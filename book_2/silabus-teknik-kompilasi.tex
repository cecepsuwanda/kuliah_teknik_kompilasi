\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[bahasa]{babel}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{url}
\usepackage{xurl}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{longtable}

\geometry{margin=2.5cm}

\title{\textbf{SILABUS MATA KULIAH}\\
       \textbf{TEKNIK KOMPILASI}\\
       \large Program Studi S1 Teknik Informatika\\
       \large 3 SKS, 16 Pertemuan\\
       \large Kurikulum Berbasis Outcome (OBE)}
\author{}
\date{}

\begin{document}

\maketitle

\section{Deskripsi Mata Kuliah}

Mata kuliah Teknik Kompilasi memberikan pemahaman dan keterampilan praktis dalam merancang dan mengimplementasikan kompilator untuk bahasa pemrograman. Sesuai dengan pendekatan Outcome-Based Education (OBE), mata kuliah ini menekankan pembelajaran berbasis praktik di mana mahasiswa akan membangun komponen-komponen kompilator secara bertahap menggunakan bahasa pemrograman C atau C++.

Mata kuliah ini mencakup fase-fase kompilator dari analisis leksikal, analisis sintaksis, analisis semantik, hingga generasi kode. Sebagai landasan, definisi kompilator menurut sumber terbuka adalah sebagai berikut:

\begin{quote}
``A compiler is a program that translates source code written in a programming language (the source language) into another language (the target language), often machine code or intermediate representation. Compilers typically perform several phases: lexical analysis, syntax analysis, semantic analysis, intermediate code generation, optimization, and code generation.''\footnote{\url{https://ucsd-cse231.github.io/sp24/}}
\end{quote}

Lebih lanjut, menurut sumber terbuka dari universitas:

\begin{quote}
``A typical compiler front end comprises several sequential phases: lexical analysis (scanning), syntax analysis (parsing), and semantic analysis. Lexical analysis breaks input text into lexemes which correspond to tokens, eliminating comments and whitespace. Syntax analysis checks grammar validity and builds a structural representation (parse tree or AST). Semantic analysis performs scope resolution, type checking, name resolution, and checks language-specific semantic rules.''\footnote{\href{https://diznr.com/six-phases-of-compiler-lexical-syntax-semantic-intermediate-code-generation-optimization-code/}{diznr.com/six-phases-of-compiler}}
\end{quote}

\section{Capaian Pembelajaran Mata Kuliah (CPMK) / Course Learning Outcomes (CLOs)}

Mata kuliah ini dirancang untuk mencapai capaian pembelajaran berikut, yang selaras dengan kurikulum Outcome-Based Education:

\subsection{CPMK 1: Pemahaman Konsep Kompilator}
Setelah menyelesaikan mata kuliah ini, mahasiswa mampu \textbf{menjelaskan} arsitektur kompilator secara keseluruhan, termasuk fase-fase utama: analisis leksikal, parsing, analisis semantik, generasi kode intermediate, optimasi, dan generasi kode.

\begin{quote}
``By the end of this Compiler Techniques course, students will be able to explain the overall architecture of a compiler, including its major phases—lexical analysis, parsing, semantic analysis, intermediate code generation, optimization, and code generation.''\footnote{\url{https://www.scribd.com/document/855675874/OBE-CSE}}
\end{quote}

\textit{Level Kognitif:} Memahami (Bloom's Taxonomy)\\
\textit{Alat Penilaian:} Kuis, UTS, Tugas Presentasi

\subsection{CPMK 2: Implementasi Lexer dan Parser}
Mahasiswa mampu \textbf{membangun} lexer dan parser menggunakan grammar formal (misalnya regular expressions, context-free grammars), finite automata (NFA/DFA), dan teknik parsing top-down dan bottom-up.

\begin{quote}
``Build lexical analyzers and parsers using formal grammars (e.g. regular expressions, context-free grammars), finite automata (NFA/DFA), top-down and bottom-up parsing techniques.''\footnote{\href{https://studylib.net/doc/14111770/outcomes-based-education-curricula--academic-year-2015-}{https://studylib.net/doc/14111770/outcomes-based-education-curricula}}
\end{quote}

\textit{Level Kognitif:} Menerapkan/Mencipta (Bloom's Taxonomy)\\
\textit{Alat Penilaian:} Tugas Praktikum 1-4, Project Intermediate

\subsection{CPMK 3: Analisis Semantik}
Mahasiswa mampu \textbf{menerapkan} syntax-directed translation dan analisis semantik untuk menegakkan aturan bahasa, menyelesaikan tipe, mengelola scope, dan menangani error.

\begin{quote}
``Apply syntax-directed translation and semantic analysis to enforce language rules, resolve types, manage scopes, and handle errors.''\footnote{\url{https://www.scribd.com/document/751408118/OBE-semester}}
\end{quote}

\textit{Level Kognitif:} Menerapkan/Menganalisis (Bloom's Taxonomy)\\
\textit{Alat Penilaian:} Tugas Praktikum 5-7, Project Intermediate

\subsection{CPMK 4: Representasi Kode Intermediate dan Optimasi}
Mahasiswa mampu \textbf{merancang dan menghasilkan} representasi kode intermediate (misalnya three-address code, DAGs) dan melakukan optimasi yang tidak bergantung pada mesin (optimasi basic block, data-flow analysis).

\begin{quote}
``Design and generate intermediate code representations (e.g., three-address code, DAGs) and perform machine-independent optimizations (basic block optimizations, data-flow analysis).''\footnote{\url{https://www.scribd.com/document/855675874/OBE-CSE}}
\end{quote}

\textit{Level Kognitif:} Mencipta/Mengevaluasi (Bloom's Taxonomy)\\
\textit{Alat Penilaian:} Tugas Praktikum 8-10, Project Final

\subsection{CPMK 5: Generasi Kode}
Mahasiswa mampu \textbf{mengimplementasikan} generasi kode untuk arsitektur target, memetakan kode intermediate menjadi kode target yang efisien, mengelola struktur run-time (activation records, memory layout, symbol tables), dan menerapkan optimasi khusus mesin dasar.

\begin{quote}
``Implement code generation for a target architecture, mapping intermediate code into efficient target code, managing run-time structures (activation records, memory layout, symbol tables), and applying basic machine-specific optimizations.''\footnote{\href{https://studylib.net/doc/14111770/outcomes-based-education-curricula--academic-year-2015-}{https://studylib.net/doc/14111770/outcomes-based-education-curricula}}
\end{quote}

\textit{Level Kognitif:} Menerapkan/Mencipta (Bloom's Taxonomy)\\
\textit{Alat Penilaian:} Tugas Praktikum 11-13, Project Final

\subsection{CPMK 6: Evaluasi Alat dan Pendekatan}
Mahasiswa mampu \textbf{mengevaluasi} dan membandingkan alat kompilator (seperti parser generators) dan pendekatan optimasi, menganalisis trade-off antara waktu kompilasi, kualitas kode, dan efisiensi runtime.

\begin{quote}
``Evaluate and compare compiler tools (like parser generators) and optimization approaches, analyze trade-offs between compilation time, code quality, and runtime efficiency.''\footnote{\url{https://www.cs.ox.ac.uk/teaching/courses/2024-2025/com/}}
\end{quote}

\textit{Level Kognitif:} Mengevaluasi/Menganalisis (Bloom's Taxonomy)\\
\textit{Alat Penilaian:} Tugas Review Paper, Diskusi Kelas, UAS

\section{Pokok Bahasan per Pertemuan}

\subsection{Pertemuan 1: Pengenalan Kompilator dan Fase-Fase Kompilasi}
\textbf{Topic:} Overview kompilator, fase-fase kompilasi, pendahuluan analisis leksikal

\begin{quote}
``A compiler is a program that translates source code written in a programming language (the source language) into another language (the target language), often machine code or intermediate representation.''\footnote{\url{https://ucsd-cse231.github.io/sp24/}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Memahami konsep kompilator melalui studi literatur
    \item Analisis contoh kompilator sederhana (misalnya TCC, TinyCC)
    \item Diskusi tentang fase-fase kompilasi: lexical analysis, parsing, semantic analysis, code generation
    \item Setup environment development (C/C++ compiler, Git, editor)
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Laporan ringkasan fase-fase kompilasi
    \item Diagram arsitektur kompilator sederhana
    \item Environment setup yang siap digunakan
\end{itemize}

\subsection{Pertemuan 2: Regular Expression dan Finite Automata untuk Lexical Analysis}
\textbf{Topic:} Regular languages, finite automata (NFA/DFA), hubungan dengan tokenisasi

\begin{quote}
``Lexical analysis breaks input text into lexemes which correspond to tokens. Usually implemented using regular languages → regex → NFA → DFA → (minimized) DFA for efficiency.''\footnote{\url{https://www.sw.it.aoyama.ac.jp/2025/Compiler/lecture5.html}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Implementasi NFA dan DFA sederhana dalam C/C++
    \item Konversi regular expression ke NFA menggunakan algoritma Thompson
    \item Konversi NFA ke DFA menggunakan subset construction
    \item Mini project: membuat recognizer untuk pattern sederhana (identifier, number, string)
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Source code NFA/DFA simulator dalam C/C++
    \item Program recognizer untuk token sederhana
    \item Laporan dokumentasi algoritma yang diimplementasikan
\end{itemize}

\subsection{Pertemuan 3: Implementasi Lexer Sederhana (Hand-Written)}
\textbf{Topic:} Implementasi lexer manual, state machine, token classification

\begin{quote}
``Hand-written lexers are possible: directly code a state machine, or use manual scanning logic. Requires careful handling of edge cases (e.g. unclosed strings/comments).''\footnote{\url{https://iq.opengenus.org/build-lexer/}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Implementasi lexer sederhana untuk subset bahasa C (identifier, keyword, literal, operator)
    \item Handling whitespace dan komentar (single-line dan multi-line)
    \item Error handling untuk token tidak valid
    \item Unit testing untuk berbagai kasus input
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Source code lexer hand-written dalam C/C++
    \item Test cases lengkap (valid dan invalid input)
    \item Dokumentasi token types dan token structure
\end{itemize}

\subsection{Pertemuan 4: Lexer Generator (Flex/re2c) dan Praktikum Lexer}
\textbf{Topic:} Menggunakan lexer generator, specification file, integrasi dengan parser

\begin{quote}
``re2c is a high-performance lexer generator for C/C++ that takes regex specifications and builds deterministic finite automata. It's used in real projects.''\footnote{\url{https://en.wikipedia.org/wiki/Re2c}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Tutorial menggunakan Flex atau re2c
    \item Membuat specification file untuk lexer bahasa sederhana
    \item Generate lexer code dan integrasikan dengan program utama
    \item Membandingkan hand-written vs generator-based lexer
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Flex/re2c specification file (.l atau .re)
    \item Generated lexer code
    \item Program yang menggunakan generated lexer
    \item Perbandingan performa dan kemudahan maintenance
\end{itemize}

\textbf{Tugas Praktikum 1 (Due: Pertemuan 5):} Implementasi lexer lengkap untuk bahasa mini dengan minimal 10 token types

\subsection{Pertemuan 5: Context-Free Grammar dan Pengenalan Parsing}
\textbf{Topic:} Grammar formal, context-free grammar, derivation, parse tree

\begin{quote}
``Given the stream of tokens from the lexer, syntax analysis checks whether they form a valid sequence under the language grammar. Builds a parse tree or AST that represents nested structure of language constructs.''\footnote{\href{https://diznr.com/six-phases-of-compiler-lexical-syntax-semantic-intermediate-code-generation-optimization-code/}{diznr.com/six-phases-of-compiler}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Mempelajari notasi BNF dan EBNF
    \item Menulis grammar untuk ekspresi aritmatika sederhana
    \item Manual parsing untuk memahami konsep derivation
    \item Membuat parse tree untuk contoh kalimat
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Grammar specification dalam BNF/EBNF
    \item Parse tree untuk beberapa contoh kalimat
    \item Presentasi grammar yang dirancang
\end{itemize}

\subsection{Pertemuan 6: Top-Down Parsing dan Recursive Descent}
\textbf{Topic:} LL parsing, recursive descent parser, predictive parsing

\begin{quote}
``Top-down parsers (recursive descent) – easy to hand-write; better for LL(1) grammars, when unambiguous. Works by writing functions for grammar nonterminals (e.g. expression(), term(), factor()) that consume tokens one at a time.''\footnote{\url{https://iq.opengenus.org/build-lexer/}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Implementasi recursive descent parser untuk ekspresi aritmatika
    \item Handling precedence dan associativity
    \item Error recovery pada recursive descent
    \item Integrasi lexer dengan parser recursive descent
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Source code recursive descent parser dalam C/C++
    \item Parser yang dapat mengevaluasi ekspresi aritmatika
    \item Error messages yang informatif
\end{itemize}

\subsection{Pertemuan 7: Bottom-Up Parsing dan LR Parser}
\textbf{Topic:} LR parsing, shift-reduce, parser table construction

\begin{quote}
``Bottom-up parsers (LR, LALR, GLR) – more powerful; often generated by tools like Bison/Yacc. The choice affects ease of specification and parsing power.''\footnote{\href{https://diznr.com/six-phases-of-compiler-lexical-syntax-semantic-intermediate-code-generation-optimization-code/}{diznr.com/six-phases-of-compiler}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Memahami konsep shift-reduce parsing
    \item Konstruksi LR(1) parsing table (manual untuk grammar kecil)
    \item Implementasi atau menggunakan LR parser generator
    \item Membandingkan top-down vs bottom-up parsing
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item LR parsing table untuk grammar contoh
    \item Dokumentasi proses konstruksi table
    \item Analisis perbandingan parsing techniques
\end{itemize}

\subsection{Pertemuan 8: Parser Generator (Bison/Yacc) dan Praktikum Parser}
\textbf{Topic:} Menggunakan parser generator, grammar specification, semantic actions

\begin{quote}
``Bison / YACC: define grammar in a .y file, specify \%token s, grammar rules, actions, etc. Generates C parser (or C++ variants). Flex + Bison: use Flex to build the lexer (.l file), Bison for parser, integrate them via tokens.''\footnote{\url{https://en.ittrip.xyz/c-language/c-parser-flex-bison}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Tutorial Bison: membuat grammar file
    \item Integrasi Flex lexer dengan Bison parser
    \item Menambahkan semantic actions untuk membangun AST
    \item Error handling dalam Bison
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Bison grammar file (.y) untuk bahasa sederhana
    \item Generated parser code
    \item Program lengkap: lexer + parser + AST builder
\end{itemize}

\textbf{Tugas Praktikum 2 (Due: Pertemuan 9):} Implementasi parser lengkap menggunakan Flex+Bison untuk subset bahasa C (ekspresi, statements dasar)

\subsection{Pertemuan 9: Abstract Syntax Tree (AST) dan Struktur Data}
\textbf{Topic:} Representasi AST, node types, tree traversal

\begin{quote}
``Abstract Syntax Trees represent the nested structure of language constructs (expressions, statements, declarations). AST representation: whether nodes represent every symbol from the grammar or a simplified form; whether annotations (types, scopes) are added later.''\footnote{\href{https://diznr.com/six-phases-of-compiler-lexical-syntax-semantic-intermediate-code-generation-optimization-code/}{diznr.com/six-phases-of-compiler}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Desain struktur data AST (node hierarchy)
    \item Implementasi AST node classes/structs dalam C/C++
    \item Tree traversal: pre-order, post-order, in-order
    \item Modifikasi parser untuk membangun AST (bukan parse tree)
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Header file definisi AST nodes
    \item Implementation AST builder
    \item AST visualizer (text atau graphical)
    \item Tree traversal utilities
\end{itemize}

\subsection{Pertemuan 10: Symbol Table dan Scope Management}
\textbf{Topic:} Symbol table implementation, scoping rules, name resolution

\begin{quote}
``Symbol tables: data structures mapping names to declarations, with nested scopes. Semantic analysis includes name resolution: every use of a variable, function, type must refer to a declaration.''\footnote{\url{https://nguyenthanhvuh.github.io/class-compilers/notes/sem.html}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Implementasi symbol table menggunakan hash table
    \item Mendukung nested scopes (stack of symbol tables)
    \item Name resolution: lookup dalam scope hierarchy
    \item Handling scope entry/exit (function, block)
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Source code symbol table implementation
    \item Test cases untuk scope nesting
    \item Visualisasi symbol table untuk contoh program
\end{itemize}

\textbf{Tugas Praktikum 3 (Due: Pertemuan 11):} Implementasi symbol table dengan support nested scopes

\subsection{Pertemuan 11: Type Checking dan Semantic Analysis}
\textbf{Topic:} Type system, type checking rules, semantic error detection

\begin{quote}
``Type checking: operator operands must be type-compatible. Return types match declared types. Implicit/explicit conversions. Semantic analysis ensures that the parse tree makes sense under language rules.''\footnote{\url{https://nguyenthanhvuh.github.io/class-compilers/notes/sem.html}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Implementasi type checker untuk ekspresi aritmatika
    \item Type inference untuk literal dan operasi
    \item Type compatibility checking
    \item Semantic error reporting (undeclared variable, type mismatch, dll)
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Source code type checker
    \item Test cases dengan berbagai error scenarios
    \item Error messages yang jelas dan informatif
\end{itemize}

\subsection{Pertemuan 12: Intermediate Code Generation}
\textbf{Topic:} Three-address code, quadruples, code generation dari AST

\begin{quote}
``Intermediate code generation transforms AST to IR (three-address code, bytecode, etc.). Design and generate intermediate code representations (e.g., three-address code, DAGs).''\footnote{\url{https://iq.opengenus.org/build-lexer/}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Desain format three-address code (TAC)
    \item Implementasi TAC generator dari AST
    \item Handling berbagai statement types (assignment, if, loop)
    \item Optimasi dasar: common subexpression elimination
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item TAC generator implementation
    \item Contoh output TAC untuk program contoh
    \item Dokumentasi format TAC yang digunakan
\end{itemize}

\textbf{Tugas Praktikum 4 (Due: Pertemuan 13):} Implementasi semantic analyzer lengkap dengan type checking dan TAC generation

\subsection{Pertemuan 13: Runtime Environment dan Memory Management}
\textbf{Topic:} Activation records, stack frame, heap management, garbage collection intro

\begin{quote}
``Runtime environment: stack, heap, activation records; garbage collection intro. Managing run-time structures (activation records, memory layout, symbol tables).''\footnote{\href{https://studylib.net/doc/14111770/outcomes-based-education-curricula--academic-year-2015-}{https://studylib.net/doc/14111770/outcomes-based-education-curricula}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Memahami konsep activation record dan stack frame
    \item Simulasi runtime stack untuk function calls
    \item Memory layout: static, stack, heap
    \item Pengenalan garbage collection strategies
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Simulator runtime stack
    \item Diagram memory layout untuk contoh program
    \item Laporan tentang runtime organization
\end{itemize}

\subsection{Pertemuan 14: Code Generation untuk Target Architecture}
\textbf{Topic:} Instruction selection, register allocation, target code generation

\begin{quote}
``Code generation: instruction selection, machine model. Implement code generation for a target architecture, mapping intermediate code into efficient target code, managing run-time structures.''\footnote{\href{https://studylib.net/doc/14111770/outcomes-based-education-curricula--academic-year-2015-}{https://studylib.net/doc/14111770/outcomes-based-education-curricula}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Mapping TAC ke assembly instructions (x86 atau RISC-V subset)
    \item Register allocation sederhana (local allocation)
    \item Code generation untuk arithmetic operations, assignments
    \item Handling function calls (calling convention)
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Code generator implementation
    \item Assembly output untuk program contoh
    \item Test: compile → assemble → link → run
\end{itemize}

\subsection{Pertemuan 15: Optimasi Kompilator Dasar}
\textbf{Topic:} Basic block optimization, constant folding, dead code elimination

\begin{quote}
``Perform machine-independent optimizations (basic block optimizations, data-flow analysis). Local and global optimization; data-flow analysis.''\footnote{\url{https://www.scribd.com/document/855675874/OBE-CSE}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Identifikasi basic blocks dalam TAC
    \item Implementasi optimasi: constant folding, constant propagation
    \item Dead code elimination
    \item Evaluasi efektivitas optimasi
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Optimizer implementation
    \item Before/after comparison (code size, execution time)
    \item Benchmark hasil optimasi
\end{itemize}

\textbf{Tugas Praktikum 5 (Due: Pertemuan 16):} Implementasi code generator dengan optimasi dasar

\subsection{Pertemuan 16: Project Final Presentation dan Review}
\textbf{Topic:} Presentasi project final, review seluruh materi, diskusi tool dan trade-off

\begin{quote}
``Evaluate and compare compiler tools (like parser generators) and optimization approaches, analyze trade-offs between compilation time, code quality, and runtime efficiency.''\footnote{\url{https://www.cs.ox.ac.uk/teaching/courses/2024-2025/com/}}
\end{quote}

\textbf{Learning Activities:}
\begin{itemize}
    \item Presentasi project final (working compiler)
    \item Demo: compile dan run program dalam bahasa yang dirancang
    \item Diskusi perbandingan hand-written vs generator tools
    \item Refleksi pembelajaran dan evaluasi diri
\end{itemize}

\textbf{Expected Artifacts:}
\begin{itemize}
    \item Final project: working compiler lengkap
    \item Dokumentasi proyek (README, design doc)
    \item Demo video atau live demo
    \item Laporan evaluasi tools dan teknik yang digunakan
\end{itemize}

\section{Rencana Evaluasi (Assessment Plan)}

Evaluasi pembelajaran dirancang untuk mengukur pencapaian setiap CPMK sesuai dengan prinsip Outcome-Based Education:

\subsection{Evaluasi Formatif}
\begin{itemize}
    \item \textbf{Kuis (10\%):} Dilakukan 2-3 kali selama semester untuk mengukur pemahaman konsep (CPMK 1)
    \item \textbf{Tugas Praktikum (40\%):} 
    \begin{itemize}
        \item Tugas Praktikum 1: Lexer Implementation (CPMK 2) - 8\%
        \item Tugas Praktikum 2: Parser Implementation (CPMK 2) - 10\%
        \item Tugas Praktikum 3: Symbol Table (CPMK 3) - 8\%
        \item Tugas Praktikum 4: Semantic Analysis + TAC (CPMK 3, 4) - 8\%
        \item Tugas Praktikum 5: Code Generation (CPMK 5) - 6\%
    \end{itemize}
\end{itemize}

\subsection{Evaluasi Sumatif}
\begin{itemize}
    \item \textbf{Ujian Tengah Semester (UTS) (20\%):} Mengukur CPMK 1, 2, dan sebagian CPMK 3
    \item \textbf{Project Final (25\%):} 
    \begin{itemize}
        \item Membangun compiler lengkap untuk bahasa sederhana
        \item Mencakup semua fase: lexer, parser, semantic, code generation
        \item Dokumentasi dan presentasi
        \item Mengukur CPMK 2, 3, 4, 5
    \end{itemize}
    \item \textbf{Ujian Akhir Semester (UAS) (15\%):} 
    \begin{itemize}
        \item Mengukur semua CPMK dengan fokus evaluasi kritis (CPMK 6)
        \item Pertanyaan analisis dan evaluasi tools/teknik
    \end{itemize}
\end{itemize}

\subsection{Rubrik Penilaian}
Setiap tugas praktikum dinilai berdasarkan:
\begin{itemize}
    \item \textbf{Correctness (40\%):} Program berjalan dengan benar, mengatasi edge cases
    \item \textbf{Code Quality (30\%):} Struktur kode, readability, dokumentasi
    \item \textbf{Completeness (20\%):} Semua requirement terpenuhi
    \item \textbf{Testing (10\%):} Test cases yang komprehensif
\end{itemize}

\section{Daftar Referensi}

\subsection{Buku Teks}
\begin{enumerate}
    \item Aho, A. V., Lam, M. S., Sethi, R., \& Ullman, J. D. (2006). \textit{Compilers: Principles, Techniques, and Tools} (2nd ed.). Pearson Education. (Dragon Book)
    
    \item Cooper, K. D., \& Torczon, L. (2011). \textit{Engineering a Compiler} (2nd ed.). Morgan Kaufmann.
    
    \item Levine, J. R. (2009). \textit{flex \& bison: Text Processing Tools}. O'Reilly Media.
\end{enumerate}

\subsection{Referensi Online Terbuka}
\begin{enumerate}
    \item UC San Diego CSE 231: Compiler Construction. \url{https://ucsd-cse231.github.io/sp24/}\\
    \textit{Kutipan:} ``A compiler is a program that translates source code written in a programming language (the source language) into another language (the target language), often machine code or intermediate representation.''
    
    \item Northeastern University CS 4410/6410: Compiler Design. \url{https://course.ccs.neu.edu/cs4410sp25/}\\
    \textit{Kutipan:} ``A comprehensive compiler design course emphasizing both theory and implementation. Students build a working compiler covering: lexical analysis, parsing, type checking, code generation, register allocation, runtime issues, and optimization.''
    
    \item Johns Hopkins University EN.601.428/628: Compilers and Interpreters. \url{https://jhucompilers.github.io/fall2025/syllabus.html}\\
    \textit{Kutipan:} ``A standard 3-credit course focusing on core compiler components: syntax trees, symbol tables, translation, code generation, and optimization. Students write a full compiler.''
    
    \item University of Washington CSE P 501. \url{https://courses.cs.washington.edu/courses/csep501/21au/syllabus.html}\\
    \textit{Kutipan:} ``Covers basic to advanced topics: scanner/parser, symbol tables, semantics, code generation and optimization. Course project to build a compiler translating a subset of Java into x86-64 assembly.''
    
    \item Diznr - Six Phases of Compiler. \url{https://diznr.com/six-phases-of-compiler-lexical-syntax-semantic-intermediate-code-generation-optimization-code/}\\
    \textit{Kutipan:} ``A typical compiler front end comprises several sequential phases: lexical analysis, syntax analysis, and semantic analysis. Lexical analysis breaks input text into lexemes which correspond to tokens, eliminating comments and whitespace.''
    
    \item Aoyama Gakuin University - Compiler Lecture 5. \url{https://www.sw.it.aoyama.ac.jp/2025/Compiler/lecture5.html}\\
    \textit{Kutipan:} ``Lexical analysis breaks input text into lexemes which correspond to tokens. Usually implemented using regular languages → regex → NFA → DFA → (minimized) DFA for efficiency.''
    
    \item OpenGenus - Build Lexer. \url{https://iq.opengenus.org/build-lexer/}\\
    \textit{Kutipan:} ``Hand-written lexers are possible: directly code a state machine, or use manual scanning logic. Requires careful handling of edge cases (e.g. unclosed strings/comments). Top-down parsers (recursive descent) – easy to hand-write; better for LL(1) grammars, when unambiguous.''
    
    \item Wikipedia - re2c. \url{https://en.wikipedia.org/wiki/Re2c}\\
    \textit{Kutipan:} ``re2c is a high-performance lexer generator for C/C++ that takes regex specifications and builds deterministic finite automata. It's used in real projects.''
    
    \item Wikipedia - RE/flex. \url{https://en.wikipedia.org/wiki/Draft:RE/flex}\\
    \textit{Kutipan:} ``RE/flex: A modern C++ lexical analyzer generator. It improves on Flex by supporting Unicode, thread safety, lazy quantifiers, better performance tuning.''
    
    \item IT Trip - C Parser Flex Bison. \url{https://en.ittrip.xyz/c-language/c-parser-flex-bison}\\
    \textit{Kutipan:} ``Bison / YACC: define grammar in a .y file, specify \%token s, grammar rules, actions, etc. Generates C parser (or C++ variants). Flex + Bison: use Flex to build the lexer (.l file), Bison for parser, integrate them via tokens.''
    
    \item Nguyen Thanh Vu - Compiler Class Notes - Semantic Analysis. \url{https://nguyenthanhvuh.github.io/class-compilers/notes/sem.html}\\
    \textit{Kutipan:} ``Semantic analysis ensures that the parse tree makes sense under language rules. Tasks include: name resolution: every use of a variable, function, type must refer to a declaration. Type checking: operator operands must be type-compatible.''
    
    \item University of Oxford - Compilers Course. \url{https://www.cs.ox.ac.uk/teaching/courses/2024-2025/com/}\\
    \textit{Kutipan:} ``Evaluate and compare compiler tools (like parser generators) and optimization approaches, analyze trade-offs between compilation time, code quality, and runtime efficiency.''
    
    \item Scribd - OBE CSE Document. \url{https://www.scribd.com/document/855675874/OBE-CSE}\\
    \textit{Kutipan:} ``By the end of this Compiler Techniques course, students will be able to explain the overall architecture of a compiler, including its major phases—lexical analysis, parsing, semantic analysis, intermediate code generation, optimization, and code generation. Design and generate intermediate code representations (e.g., three-address code, DAGs) and perform machine-independent optimizations (basic block optimizations, data-flow analysis).''
    
    \item StudyLib - Outcomes-Based Education Curricula. \href{https://studylib.net/doc/14111770/outcomes-based-education-curricula--academic-year-2015-}{https://studylib.net/doc/14111770/outcomes-based-education-curricula}\\
    \textit{Kutipan:} ``Build lexical analyzers and parsers using formal grammars (e.g. regular expressions, context-free grammars), finite automata (NFA/DFA), top-down and bottom-up parsing techniques. Implement code generation for a target architecture, mapping intermediate code into efficient target code, managing run-time structures (activation records, memory layout, symbol tables), and applying basic machine-specific optimizations.''
    
    \item Scribd - OBE Semester Document. \url{https://www.scribd.com/document/751408118/OBE-semester}\\
    \textit{Kutipan:} ``Apply syntax-directed translation and semantic analysis to enforce language rules, resolve types, manage scopes, and handle errors.''
\end{enumerate}

\subsection{Tools dan Software}
\begin{itemize}
    \item Flex (Fast Lexical Analyzer): \url{https://github.com/westes/flex}
    \item GNU Bison: \url{https://www.gnu.org/software/bison/}
    \item re2c: \url{https://re2c.org/}
    \item LLVM (untuk advanced study): \url{https://llvm.org/}
    \item GCC source code (untuk referensi): \url{https://gcc.gnu.org/}
\end{itemize}

\subsection{Proyek Open Source untuk Referensi}
\begin{itemize}
    \item TinyCC (TCC): \url{https://bellard.org/tcc/} - Kompilator C kecil dan cepat
    \item AnjaneyaTripathi's C Compiler: \url{https://github.com/AnjaneyaTripathi/c-compiler} - Contoh implementasi compiler sederhana dengan Lex \& Yacc
    \item Petit Programming Language: \url{https://arxiv.org/abs/2311.14443} - Tutorial compiler lengkap dengan LLVM IR
\end{itemize}

\vspace{1cm}
\noindent\textit{Dokumen ini disusun berdasarkan Outcome-Based Education (OBE) dan menggunakan referensi terbuka yang dapat diverifikasi secara online. Setiap kutipan langsung dari sumber disertai dengan URL untuk memastikan transparansi dan akuntabilitas akademik.}

\end{document}
