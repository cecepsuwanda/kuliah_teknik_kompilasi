\section{Integrasi AST dengan Parser}

Parser perlu dimodifikasi untuk membangun AST selama proses parsing, bukan hanya memverifikasi grammar. Berikut adalah contoh integrasi dengan Bison parser generator.

\subsection{Bison Grammar dengan AST Building}

\begin{lstlisting}[language=C++, caption=Bison Grammar dengan AST Building]
%{
#include "ASTNode.hpp"
#include "Expression.hpp"
#include "Statement.hpp"
#include "Program.hpp"
%}

%union {
    int intVal;
    char* strVal;
    Expr* expr;
    Stmt* stmt;
    Program* program;
}

%token <intVal> INT_LITERAL
%token <strVal> IDENTIFIER
%token PLUS MINUS MULTIPLY DIVIDE
%token ASSIGN SEMICOLON
%token IF ELSE WHILE RETURN
%token LBRACE RBRACE LPAREN RPAREN

%type <expr> expression
%type <stmt> statement block_statement
%type <program> program

%%

program:
    statement_list {
        $$ = new Program();
        // Add statements to program
    }
    ;

statement_list:
    statement_list statement {
        // Add statement to list
    }
  | /* empty */
    ;

statement:
    expression SEMICOLON {
        $$ = new ExprStmt($1);
    }
  | IDENTIFIER ASSIGN expression SEMICOLON {
        auto id = new Identifier($1);
        $$ = new AssignStmt(std::unique_ptr<Identifier>(id), 
                            std::unique_ptr<Expr>($3));
    }
  | block_statement
    ;

block_statement:
    LBRACE statement_list RBRACE {
        $$ = new BlockStmt();
        // Add statements to block
    }
    ;

expression:
    INT_LITERAL {
        $$ = new IntLiteral($1);
    }
  | IDENTIFIER {
        $$ = new Identifier($1);
    }
  | expression PLUS expression {
        $$ = new BinaryExpr("+", 
                           std::unique_ptr<Expr>($1),
                           std::unique_ptr<Expr>($3));
    }
  | expression MINUS expression {
        $$ = new BinaryExpr("-",
                           std::unique_ptr<Expr>($1),
                           std::unique_ptr<Expr>($3));
    }
  | expression MULTIPLY expression {
        $$ = new BinaryExpr("*",
                           std::unique_ptr<Expr>($1),
                           std::unique_ptr<Expr>($3));
    }
  | expression DIVIDE expression {
        $$ = new BinaryExpr("/",
                           std::unique_ptr<Expr>($1),
                           std::unique_ptr<Expr>($3));
    }
  | LPAREN expression RPAREN {
        $$ = $2;
    }
  ;

%%
\end{lstlisting}