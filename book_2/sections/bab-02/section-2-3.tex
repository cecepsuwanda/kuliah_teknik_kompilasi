\section{Alur Kerja dan Arsitektur Kompilator}

\subsection{Alur Kerja Kompilator: Dari Source ke Executable}

Proses kompilasi bukanlah langkah tunggal, melainkan sebuah rantai produksi (\textit{pipeline}) yang mentransformasi data dari satu bentuk ke bentuk lain. Gambar \ref{fig:compiler-flow} mengilustrasikan perjalanan kode sumber: dimulai dari pre-processing yang menangani makro, masuk ke kompilator inti untuk diubah menjadi bahasa assembly tingkat rendah, lalu diteruskan ke assembler untuk menjadi kode objek biner, dan akhirnya disatukan oleh Linker dengan pustaka eksternal menjadi file eksekusi utuh. Pemahaman tentang rantai alat (\textit{toolchain}) ini penting bagi seorang \textit{systems programmer}.

\begin{figure}[!htbp]
\centering
\adjustbox{max width=0.85\textwidth,center}{%
\begin{tikzpicture}[
    process/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.5cm, text centered, minimum height=0.6cm, rounded corners, font=\footnotesize},
    output/.style={rectangle, draw=green!50, fill=green!10, text width=2cm, text centered, minimum height=0.5cm, rounded corners, font=\tiny},
    arrow/.style={->, >=stealth, thick}
]
    \node[process] (source) {\textbf{Source Code}\\\footnotesize(C, C++, dll.)};
    \node[process, below=0.6cm of source] (preproc) {\textbf{Preprocessing}};
    \node[process, below=0.6cm of preproc] (compiler) {\textbf{Compiler}};
    \node[output, right=1cm of compiler] (asm) {Assembly Code};
    \node[process, below=0.6cm of compiler] (assemble) {\textbf{Assembler}};
    \node[output, right=1cm of assemble] (obj) {Object Code};
    \node[process, below=0.6cm of assemble] (link) {\textbf{Linker}};
    \node[output, right=1cm of link] (exe) {\textbf{Executable}};
    
    \draw[arrow] (source) -- (preproc);
    \draw[arrow] (preproc) -- (compiler);
    \draw[arrow] (compiler) -- (asm);
    \draw[arrow] (compiler) -- (assemble);
    \draw[arrow] (assemble) -- (obj);
    \draw[arrow] (assemble) -- (link);
    \draw[arrow] (link) -- (exe);
\end{tikzpicture}%
}
\caption{Alur kerja sistem kompilasi standar (GNU Toolchain model)}
\label{fig:compiler-flow}
\end{figure}

\subsection{Arsitektur Tiga Tingkat: Front-end, Middle-end, Back-end}

Meskipun secara tradisional kita membagi kompilator menjadi dua (Front-end dan Back-end), kompilator modern seperti LLVM memperkenalkan arsitektur tiga tingkat yang revolusioner.

\begin{itemize}
    \item \textbf{Front-end (Analisis)}: Bertanggung jawab memahami kode sumber. Sifatnya spesifik terhadap bahasa (misal: Clang untuk C/C++, Rustc untuk Rust). Tugasnya memvalidasi sintaks/semantik dan menghasilkan \textit{Intermediate Representation} (IR).
    \item \textbf{Middle-end (Optimasi)}: Jantung dari efisiensi kompilator. Bekerja sepenuhnya pada IR dan bersifat agnostik terhadap bahasa sumber maupun mesin target. Di sinilah optimasi matematika tingkat tinggi seperti \textit{Dead Code Elimination} dan \textit{Loop Unrolling} terjadi.
    \item \textbf{Back-end (Sintesis)}: Bertanggung jawab menerjemahkan IR yang sudah dioptimasi ke dalam instruksi mesin spesifik (misal: x86-64, ARM64, RISC-V). Sifatnya spesifik terhadap target hardware.
\end{itemize}

Keunggulan desain ini adalah \textbf{retargetability}. Untuk membuat kompilator bahasa baru ke 10 arsitektur mesin, kita hanya perlu membuat 1 Front-end, bukan 10 kompilator penuh. Masalah $N \times M$ (bahasa $\times$ target) direduksi menjadi $N + M$.

\begin{figure}[!htbp]
    \centering
    \adjustbox{max width=0.9\textwidth,center}{%
    \begin{tikzpicture}[
        box/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.0cm, text centered, minimum height=0.9cm, rounded corners, font=\footnotesize, inner sep=4pt},
        arrow/.style={->, >=stealth, thick},
        section/.style={rectangle, draw=black!50, fill=gray!20, text width=2.8cm, text centered, minimum height=1.0cm, rounded corners, font=\bfseries\small, inner sep=5pt},
        irbox/.style={rectangle, draw=purple!50, fill=purple!10, text width=2.0cm, text centered, minimum height=1.0cm, rounded corners, font=\footnotesize, inner sep=4pt},
        node distance=0.6cm and 0.8cm
    ]
    
    \node[box] (source) {Source};
    \node[section, right=of source] (frontend) {FRONT-END\\(Analisis)};
    \node[irbox, right=of frontend] (ir) {IR};
    \node[section, right=of ir] (middleend) {MIDDLE-END\\(Optimasi)};
    \node[irbox, right=of middleend] (optir) {Opt IR};
    \node[section, right=of optir] (backend) {BACK-END\\(Sintesis)};
    \node[box, right=of backend] (target) {Binary};
    
    \draw[arrow] (source) -- (frontend);
    \draw[arrow] (frontend) -- (ir);
    \draw[arrow] (ir) -- (middleend);
    \draw[arrow] (middleend) -- (optir);
    \draw[arrow] (optir) -- (backend);
    \draw[arrow] (backend) -- (target);
    \end{tikzpicture}%
    }
    \caption{Arsitektur Tiga Tingkat Kompilator Modern (Model LLVM)}
    \label{fig:compiler-architecture-modern}
\end{figure}
