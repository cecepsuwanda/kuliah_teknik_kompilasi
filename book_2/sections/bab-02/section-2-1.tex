\section{Konsep dan Definisi Kunci}

\subsection{Definisi Kompilator}

Secara tradisional, kompilator dipandang sebagai "kotak hitam" yang mengubah kode sumber menjadi kode target executable. Namun, pandangan ini terlalu menyederhanakan kompleksitas yang ada di dalamnya. Menurut \cite{aho2006compilers}, kompilasi sebenarnya adalah orkestrasi dari serangkaian proses transformasi data yang presisi, di mana makna program harus dipertahankan secara utuh melintasi berbagai representasi.

Secara formal, \compiler{compiler} adalah program perangkat lunak yang membaca program yang ditulis dalam satu bahasa (bahasa sumber) dan menerjemahkannya ke dalam program yang setara dalam bahasa lain (bahasa target). Output dari kompilator biasanya adalah kode mesin atau kode assembly yang dapat dieksekusi langsung oleh perangkat keras, namun bisa juga berupa kode sumber bahasa tingkat tinggi lain (source-to-source compiler/transpiler).

\subsection{Karakteristik Kompilator}

Kompilator memiliki beberapa karakteristik unik yang membedakannya dari alat pemroses bahasa lainnya:
\begin{itemize}
    \item \textbf{Translasi Lengkap}: Kompilator menganalisis seluruh unit kompilasi (file atau modul) secara utuh sebelum menghasilkan output, memungkinkan validasi lintas baris kode.
    \item \textbf{Analisis Mendalam}: Melakukan verifikasi statis yang ketat meliputi pemeriksaan sintaksis, tipe data, dan aliran kontrol untuk menjamin keamanan program sebelum dijalankan.
    \item \textbf{Output Terpisah}: Hasil kompilasi disimpan sebagai artefak permanen (seperti file \texttt{.exe} atau \texttt{.o}) yang dapat didistribusikan dan dijalankan berulang kali tanpa memerlukan kode sumber asli.
    \item \textbf{Optimasi Matematis}: Menerapkan berbagai transformasi matematis untuk meningkatkan efisiensi eksekusi (kecepatan) dan efisiensi ruang (memori) dari kode hasil.
\end{itemize}

\subsection{Interpreter vs Compiler dan Arsitektur Hibrida}

Perbedaan klasik antara \compiler{compiler} dan \compiler{interpreter} terletak pada waktu eksekusi. Kompilator melakukan translasi sekali di awal (\textit{ahead-of-time}), sedangkan interpreter melakukan translasi baris-per-baris saat program berjalan. Namun, di era komputasi modern, batas ini semakin kabur dengan munculnya arsitektur hibrida.

Sistem seperti Java Virtual Machine (JVM) dan .NET CLR menggunakan pendekatan dua langkah: kode sumber dikompilasi menjadi \textit{bytecode} (bentuk antara yang kompak), yang kemudian dijalankan oleh interpreter atau dikompilasi ulang menjadi kode mesin asli saat runtime menggunakan teknik \textit{Just-In-Time (JIT) Compilation}. Pendekatan ini menggabungkan portabilitas interpreter dengan performa tinggi \textit{native code}.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Aspek} & \textbf{Compiler} & \textbf{Interpreter} \\
\hline
Eksekusi & Compile lalu run (AOT) & Run langsung \\
Kecepatan & Cepat (native speed) & Lambat (overhead translasi) \\
Analisis Error & Menyeluruh sebelum run & Berhenti saat error terjadi \\
Portabilitas & Perlu re-compile per OS & Kode sumber jalan di mana saja \\
Contoh & C, C++, Rust, Go & Python, Ruby, PHP \\
\hline
\end{tabular}
\caption{Perbandingan Karakteristik Compiler dan Interpreter}
\end{table}
