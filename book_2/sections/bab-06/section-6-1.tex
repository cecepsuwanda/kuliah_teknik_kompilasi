\section{Abstract Syntax Tree (AST) Deep Dive}

\subsection{Filosofi Desain AST}
AST adalah versi ''bersih'' dari Parse Tree. Jika Parse Tree merekam \textit{bagaimana} program diturunkan dari grammar (termasuk token-token sintaksis seperti \texttt{;} atau \texttt{()}), AST hanya merekam \textit{apa} isi program tersebut.
\begin{itemize}
    \item \textbf{Compact}: Tidak ada node untuk token pungtuasi.
    \item \textbf{Heterogen}: Setiap jenis node (misal \texttt{IfStmt}, \texttt{BinaryExpr}) bisa memiliki struktur C++ class yang berbeda, tidak harus seragam.
\end{itemize}

\subsection{Implementasi Titik Temu: The Visitor Pattern}
Tantangan utama AST adalah: "Bagaimana kita menambahkan operasi baru (seperti Type Checking, Code Gen, Pretty Print) tanpa mengacak-acak definisi class AST?" Solusinya adalah \textbf{Visitor Pattern}.

\begin{lstlisting}[language=C++]
// Abstract Base Class
struct Node {
    virtual void accept(Visitor* v) = 0;
};

// Concrete Node
struct BinaryExpr : Node {
    Node *left, *right;
    Token op;
    void accept(Visitor* v) override { v->visitBinary(this); }
};

// Visitor Interface
struct Visitor {
    virtual void visitBinary(BinaryExpr* node) = 0;
    virtual void visitNumber(NumberExpr* node) = 0;
};
\end{lstlisting}
Dengan pola ini, logika semantik terisolasi dalam class \texttt{SemanticAnalyzer} yang mewarisi \texttt{Visitor}, menjaga kode AST tetap bersih.
