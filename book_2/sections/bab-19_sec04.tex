\section{Jawaban Ujian Akhir Semester (UAS)}

\subsection{Jawaban Soal UAS}

\begin{enumerate}
\item \textbf{[Bab 8 - 20 poin]}

\begin{enumerate}
\item \textbf{Grammar specification untuk Bison/Yacc}

\textbf{Grammar dengan semantic value dan precedence yang benar:}

\begin{verbatim}
%{
#include <stdio.h>
#include "ast.h"
extern int yylex();
void yyerror(const char* s);
%}

%union {
    int ival;
    ASTNode* node;
}

%token <ival> NUMBER
%type  <node> expr

%left '+' '-'
%left '*' '/'
%right UMINUS

%%
expr:
      NUMBER            { $$ = createNumberNode($1); }
    | expr '+' expr     { $$ = createBinaryNode('+', $1, $3); }
    | expr '-' expr     { $$ = createBinaryNode('-', $1, $3); }
    | expr '*' expr     { $$ = createBinaryNode('*', $1, $3); }
    | expr '/' expr     { $$ = createBinaryNode('/', $1, $3); }
    | '-' expr %prec UMINUS { $$ = createUnaryNode('-', $2); }
    | '(' expr ')'      { $$ = $2; }
;
%%
\end{verbatim}

Penjelasan:
\begin{itemize}
    \item \texttt{\%union} mendefinisikan tipe semantic value.
    \item \texttt{\%token <ival>} menentukan tipe token.
    \item \texttt{\%type <node>} menentukan tipe non-terminal.
    \item Deklarasi precedence menghindari ambiguity pada grammar ekspresi aritmetika.
\end{itemize}

\item \textbf{Handling conflicts dalam Bison}

\textbf{Shift-reduce conflict}

Contoh grammar ambigu:
\begin{verbatim}
expr: expr '+' expr
    | expr '*' expr
    | NUMBER
\end{verbatim}

Untuk input \texttt{1 + 2 * 3}, parser tidak dapat menentukan apakah harus melakukan shift atau reduce tanpa aturan precedence.

Solusi:
\begin{itemize}
    \item Menambahkan deklarasi precedence:
\begin{verbatim}
%left '+'
%left '*'
\end{verbatim}
\end{itemize}

\textbf{Reduce-reduce conflict}

Contoh grammar:
\begin{verbatim}
A: B
 | C
B: 'a'
C: 'a'
\end{verbatim}

Token \texttt{a} dapat direduksi menjadi \texttt{B} atau \texttt{C}, sehingga terjadi reduce-reduce conflict.

Solusi:
\begin{itemize}
    \item Menghilangkan ambiguity dengan memodifikasi grammar.
\end{itemize}

\item \textbf{Implementasi kalkulator dengan Flex dan Bison}

\textbf{Flex file (calc.l)}
\begin{verbatim}
%{
#include "calc.tab.h"
#include <stdlib.h>
%}
%%
[0-9]+      { yylval = atoi(yytext); return NUMBER; }
[ \t\r]+    { /* skip whitespace */ }
\n          { return 0; }
.           { return yytext[0]; }
%%
\end{verbatim}

\textbf{Bison file (calc.y)}
\begin{verbatim}
%{
#include <stdio.h>
int yylex();
void yyerror(const char* s) {
    fprintf(stderr, "Error: %s\n", s);
}
%}

%token NUMBER
%left '+' '-'
%left '*' '/'

%%
expr:
      NUMBER          { $$ = $1; }
    | expr '+' expr   { $$ = $1 + $3; }
    | expr '-' expr   { $$ = $1 - $3; }
    | expr '*' expr   { $$ = $1 * $3; }
    | expr '/' expr   {
        if ($3 == 0) yyerror("Division by zero");
        else $$ = $1 / $3;
      }
    | '(' expr ')'    { $$ = $2; }
;
%%
int main() {
    printf("Result: ");
    yyparse();
    return 0;
}
\end{verbatim}

\end{enumerate}

\item \textbf{[Bab 9 - 20 poin]}

\begin{enumerate}
\item \textbf{Struktur data AST}

AST dirancang menggunakan class hierarchy dan Visitor Pattern:

\begin{verbatim}
class ASTNode {
public:
    virtual ~ASTNode() = default;
    virtual void accept(class Visitor* v) = 0;
};

class ExprNode : public ASTNode {};

class BinaryExpr : public ExprNode {
public:
    char op;
    ExprNode* left;
    ExprNode* right;
    void accept(Visitor* v) override;
};

class NumberNode : public ExprNode {
public:
    int value;
    void accept(Visitor* v) override;
};
\end{verbatim}

\item \textbf{Post-order traversal}

Post-order traversal mengevaluasi child sebelum parent, sehingga cocok untuk code generation.

\begin{verbatim}
void traverse(ASTNode* node, Visitor* v) {
    if (!node) return;
    node->accept(v);
}
\end{verbatim}

\item \textbf{AST visualizer}

\begin{verbatim}
void printAST(ASTNode* node, int indent = 0) {
    std::string pad(indent * 2, ' ');
    if (auto* b = dynamic_cast<BinaryExpr*>(node)) {
        std::cout << pad << "BinaryExpr(" << b->op << ")\n";
        printAST(b->left, indent + 1);
        printAST(b->right, indent + 1);
    } else if (auto* n = dynamic_cast<NumberNode*>(node)) {
        std::cout << pad << "Number(" << n->value << ")\n";
    }
}
\end{verbatim}

\end{enumerate}

\item \textbf{[Bab 10 - 20 poin]}

\begin{enumerate}
\item \textbf{Symbol table dengan nested scope}

\begin{verbatim}
class SymbolTable {
private:
    std::vector<std::unordered_map<std::string, std::string>> scopes;

public:
    void enterScope() { scopes.push_back({}); }
    void exitScope() { scopes.pop_back(); }

    bool insert(const std::string& name, const std::string& type) {
        auto& scope = scopes.back();
        if (scope.count(name)) return false;
        scope[name] = type;
        return true;
    }

    std::string lookup(const std::string& name) {
        for (auto it = scopes.rbegin(); it != scopes.rend(); ++it)
            if (it->count(name)) return (*it)[name];
        return "";
    }
};
\end{verbatim}

Kompleksitas:
\begin{itemize}
    \item Insert: $O(1)$ rata-rata.
    \item Lookup: $O(s)$, dengan $s$ jumlah scope.
\end{itemize}

\item \textbf{Static vs Dynamic scoping}

Static scoping menentukan binding variabel berdasarkan struktur leksikal program, sedangkan dynamic scoping berdasarkan call stack saat runtime.

\end{enumerate}

\item \textbf{[Bab 11 - 20 poin]}

\begin{enumerate}
\item \textbf{Type checker}

\begin{verbatim}
enum Type { INT, FLOAT, BOOL, ERROR };

Type inferType(NumberNode* n) {
    return INT;
}
\end{verbatim}

\item \textbf{Semantic analysis}

Semantic analysis dilakukan dalam beberapa tahap:
\begin{enumerate}
    \item Pengumpulan deklarasi.
    \item Pemeriksaan penggunaan identifier.
    \item Pemeriksaan tipe.
\end{enumerate}

\end{enumerate}

\item \textbf{[Bab 12 - 25 poin]}

\begin{enumerate}
\item \textbf{Three-address code}

Untuk ekspresi:
\begin{verbatim}
x = (a + b) * (c - d) / e;
\end{verbatim}

TAC:
\begin{verbatim}
t1 = a + b
t2 = c - d
t3 = t1 * t2
t4 = t3 / e
x = t4
\end{verbatim}

\end{enumerate}

\item \textbf{[Integratif] Rancangan kompilator}

Pipeline kompilator modern:
\begin{verbatim}
Source → Lexer → Parser → AST → IR → SSA → Optimization → Code Generation → Assembly
\end{verbatim}

\end{enumerate}
