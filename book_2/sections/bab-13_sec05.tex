\section{Implementasi Runtime Stack Simulator}

Untuk memahami runtime stack dengan lebih baik, kita akan mengimplementasikan simulator sederhana dalam C++.

\subsection{Struktur Data Activation Record}

\begin{lstlisting}[language=C++, caption={Struktur data untuk activation record}]
#include <string>
#include <vector>
#include <unordered_map>
#include <iostream>

// Representasi activation record
struct ActivationRecord {
    std::string function_name;           // Nama fungsi
    void* return_address;                // Return address (simulated)
    ActivationRecord* control_link;      // Pointer ke caller's AR
    ActivationRecord* access_link;       // Pointer ke enclosing scope
    
    // Local variables dan parameters
    std::unordered_map<std::string, int> locals;
    std::unordered_map<std::string, int> parameters;
    
    // Return value
    int return_value;
    
    ActivationRecord(const std::string& name, 
                    ActivationRecord* caller = nullptr)
        : function_name(name), 
          return_address(nullptr),
          control_link(caller),
          access_link(nullptr),
          return_value(0) {}
};
\end{lstlisting}

\subsection{Stack Manager}

\begin{lstlisting}[language=C++, caption={Implementasi runtime stack manager}]
class RuntimeStack {
private:
    ActivationRecord* top;  // Top of stack (current activation)
    int frame_count;
    
public:
    RuntimeStack() : top(nullptr), frame_count(0) {}
    
    // Push activation record baru (function call)
    void pushFrame(const std::string& function_name) {
        ActivationRecord* new_frame = 
            new ActivationRecord(function_name, top);
        new_frame->access_link = top;  // Simplified: same as control link
        top = new_frame;
        frame_count++;
        
        std::cout << ">>> Called: " << function_name 
                  << " (Frame #" << frame_count << ")\n";
        printStack();
    }
    
    // Pop activation record (function return)
    void popFrame() {
        if (top == nullptr) {
            std::cerr << "Error: Cannot pop from empty stack!\n";
            return;
        }
        
        std::string func_name = top->function_name;
        int ret_val = top->return_value;
        
        ActivationRecord* old_top = top;
        top = top->control_link;
        delete old_top;
        frame_count--;
        
        std::cout << "<<< Returned from: " << func_name 
                  << " (return value: " << ret_val << ")\n";
        printStack();
    }
    
    // Get current activation record
    ActivationRecord* getCurrentFrame() {
        return top;
    }
    
    // Set local variable di current frame
    void setLocal(const std::string& name, int value) {
        if (top == nullptr) {
            std::cerr << "Error: No active frame!\n";
            return;
        }
        top->locals[name] = value;
        std::cout << "  Set local: " << name << " = " << value << "\n";
    }
    
    // Get local variable dari current frame atau enclosing scopes
    int getLocal(const std::string& name) {
        ActivationRecord* frame = top;
        while (frame != nullptr) {
            if (frame->locals.find(name) != frame->locals.end()) {
                return frame->locals[name];
            }
            frame = frame->access_link;  // Check enclosing scope
        }
        std::cerr << "Error: Variable '" << name 
                  << "' not found!\n";
        return 0;
    }
    
    // Set parameter
    void setParameter(const std::string& name, int value) {
        if (top == nullptr) {
            std::cerr << "Error: No active frame!\n";
            return;
        }
        top->parameters[name] = value;
        std::cout << "  Set parameter: " << name << " = " << value << "\n";
    }
    
    // Set return value
    void setReturnValue(int value) {
        if (top == nullptr) {
            std::cerr << "Error: No active frame!\n";
            return;
        }
        top->return_value = value;
        std::cout << "  Set return value: " << value << "\n";
    }
    
    // Print stack untuk debugging
    void printStack() {
        std::cout << "Stack (top to bottom):\n";
        ActivationRecord* frame = top;
        int level = 0;
        while (frame != nullptr) {
            std::cout << "  [" << level << "] " 
                      << frame->function_name << "\n";
            frame = frame->control_link;
            level++;
        }
        std::cout << "\n";
    }
    
    ~RuntimeStack() {
        while (top != nullptr) {
            popFrame();
        }
    }
};
\end{lstlisting}

\subsection{Contoh Penggunaan Simulator}

\begin{lstlisting}[language=C++, caption={Contoh penggunaan runtime stack simulator}]
int main() {
    RuntimeStack stack;
    
    // Simulasi: main() calls factorial(5)
    stack.pushFrame("main");
    stack.setLocal("n", 5);
    
    // Call factorial(5)
    stack.pushFrame("factorial");
    stack.setParameter("n", 5);
    
    // Recursive call: factorial(4)
    stack.pushFrame("factorial");
    stack.setParameter("n", 4);
    
    // Recursive call: factorial(3)
    stack.pushFrame("factorial");
    stack.setParameter("n", 3);
    
    // Base case: factorial(1) returns 1
    stack.setReturnValue(1);
    stack.popFrame();
    
    // factorial(3) = 3 * factorial(2) = 3 * 2 = 6
    // (simplified, actual would need more frames)
    stack.setReturnValue(6);
    stack.popFrame();
    
    stack.setReturnValue(24);
    stack.popFrame();
    
    stack.setReturnValue(120);
    stack.popFrame();
    
    // main returns
    stack.popFrame();
    
    return 0;
}
\end{lstlisting}