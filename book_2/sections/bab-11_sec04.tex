\section{Type Checking}

Type checking adalah proses memastikan bahwa program mematuhi aturan tipe bahasa pemrograman. Menurut GeeksforGeeks:

\begin{quote}
``The process of ensuring that a program adheres to the language's type rules. Checking for things like 'you can't add an integer to a string', that function calls match the declared parameter types, etc.''\footnote{\url{https://www.geeksforgeeks.org/type-checking-in-compiler-design/}}
\end{quote}

\subsection{Aturan Type Checking Dasar}

\subsubsection{Type Checking untuk Ekspresi Aritmatika}

Untuk ekspresi aritmatika, aturan dasar meliputi:

\begin{enumerate}
    \item \textbf{Literals}: Setiap literal memiliki tipe intrinsik
    \begin{itemize}
        \item Integer literal (42) → \texttt{int}
        \item Float literal (3.14) → \texttt{float}
        \item String literal ("hello") → \texttt{string}
    \end{itemize}
    
    \item \textbf{Operasi Aritmatika}: Operan harus kompatibel
    \begin{itemize}
        \item \texttt{int + int} → \texttt{int}
        \item \texttt{float + float} → \texttt{float}
        \item \texttt{int + float} → \texttt{float} (dengan implicit conversion)
    \end{itemize}
    
    \item \textbf{Assignment}: Tipe ekspresi harus kompatibel dengan tipe variabel
    \begin{itemize}
        \item \texttt{int x = 42;} $\checkmark$ (valid)
        \item \texttt{int x = 3.14;} $\times$ (type mismatch, atau perlu explicit cast)
    \end{itemize}
\end{enumerate}

\subsubsection{Type Checking untuk Function Calls}

Untuk pemanggilan fungsi, type checker memverifikasi:

\begin{enumerate}
    \item Jumlah argumen sesuai dengan jumlah parameter
    \item Tipe setiap argumen kompatibel dengan tipe parameter yang sesuai
    \item Return type dari fungsi sesuai dengan konteks penggunaan
\end{enumerate}

Contoh:
\begin{lstlisting}[language=C++,basicstyle=\ttfamily\footnotesize,breaklines=true,breakatwhitespace=false]
int add(int a, int b) { return a + b; }

// Valid call
int result = add(5, 10);  // OK

// Invalid calls
add(5);                   // ERROR: Wrong number of arguments
int x = add(5.0, 10.0);   // ERROR: Type mismatch (float vs int)
\end{lstlisting}

\subsection{Implementasi Type Checker Sederhana}

Berikut adalah contoh struktur data untuk type checker dalam C++:

\begin{lstlisting}[language=C++, caption=Struktur Data untuk Type System]
enum class TypeKind {
    INT,
    FLOAT,
    STRING,
    BOOL,
    VOID,
    ARRAY,
    FUNCTION
};

struct Type {
    TypeKind kind;
    // Untuk array: element type
    // Untuk function: parameter types dan return type
    std::vector<Type> subtypes;
};

class TypeChecker {
private:
    SymbolTable* symbolTable;
    
public:
    TypeChecker(SymbolTable* st) : symbolTable(st) {}
    
    // Type check sebuah ekspresi
    Type checkExpression(ASTNode* expr);
    
    // Type check sebuah statement
    void checkStatement(ASTNode* stmt);
    
    // Type check sebuah program
    void checkProgram(ASTNode* program);
    
    // Cek kompatibilitas tipe
    bool isCompatible(Type t1, Type t2);
    
    // Lakukan implicit conversion jika perlu
    Type promoteType(Type t1, Type t2);
};
\end{lstlisting}

\subsubsection{Type Checking untuk Binary Operations}

Berikut adalah contoh implementasi type checking untuk operasi biner:

\begin{lstlisting}[language=C++, caption=Type Checking untuk Binary Operations]
Type TypeChecker::checkBinaryOp(ASTNode* node) {
    ASTBinaryOp* binOp = static_cast<ASTBinaryOp*>(node);
    
    Type leftType = checkExpression(binOp->left);
    Type rightType = checkExpression(binOp->right);
    
    switch (binOp->op) {
        case OP_PLUS:
        case OP_MINUS:
        case OP_MULTIPLY:
        case OP_DIVIDE:
            // Operasi aritmatika: int atau float
            if (leftType.kind == TypeKind::INT && 
                rightType.kind == TypeKind::INT) {
                return Type{TypeKind::INT};
            }
            if (leftType.kind == TypeKind::FLOAT || 
                rightType.kind == TypeKind::FLOAT) {
                return promoteType(leftType, rightType);
            }
            reportError("Arithmetic operation on incompatible types");
            break;
            
        case OP_EQUAL:
        case OP_NOT_EQUAL:
        case OP_LESS:
        case OP_GREATER:
            // Operasi perbandingan: hasilnya boolean
            if (isCompatible(leftType, rightType)) {
                return Type{TypeKind::BOOL};
            }
            reportError("Comparison on incompatible types");
            break;
            
        default:
            reportError("Unknown binary operator");
    }
    
    return Type{TypeKind::VOID}; // Error type
}
\end{lstlisting}