\section{Implementasi Symbol Table yang Lengkap}

\subsection{Arsitektur Kelas SymbolTable}
Berikut adalah implementasi minimalis namun fungsional untuk Symbol Table dengan dukungan \textit{nested scopes} menggunakan C++.

\begin{lstlisting}[language=C++]
#include <unordered_map>
#include <string>
#include <vector>
#include <memory>

struct Symbol {
    std::string name;
    std::string type;
    int offset; // Untuk Code Generation
};

class Scope {
public:
    std::unordered_map<std::string, std::shared_ptr<Symbol>> symbols;
    Scope* parent;

    Scope(Scope* p) : parent(p) {}
    
    void insert(std::string name, std::shared_ptr<Symbol> sym) {
        symbols[name] = sym;
    }
    
    std::shared_ptr<Symbol> lookup(std::string name) {
        if (symbols.count(name)) return symbols[name];
        if (parent) return parent->lookup(name);
        return nullptr;
    }
};

class SymbolTable {
    Scope* currentScope;
public:
    SymbolTable() { currentScope = new Scope(nullptr); } // Global Scope

    void enterScope() {
        currentScope = new Scope(currentScope);
    }
    
    void exitScope() {
        if (currentScope->parent) {
            Scope* temp = currentScope;
            currentScope = currentScope->parent;
            delete temp;
        }
    }
    
    void addSymbol(std::string name, std::string type) {
        auto sym = std::make_shared<Symbol>();
        sym->name = name;
        sym->type = type;
        currentScope->insert(name, sym);
    }
};
\end{lstlisting}

\subsection{Integrasi dalam Parser}
Di dalam parser (misal: Recursive Descent), panggilan ke \texttt{enterScope} dan \texttt{exitScope} disisipkan pada grammar \textit{Block}:
\begin{lstlisting}[language=C++]
void Parser::parseBlock() {
    match('{');
    symbolTable.enterScope();  // Buat scope baru
    parseDeclarations();       // Isi tabel dengan variabel lokal
    parseStatements();         // Gunakan variabel (lookup)
    symbolTable.exitScope();   // Hapus scope saat keluar
    match('}');
}
\end{lstlisting}
