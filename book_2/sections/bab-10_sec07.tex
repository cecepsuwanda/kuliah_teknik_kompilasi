\section{Implementasi Lengkap Symbol Table}

Berikut adalah implementasi lengkap symbol table dengan semua fitur yang telah dibahas:

\begin{lstlisting}[language=C++, caption={Implementasi lengkap SymbolTable}]
#include <string>
#include <unordered_map>
#include <iostream>
#include <vector>

struct Symbol {
    std::string name;
    std::string type;
    int scope_level;
    int line_number;
    void* memory_location;
    
    Symbol() : scope_level(-1), line_number(-1), 
               memory_location(nullptr) {}
};

class Scope {
private:
    std::unordered_map<std::string, Symbol*> table;
    Scope* parent;
    int level;
    std::vector<std::string> declared_names;  // Untuk cleanup
    
public:
    Scope(Scope* p = nullptr, int l = 0) 
        : parent(p), level(l) {}
    
    ~Scope() {
        // Cleanup semua symbols
        for (auto& pair : table) {
            delete pair.second;
        }
    }
    
    bool insert(const std::string& name, Symbol* sym) {
        if (table.find(name) != table.end()) {
            return false;  // Duplicate
        }
        table[name] = sym;
        declared_names.push_back(name);
        return true;
    }
    
    Symbol* lookupLocal(const std::string& name) {
        auto it = table.find(name);
        if (it != table.end()) {
            return it->second;
        }
        return nullptr;
    }
    
    Symbol* lookup(const std::string& name) {
        Symbol* sym = lookupLocal(name);
        if (sym != nullptr) {
            return sym;
        }
        if (parent != nullptr) {
            return parent->lookup(name);
        }
        return nullptr;
    }
    
    Scope* getParent() { return parent; }
    int getLevel() { return level; }
    const std::vector<std::string>& getDeclaredNames() const {
        return declared_names;
    }
};

class SymbolTable {
private:
    Scope* current_scope;
    int next_level;
    
public:
    SymbolTable() {
        current_scope = new Scope(nullptr, 0);
        next_level = 1;
    }
    
    ~SymbolTable() {
        // Cleanup semua scopes
        while (current_scope != nullptr) {
            Scope* parent = current_scope->getParent();
            delete current_scope;
            current_scope = parent;
        }
    }
    
    void beginScope() {
        Scope* new_scope = new Scope(current_scope, next_level++);
        current_scope = new_scope;
    }
    
    void endScope() {
        if (current_scope == nullptr || 
            current_scope->getLevel() == 0) {
            return;  // Tidak bisa keluar dari global scope
        }
        
        Scope* parent = current_scope->getParent();
        delete current_scope;
        current_scope = parent;
        next_level--;
    }
    
    bool insert(const std::string& name, 
                const std::string& type, 
                int line) {
        if (current_scope == nullptr) {
            return false;
        }
        
        // Cek duplikasi
        if (current_scope->lookupLocal(name) != nullptr) {
            std::cerr << "Error: Duplicate declaration of '" 
                      << name << "' at line " << line << std::endl;
            return false;
        }
        
        // Cek shadowing (optional warning)
        Scope* parent = current_scope->getParent();
        while (parent != nullptr) {
            Symbol* shadowed = parent->lookupLocal(name);
            if (shadowed != nullptr) {
                std::cout << "Warning: '" << name 
                          << "' at line " << line
                          << " shadows declaration at line " 
                          << shadowed->line_number << std::endl;
                break;
            }
            parent = parent->getParent();
        }
        
        // Insert symbol
        Symbol* sym = new Symbol();
        sym->name = name;
        sym->type = type;
        sym->scope_level = current_scope->getLevel();
        sym->line_number = line;
        
        return current_scope->insert(name, sym);
    }
    
    Symbol* lookup(const std::string& name) {
        if (current_scope == nullptr) {
            return nullptr;
        }
        return current_scope->lookup(name);
    }
    
    Symbol* lookupCurrentScope(const std::string& name) {
        if (current_scope == nullptr) {
            return nullptr;
        }
        return current_scope->lookupLocal(name);
    }
    
    int getCurrentLevel() {
        return current_scope ? current_scope->getLevel() : -1;
    }
    
    Scope* getCurrentScope() {
        return current_scope;
    }
};
\end{lstlisting}