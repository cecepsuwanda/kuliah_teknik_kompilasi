\section{Implementasi: Hand-written Recursive Descent}

Recursive Descent adalah teknik parsing paling populer untuk implementasi manual karena struktur kodenya sangat mirip dengan grammar EBNF-nya.

\subsection{Pola Implementasi}
Setiap aturan produksi diterjemahkan menjadi satu fungsi.
\begin{itemize}
    \item \textbf{Pilihan ($\mid$)}: Menjadi \texttt{if-else} atau \texttt{switch-case}.
    \item \textbf{Repetisi ($*$ atau $+$)}: Menjadi \texttt{while} atau \texttt{do-while} loop.
    \item \textbf{Sequence}: Menjadi pemanggilan fungsi berurutan.
\end{itemize}

\subsection{Pratt Parsing (Top-Down Operator Precedence)}
Recursive Descent menjadi agak berbelit saat menangani ekspresi matematika dengan banyak level presedensi (misal: 10 level dari $||$ hingga $()$). Kita harus membuat 10 fungsi bersarang (\texttt{parseOr}, \texttt{parseAnd}, ..., \texttt{parsePrimary}).

Sebagai alternatif, teknik \textbf{Pratt Parsing} (digunakan di Python dan Rust) menggunakan tabel lookup untuk presedensi.
\begin{lstlisting}[language=C++]
// Konsep Pratt Parsing
Expression parsePratt(int precedence) {
    Token t = advance();
    Expression left = prefixParselet[t.type].parse(t);
    while (precedence < getPrecedence(peek().type)) {
        t = advance();
        left = infixParselet[t.type].parse(left, t);
    }
    return left;
}
\end{lstlisting}
Teknik ini jauh lebih ringkas untuk ekspresi, namun Recursive Descent tetap lebih unggul untuk statement (\texttt{if}, \texttt{while}, \texttt{class}).
