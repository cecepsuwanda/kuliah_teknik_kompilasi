\section{Bottom-Up Parsing: Shift-Reduce dan LR}

\subsection{Filosofi Bottom-Up}
Jika Top-Down mencoba "menebak" struktur dari atas, Bottom-Up bekerja seperti menyusun puzzle dari kepingan kecil (token) menjadi gambar utuh (start symbol).
\begin{itemize}
    \item \textbf{Shift}: Memindahkan token dari input ke stack parser.
    \item \textbf{Reduce}: Mengenali pola di puncak stack yang cocok dengan RHS aturan grammar, lalu menggantinya dengan LHS.
\end{itemize}

\subsection{Contoh Trace Shift-Reduce}
Grammar: $E \to E + E \mid \textbf{id}$
Input: \textbf{id} + \textbf{id} \$

\begin{table}[!htbp]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Stack} & \textbf{Input} & \textbf{Action} \\
\hline
\$ & id + id \$ & Shift \textbf{id} \\
\$ \textbf{id} & + id \$ & Reduce by $E \to \textbf{id}$ \\
\$ $E$ & + id \$ & Shift \textbf{+} \\
\$ $E$ \textbf{+} & id \$ & Shift \textbf{id} \\
\$ $E$ \textbf{+} \textbf{id} & \$ & Reduce by $E \to \textbf{id}$ \\
\$ $E$ \textbf{+} $E$ & \$ & Reduce by $E \to E + E$ \\
\$ $E$ & \$ & \textbf{Accept} \\
\hline
\end{tabular}
\caption{Langkah-langkah Shift-Reduce Parsing}
\end{table}

\subsection{Keluarga LR Parser}
\begin{enumerate}
    \item \textbf{LR(0)}: Tidak melihat lookahead sama sekali. Hanya bisa menangani grammar sangat sederhana.
    \item \textbf{SLR(1)}: Simple LR. Menggunakan himpunan \textit{Follow} untuk menyelesaikan konflik Shift/Reduce dasar.
    \item \textbf{LALR(1)}: Look-Ahead LR. Standar industri (Bison/Yacc). Menggabungkan state LR(1) yang memiliki inti (\textit{core}) sama untuk menghemat memori.
    \item \textbf{Canonical LR(1)}: Paling powerful, tapi tabel parsing-nya bisa sangat besar (ribuan state).
\end{enumerate}
