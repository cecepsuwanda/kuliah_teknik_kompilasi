\section{Memory Layout}

Program yang dieksekusi memiliki memory layout yang terorganisir menjadi beberapa region. Setiap region memiliki karakteristik dan tujuan penggunaan yang berbeda.

\subsection{Memory Regions}

Memory address space program biasanya dibagi menjadi beberapa region utama:

\begin{enumerate}
    \item \textbf{Code/Text Segment}: Berisi instruksi machine code yang dihasilkan compiler. Region ini biasanya read-only dan tidak dapat dimodifikasi saat runtime.
    
    \item \textbf{Static/Global Data}: Berisi variabel global dan static yang dialokasikan pada compile time. Region ini memiliki ukuran tetap dan alamat yang diketahui saat compile time.
    
    \item \textbf{Stack}: Region untuk activation records (stack frames) dari fungsi-fungsi yang sedang aktif. Stack tumbuh ke bawah (dari high address ke low address) dan dikelola secara otomatis.
    
    \item \textbf{Heap}: Region untuk dynamic memory allocation. Heap tumbuh ke atas (dari low address ke high address) dan dikelola secara manual atau melalui garbage collector.
\end{enumerate}

Gambar \ref{fig:memory-layout-visual} menunjukkan layout memory secara visual dengan TikZ.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.85\textwidth,center}{%
    \begin{tikzpicture}[
        region/.style={rectangle, draw=blue!50, fill=blue!10, text width=4cm, minimum height=0.8cm, font=\footnotesize, align=center, inner sep=4pt},
        arrow/.style={->, >=stealth, thick},
        node distance=0.4cm
    ]
    
    \node[region] (high) {High Address};
    \node[region, below=of high, draw=red!50, fill=red!10] (stack) {Stack\\(grows down)};
    \node[region, below=of stack, draw=green!50, fill=green!10] (heap) {Heap\\(grows up)};
    \node[region, below=of heap] (data) {Static/Global Data};
    \node[region, below=of data] (code) {Code/Text Segment};
    \node[region, below=of code] (low) {Low Address};
    
    \draw[arrow] (stack) to[out=180, in=180] node[left, font=\tiny] {↓} (stack.south west);
    \draw[arrow] (heap) to[out=0, in=0] node[right, font=\tiny] {↑} (heap.south east);
    
    \end{tikzpicture}%
    }
    \caption{Memory layout program}
    \label{fig:memory-layout-visual}
\end{figure}

Gambar \ref{fig:memory-layout} menunjukkan layout memory yang khas:

\begin{figure}[H]
\centering
\begin{verbatim}
High Address
    +-----------------+
    |   Command Line  |
    |     Arguments   |
    +------------------+
    |      Stack      | <- Tumbuh ke bawah
    |   (grows down)  |
    |                 |
    |       ↓         |
    |                 |
    |       ↑         |
    |   (grows up)    |
    |      Heap       | <- Tumbuh ke atas
    +------------------+
    |  BSS (uninit)   |
    |  Data (init)    |
    +------------------+
    |  Text/Code      | <- Read-only
Low Address
\end{verbatim}
\caption{Memory layout khas untuk program yang dieksekusi}
\label{fig:memory-layout}
\end{figure}

\subsection{Static Memory Allocation}

Static memory allocation terjadi pada compile time. Variabel yang dialokasikan secara static memiliki:
\begin{itemize}
    \item Alamat yang tetap dan diketahui saat compile time
    \item Lifetime yang sama dengan program (dari awal hingga akhir eksekusi)
    \item Tidak memerlukan runtime overhead untuk alokasi/dealokasi
\end{itemize}

Contoh variabel static:
\begin{itemize}
    \item Variabel global: \texttt{int global\_var;}
    \item Variabel static lokal: \texttt{static int counter;}
    \item String literals dan konstanta
\end{itemize}

Keuntungan static allocation:
\begin{itemize}
    \item Sangat efisien (tidak ada overhead runtime)
    \item Deterministik (alamat diketahui saat compile time)
    \item Tidak ada risiko memory leak
\end{itemize}

Keterbatasan:
\begin{itemize}
    \item Tidak mendukung recursion dengan baik
    \item Ukuran harus diketahui saat compile time
    \item Tidak fleksibel untuk dynamic data structures
\end{itemize}

\subsection{Stack-Based Memory Allocation}

Stack digunakan untuk activation records dari fungsi-fungsi yang sedang aktif. Stack allocation memiliki karakteristik:
\begin{itemize}
    \item \textbf{Automatic}: Alokasi dan dealokasi terjadi otomatis saat fungsi dipanggil dan kembali
    \item \textbf{LIFO}: Last In First Out - fungsi terakhir dipanggil adalah yang pertama kembali
    \item \textbf{Fast}: Alokasi/dealokasi sangat cepat (hanya mengubah stack pointer)
    \item \textbf{Limited Lifetime}: Data di stack hanya hidup selama fungsi aktif
\end{itemize}

Stack sangat cocok untuk:
\begin{itemize}
    \item Local variables
    \item Function parameters
    \item Return addresses
    \item Temporary values
\end{itemize}

Contoh penggunaan stack:
\begin{lstlisting}[language=C++, caption={Contoh program yang menggunakan stack}]
int factorial(int n) {
    if (n <= 1) return 1;
    int temp = n * factorial(n - 1);  // Recursive call
    return temp;
}

int main() {
    int result = factorial(5);  // Stack frames untuk main dan factorial
    return 0;
}
\end{lstlisting}

\subsection{Heap-Based Memory Allocation}

Heap digunakan untuk dynamic memory allocation yang tidak dapat ditangani oleh stack. Heap allocation memiliki karakteristik:
\begin{itemize}
    \item \textbf{Manual Management}: Programmer harus secara eksplisit mengalokasikan dan membebaskan memory
    \item \textbf{Flexible Lifetime}: Object di heap dapat hidup lebih lama dari fungsi yang membuatnya
    \item \textbf{Variable Size}: Ukuran dapat ditentukan saat runtime
    \item \textbf{Slower}: Alokasi/dealokasi lebih lambat dibanding stack
\end{itemize}

Heap digunakan untuk:
\begin{itemize}
    \item Dynamic arrays dan data structures
    \item Objects yang harus hidup lebih lama dari fungsi pembuatnya
    \item Shared data structures
    \item Large objects yang tidak muat di stack
\end{itemize}

Contoh penggunaan heap:
\begin{lstlisting}[language=C++, caption={Contoh penggunaan heap}]
int* createArray(int size) {
    int* arr = new int[size];  // Alokasi di heap
    return arr;  // Pointer ke heap, valid setelah fungsi kembali
}

void useArray() {
    int* myArray = createArray(100);
    // Gunakan array...
    delete[] myArray;  // Dealokasi manual
}
\end{lstlisting}