\section{Handling Scope Entry dan Exit}

Kompilator harus menangani masuk dan keluar scope dengan benar untuk berbagai konstruk bahasa. Ini dilakukan dengan memanggil \texttt{beginScope()} dan \texttt{endScope()} pada waktu yang tepat.

\subsection{Function Declaration}

Saat menemukan deklarasi fungsi, kita memasuki scope baru:

\begin{lstlisting}[language=C++, caption={Handling function scope}]
// Dalam parser, saat menemukan function declaration:
void parseFunction() {
    // ... parse function signature ...
    
    symbolTable.beginScope();  // Masuk ke function scope
    
    // Parse parameter list (insert ke symbol table)
    for (auto param : parameters) {
        symbolTable.insert(param.name, param.type, param.line);
    }
    
    // Parse function body
    parseBlock();
    
    symbolTable.endScope();  // Keluar dari function scope
}
\end{lstlisting}

\subsection{Block Statement}

Setiap blok \texttt{\{ \}} menciptakan scope baru:

\begin{lstlisting}[language=C++, caption={Handling block scope}]
void parseBlock() {
    match('{');
    
    symbolTable.beginScope();  // Masuk ke block scope
    
    // Parse statements dalam block
    while (currentToken != '}') {
        parseStatement();
    }
    
    match('}');
    symbolTable.endScope();  // Keluar dari block scope
}
\end{lstlisting}

\subsection{Loop Statement}

Beberapa bahasa (seperti C++ dengan for-loop) menciptakan scope untuk variabel loop:

\begin{lstlisting}[language=C++, caption={Handling loop scope}]
void parseForLoop() {
    match("for");
    match('(');
    
    symbolTable.beginScope();  // Masuk ke loop scope
    
    // Parse loop variable declaration (jika ada)
    if (isDeclaration()) {
        parseDeclaration();
    }
    
    // Parse loop condition dan increment
    parseExpression();  // condition
    parseExpression();  // increment
    
    match(')');
    
    // Parse loop body
    parseStatement();
    
    symbolTable.endScope();  // Keluar dari loop scope
}
\end{lstlisting}