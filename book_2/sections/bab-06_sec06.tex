\section{Error Recovery pada Recursive Descent}

\subsection{Pentingnya Error Recovery}

Error recovery adalah kemampuan parser untuk melanjutkan parsing setelah menemukan error, sehingga dapat melaporkan multiple errors dalam satu pass. Tanpa error recovery, parser akan berhenti pada error pertama.

\subsection{Strategi Error Recovery}

Beberapa strategi error recovery yang umum digunakan:

\subsubsection{Synchronization Points}

Menentukan synchronization points (token-token yang dapat digunakan untuk recovery), seperti:
\begin{itemize}
    \item Statement terminators (\texttt{;}, \texttt{\}})
    \item Keywords yang menandai awal konstruksi baru (\texttt{if}, \texttt{while}, \texttt{return})
    \item Operator yang jelas (\texttt{+}, \texttt{-}, \texttt{*})
\end{itemize}

\subsubsection{Panic Mode Recovery}

Ketika error ditemukan, parser membuang token sampai menemukan synchronization point:

\begin{lstlisting}[language=C++, caption={Panic mode error recovery}]
void parseE() {
    parseT();
    parseEPrime();
}

void parseEPrime() {
    if (lookahead.type == TOK_PLUS) {
        match(TOK_PLUS);
        parseT();
        parseEPrime();
    } else if (!isValidFollow(lookahead.type)) {
        // Error recovery: skip until synchronization point
        error("Expected '+' or end of expression");
        while (!isSynchronizationPoint(lookahead.type) && 
               lookahead.type != TOK_END) {
            nextToken();
        }
    }
    // else: valid follow token, epsilon production
}

bool isSynchronizationPoint(TokenType t) {
    return t == TOK_RPAREN || t == TOK_END || 
           t == TOK_SEMICOLON;
}

bool isValidFollow(TokenType t) {
    return t == TOK_RPAREN || t == TOK_END || 
           t == TOK_SEMICOLON || t == TOK_PLUS;
}
\end{lstlisting}

\subsubsection{Error Production}

Menambahkan production khusus untuk menangani error:

\begin{verbatim}
E' -> + T E' | epsilon | error E'
\end{verbatim}

Ketika error ditemukan, parser dapat menggunakan error production untuk recovery.

\subsection{Implementasi Error Recovery yang Lebih Baik}

Berikut adalah implementasi yang lebih robust dengan error recovery:

\begin{lstlisting}[language=C++, caption={Error recovery yang lebih baik}]
class ParserWithRecovery {
private:
    int errorCount;
    std::vector<Token> tokens;
    size_t current;
    Token lookahead;
    
    void nextToken() {
        if (current < tokens.size()) {
            lookahead = tokens[current++];
        } else {
            lookahead = {TOK_END, "", 0, 0};
        }
    }
    
    void error(const std::string& msg) {
        errorCount++;
        std::cerr << "Error at line " << lookahead.line 
                  << ", col " << lookahead.col << ": " 
                  << msg << std::endl;
    }
    
    void synchronize() {
        // Skip tokens until synchronization point
        while (lookahead.type != TOK_END) {
            if (isSynchronizationPoint(lookahead.type)) {
                return;
            }
            nextToken();
        }
    }
    
    bool isSynchronizationPoint(TokenType t) {
        return t == TOK_RPAREN || t == TOK_SEMICOLON || 
               t == TOK_END || t == TOK_PLUS || t == TOK_MUL;
    }
    
public:
    ParserWithRecovery(const std::vector<Token>& t) 
        : tokens(t), current(0), errorCount(0) {
        nextToken();
    }
    
    void parseE() {
        try {
            parseT();
            parseEPrime();
        } catch (...) {
            error("Error in expression");
            synchronize();
        }
    }
    
    void parseEPrime() {
        if (lookahead.type == TOK_PLUS) {
            match(TOK_PLUS);
            parseT();
            parseEPrime();
        } else if (!isValidFollow(lookahead.type)) {
            error("Expected '+' or end of expression");
            synchronize();
        }
    }
    
    int getErrorCount() const { return errorCount; }
};
\end{lstlisting}