\section{Jawaban}

\subsection{Jawaban Latihan Bab 1: Pengenalan Kompilator dan Fase-Fase Kompilasi}

\begin{enumerate}
    \item \textbf{Perbedaan antara kompilator dan interpreter:}
    
    \textbf{Kompilator:}
    \begin{itemize}
        \item Menerjemahkan seluruh program sekaligus sebelum dieksekusi
        \item Hasil translasi disimpan dalam file terpisah (executable) yang kemudian dapat dieksekusi langsung oleh sistem operasi atau mesin virtual
        \item Sekali compile, berkali-kali run
        \item Contoh bahasa: C, C++, Rust, Go
    \end{itemize}
    
    \textbf{Interpreter:}
    \begin{itemize}
        \item Menerjemahkan dan mengeksekusi program baris demi baris secara langsung tanpa menghasilkan file terpisah untuk eksekusi
        \item Interpret setiap kali run
        \item Contoh bahasa: Python, JavaScript, Ruby
    \end{itemize}
    
    \textbf{Hybrid Approach:} Beberapa bahasa modern menggunakan pendekatan hybrid, seperti Java yang dikompilasi menjadi bytecode, kemudian diinterpretasi oleh JVM (Java Virtual Machine), atau menggunakan JIT (Just-In-Time compilation). Contoh: Java, C\#, Python (dengan bytecode).
    
    \item \textbf{Diagram alur kerja kompilator dari source code C sampai menjadi executable:}
    
    Alur kerja kompilator meliputi fase-fase berikut:
    \begin{enumerate}
        \item \textbf{Preprocessing}: Memproses directive khusus seperti \texttt{\#include}, \texttt{\#define}
        \item \textbf{Lexical Analysis}: Memecah source code menjadi token-token (identifiers, keywords, operators, literals)
        \item \textbf{Syntax Analysis}: Menganalisis struktur grammar dan membangun parse tree atau Abstract Syntax Tree (AST)
        \item \textbf{Semantic Analysis}: Memeriksa aturan semantik bahasa, type checking, scope resolution
        \item \textbf{Intermediate Code Generation}: Mengubah AST menjadi intermediate representation (misalnya three-address code)
        \item \textbf{Code Optimization}: Mengoptimasi kode intermediate untuk meningkatkan efisiensi
        \item \textbf{Code Generation}: Menghasilkan target code (assembly atau machine code)
        \item \textbf{Assembling}: Mengubah assembly code menjadi object code (file .o atau .obj)
        \item \textbf{Linking}: Menyatukan object files dan library files menjadi satu executable file
    \end{enumerate}
    
    \item \textbf{Identifikasi fase kompilasi:}
    \begin{itemize}
        \item \textbf{Menghapus whitespace dan comments}: \textbf{Lexical Analysis} - Fase ini membaca source code karakter demi karakter, mengelompokkan karakter menjadi token-token bermakna, dan mengeliminasi whitespace, comments, serta karakter yang tidak relevan.
        
        \item \textbf{Memeriksa apakah variabel dideklarasi sebelum digunakan}: \textbf{Semantic Analysis} - Fase ini melakukan scope resolution dan name resolution untuk memastikan setiap identifier merujuk ke deklarasi yang valid.
        
        \item \textbf{Mengoptimasi kode dengan menghilangkan kode yang tidak pernah dieksekusi}: \textbf{Code Optimization} - Fase ini melakukan dead code elimination untuk menghapus kode yang tidak memiliki efek pada perilaku program yang dapat diamati.
        
        \item \textbf{Mengkonversi ekspresi \texttt{a + b * c} menjadi three-address code}: \textbf{Intermediate Code Generation} - Fase ini mengubah AST menjadi intermediate representation seperti three-address code. Contoh hasilnya:
        \begin{verbatim}
        t1 = b * c
        t2 = a + t1
        \end{verbatim}
    \end{itemize}
    
    \item \textbf{Alasan kompilator modern menggunakan pendekatan multi-pass:}
    
    \textbf{Keuntungan multi-pass:}
    \begin{itemize}
        \item \textbf{Pemisahan tanggung jawab}: Setiap pass memiliki tugas spesifik, membuat implementasi lebih modular dan mudah di-maintain
        \item \textbf{Optimasi yang lebih baik}: Informasi yang dikumpulkan dalam pass pertama dapat digunakan untuk optimasi di pass berikutnya
        \item \textbf{Portabilitas}: Front-end menghasilkan IR, back-end mengkonsumsi IR. Perubahan pada satu sisi tidak mempengaruhi sisi lain
        \item \textbf{Retargeting}: Untuk menambahkan dukungan target baru, cukup menambahkan code generator untuk IR tersebut tanpa mengubah front-end
        \item \textbf{Analisis yang lebih mendalam}: Multi-pass memungkinkan analisis lintas fase yang lebih komprehensif
    \end{itemize}
    
    \textbf{Keuntungan dibanding single-pass:}
    \begin{itemize}
        \item Single-pass memiliki keterbatasan dalam melakukan analisis yang memerlukan informasi dari seluruh program
        \item Multi-pass memungkinkan optimasi yang lebih agresif dan akurat
        \item Multi-pass memudahkan debugging karena setiap fase dapat diuji secara terpisah
    \end{itemize}
    
    \item \textbf{Contoh kompilator open source: GCC (GNU Compiler Collection)}
    \begin{itemize}
        \item \textbf{Bahasa sumber dan target yang didukung}: 
        \begin{itemize}
            \item Bahasa sumber: C, C++, Fortran, Ada, Go, dan lainnya
            \item Target: x86, ARM, RISC-V, MIPS, dan banyak arsitektur lainnya
        \end{itemize}
        
        \item \textbf{Tools untuk lexical dan syntax analysis}:
        \begin{itemize}
            \item GCC menggunakan hand-written recursive descent parser untuk C dan C++ (bukan generator tools)
            \item Alasan: Better error messages, easier maintenance, better handling of complex grammar
        \end{itemize}
        
        \item \textbf{Format intermediate representation}:
        \begin{itemize}
            \item GCC menggunakan GIMPLE (Generic Intermediate Representation) sebagai IR utama
            \item Juga menggunakan RTL (Register Transfer Language) untuk optimasi tingkat rendah
            \item GIMPLE adalah three-address code yang lebih high-level
        \end{itemize}
    \end{itemize}
\end{enumerate}

\subsection{Jawaban Latihan Bab 2: Regular Expression dan Finite Automata}

\begin{enumerate}
    \item \textbf{Regular expression untuk:}
    \begin{itemize}
        \item \textbf{Email address sederhana} (\texttt{user@domain.com}):
        \begin{verbatim}
        [a-zA-Z0-9_]+@[a-zA-Z0-9]+\.[a-zA-Z]{2,}
        \end{verbatim}
        Penjelasan: \texttt{[a-zA-Z0-9\_]+} untuk user, \texttt{@} literal, \texttt{[a-zA-Z0-9]+} untuk domain, \texttt{\textbackslash.} untuk titik literal, \texttt{[a-zA-Z]\{2,\}} untuk ekstensi domain (minimal 2 karakter).
        
        \item \textbf{Phone number} (\texttt{+62-812-3456-7890}):
        \begin{verbatim}
        \+62-[0-9]{3,4}-[0-9]{4}-[0-9]{4}
        \end{verbatim}
        Penjelasan: \texttt{\textbackslash+} untuk tanda plus literal, \texttt{62} untuk kode negara, \texttt{-} untuk separator, \texttt{[0-9]\{3,4\}} untuk operator (3-4 digit), \texttt{[0-9]\{4\}} untuk nomor (4 digit).
        
        \item \textbf{C-style comment} (\texttt{/* ... */}):
        \begin{verbatim}
        /\*([^*]|\*+[^*/])*\*+/
        \end{verbatim}
        Penjelasan: \texttt{/\textbackslash*} untuk awal comment, pola untuk konten berupa karakter selain asterisk atau sekuens asterisk yang tidak diikuti slash, \texttt{*+/} untuk akhir comment.
    \end{itemize}
    
    \item \textbf{Konstruksi NFA menggunakan algoritma Thompson:}
    
    Algoritma Thompson menggunakan template untuk setiap operasi regex:
    \begin{itemize}
        \item \textbf{Literal}: State awal dengan transisi ke state akhir menggunakan karakter tersebut
        \item \textbf{Concatenation (RS)}: Menghubungkan NFA untuk R dan S menggunakan $\epsilon$-transition
        \item \textbf{Union (R|S)}: Menggunakan $\epsilon$-transitions untuk branching dari state awal ke NFA R dan S, kemudian menggabungkan ke state akhir
        \item \textbf{Kleene Star (R*)}: Membuat loop dengan $\epsilon$-transitions yang memungkinkan nol atau lebih pengulangan R
    \end{itemize}
    
    Untuk \texttt{a*b+}:
    \begin{itemize}
        \item Buat NFA untuk \texttt{a*} dengan loop menggunakan $\epsilon$-transitions
        \item Concatenate dengan NFA untuk \texttt{b+} (satu atau lebih b)
    \end{itemize}
    
    Untuk \texttt{(a|b)*ab}:
    \begin{itemize}
        \item Buat NFA untuk \texttt{(a|b)*} dengan union dan Kleene star
        \item Concatenate dengan NFA untuk literal \texttt{a} dan \texttt{b}
    \end{itemize}
    
    Untuk \texttt{[0-9]+(\textbackslash.[0-9]+)?}:
    \begin{itemize}
        \item Buat NFA untuk \texttt{[0-9]+} (satu atau lebih digit)
        \item Buat optional group \texttt{(\textbackslash.[0-9]+)?} dengan $\epsilon$-transition untuk kasus opsional
    \end{itemize}
    
    \item \textbf{Konversi NFA ke DFA menggunakan subset construction:}
    
    Algoritma subset construction:
    \begin{enumerate}
        \item Mulai dengan $\epsilon$-closure dari start state NFA sebagai state awal DFA
        \item Untuk setiap state DFA dan setiap input symbol:
        \begin{itemize}
            \item Hitung $\epsilon$-closure dari semua state yang dapat dicapai dengan symbol tersebut
            \item Jika hasilnya non-empty dan belum ada, tambahkan sebagai state baru DFA
        \end{itemize}
        \item State DFA adalah accept state jika mengandung accept state dari NFA
        \item Ulangi sampai tidak ada state baru
    \end{enumerate}
    
    State diagram DFA akan menunjukkan transisi deterministik (setiap state memiliki tepat satu transisi untuk setiap input symbol).
    
    \item \textbf{Implementasi kelas NFA dan DFA dalam C++:}
    
    Struktur dasar:
    \begin{itemize}
        \item \textbf{Kelas NFA}: Menyimpan states, transitions (termasuk $\epsilon$-transitions), start state, dan accept states
        \item \textbf{Kelas DFA}: Menyimpan states, transition table (deterministik), start state, dan accept states
        \item \textbf{Fungsi konstruksi NFA dari regex}: Menggunakan algoritma Thompson secara rekursif
        \item \textbf{Fungsi konversi NFA ke DFA}: Mengimplementasikan subset construction algorithm
        \item \textbf{Fungsi simulasi DFA}: Mengikuti transisi berdasarkan input symbol, menerima jika berakhir di accept state
    \end{itemize}
    
    \item \textbf{Program recognizer untuk token-token:}
    
    Implementasi menggunakan DFA atau state machine:
    \begin{itemize}
        \item \textbf{Identifier}: State machine yang mulai dengan huruf/underscore, kemudian menerima huruf/digit/underscore
        \item \textbf{Integer}: State machine yang menerima satu atau lebih digit
        \item \textbf{Float}: State machine yang menerima digit, titik desimal, kemudian digit
        \item \textbf{Operator}: State machine yang mengenali operator single-character atau multi-character (==, !=)
    \end{itemize}
    
    \item \textbf{Mengapa DFA lebih efisien untuk simulasi dibanding NFA:}
    
    \textbf{DFA:}
    \begin{itemize}
        \item Kompleksitas waktu: O(n) dimana n adalah panjang input string
        \item Setiap state memiliki tepat satu transisi untuk setiap input symbol
        \item Tidak memerlukan backtracking atau multiple states tracking
        \item Implementasi sederhana: hanya perlu mengikuti transisi berdasarkan input symbol saat ini
    \end{itemize}
    
    \textbf{NFA:}
    \begin{itemize}
        \item Kompleksitas waktu: O(n * m) atau lebih buruk, dimana n adalah panjang input dan m adalah jumlah states
        \item Memerlukan backtracking atau simulasi multiple states secara bersamaan
        \item Perlu menangani $\epsilon$-transitions yang tidak mengonsumsi input
        \item Implementasi lebih kompleks: perlu mempertahankan set of states yang mungkin
    \end{itemize}
    
    \textbf{Kesimpulan}: DFA lebih efisien untuk simulasi karena deterministik dan tidak memerlukan backtracking, meskipun konstruksi DFA dari regex lebih kompleks.
    
    \item \textbf{Implementasi algoritma minimisasi DFA:}
    
    Algoritma minimisasi DFA (menggunakan partition refinement):
    \begin{enumerate}
        \item Partisi awal: Pisahkan accept states dan non-accept states
        \item Untuk setiap partisi:
        \begin{itemize}
            \item Cek apakah states dalam partisi memiliki transisi ke partisi yang berbeda untuk setiap input symbol
            \item Jika ya, pisahkan menjadi partisi baru
        \end{itemize}
        \item Ulangi sampai tidak ada partisi yang dapat dipecah lagi
        \item Gabungkan states dalam partisi yang sama menjadi satu state
    \end{enumerate}
    
    Hasilnya adalah DFA minimal yang ekuivalen dengan DFA asli tetapi dengan jumlah states yang lebih sedikit.
\end{enumerate}

\subsection{Jawaban Latihan Bab 3: Implementasi Lexer}

\begin{enumerate}
    \item \textbf{Implementasi lexer dasar:}
    
    Struktur dasar lexer:
    \begin{itemize}
        \item \textbf{Token Types}: Enum untuk berbagai jenis token (IDENTIFIER, INTEGER\_LITERAL, OPERATOR, PUNCTUATION)
        \item \textbf{Token Structure}: Struktur data yang menyimpan type, lexeme, line, dan column
        \item \textbf{State Machine}: Menggunakan finite state machine untuk mengenali token
        \item \textbf{Methods}: \texttt{nextToken()}, \texttt{scanIdentifier()}, \texttt{scanNumber()}, \texttt{scanOperator()}, dll.
    \end{itemize}
    
    \item \textbf{Handling comments:}
    
    \textbf{Single-line comments (\texttt{//}):}
    \begin{itemize}
        \item Ketika menemukan \texttt{//}, masuk ke state IN\_COMMENT\_LINE
        \item Baca karakter sampai menemukan newline atau EOF
        \item Skip semua karakter dalam comment (tidak menghasilkan token)
    \end{itemize}
    
    \textbf{Multi-line comments (\texttt{/* */}):}
    \begin{itemize}
        \item Ketika menemukan \texttt{/*}, masuk ke state IN\_COMMENT\_BLOCK
        \item Baca karakter sampai menemukan \texttt{*/}
        \item Error handling: Jika mencapai EOF sebelum menemukan \texttt{*/}, report error "unclosed block comment"
    \end{itemize}
    
    \item \textbf{String literals dengan escape sequences:}
    
    Implementasi:
    \begin{itemize}
        \item Ketika menemukan \texttt{"}, masuk ke state IN\_STRING
        \item Baca karakter sampai menemukan closing \texttt{"}
        \item Handle escape sequences:
        \begin{itemize}
            \item \texttt{\textbackslash n}: Newline
            \item \texttt{\textbackslash t}: Tab
            \item \texttt{\textbackslash "}: Quote literal
            \item \texttt{\textbackslash\textbackslash}: Backslash literal
        \end{itemize}
        \item Error handling: Jika mencapai EOF atau newline sebelum closing quote, report error "unclosed string"
    \end{itemize}
    
    \item \textbf{Float literals:}
    
    Extend number scanning:
    \begin{itemize}
        \item Setelah membaca digit, cek apakah karakter berikutnya adalah titik desimal
        \item Jika ya, masuk ke state IN\_FLOAT
        \item Baca digit setelah titik desimal
        \item Untuk scientific notation (\texttt{1.5e10}, \texttt{2.3E-5}):
        \begin{itemize}
            \item Setelah membaca float, cek apakah ada \texttt{e} atau \texttt{E}
            \item Baca optional \texttt{+} atau \texttt{-}
            \item Baca eksponen (digit)
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Unit testing:}
    
    Test cases yang harus dicakup:
    \begin{itemize}
        \item \textbf{Valid tokens}: Semua kategori token (identifiers, numbers, operators, punctuation)
        \item \textbf{Edge cases}:
        \begin{itemize}
            \item Unclosed strings
            \item Unclosed block comments
            \item Invalid characters
            \item Empty input
            \item Whitespace-only input
        \end{itemize}
        \item \textbf{Position tracking}: Verifikasi bahwa line dan column dihitung dengan benar untuk error reporting
    \end{itemize}
    
    \item \textbf{Error recovery:}
    
    Strategi error recovery:
    \begin{itemize}
        \item \textbf{Skip invalid characters}: Ketika menemukan karakter yang tidak valid, skip karakter tersebut dan lanjutkan scanning
        \item \textbf{Report multiple errors}: Kumpulkan semua error dalam satu pass, jangan berhenti pada error pertama
        \item \textbf{Error messages yang informatif}: Sertakan line dan column number untuk setiap error
    \end{itemize}
    
    \item \textbf{Performance analysis:}
    
    Optimasi yang dapat dilakukan:
    \begin{itemize}
        \item \textbf{Lookahead buffer}: Gunakan buffer untuk mengurangi jumlah system calls
        \item \textbf{String interning}: Simpan lexeme sebagai interned strings untuk mengurangi memory usage
        \item \textbf{Table-driven approach}: Gunakan lookup table untuk karakter classification
        \item \textbf{Comparison dengan generator}: Benchmark dengan Flex-generated lexer untuk melihat perbedaan performa
    \end{itemize}
\end{enumerate}

\subsection{Jawaban Latihan Bab 4: Lexer Generator}

\begin{enumerate}
    \item \textbf{Flex specification file:}
    
    Contoh specification untuk token-token yang diminta:
    \begin{verbatim}
    %{
    #include "parser.tab.h"
    %}
    
    %%
    "for"       { return FOR; }
    "break"     { return BREAK; }
    "continue"  { return CONTINUE; }
    
    \"([^"\\]|\\.)*\"  { 
        // String literal dengan escape sequences
        yylval.string = processString(yytext);
        return STRING_LITERAL;
    }
    
    '([^'\\]|\\.)'  {
        // Character literal
        yylval.char = processChar(yytext);
        return CHAR_LITERAL;
    }
    
    "++"        { return PLUS_PLUS; }
    "--"        { return MINUS_MINUS; }
    "+="        { return PLUS_EQ; }
    "-="        { return MINUS_EQ; }
    %%
    \end{verbatim}
    
    \item \textbf{Implementasi dengan re2c:}
    
    Perbandingan kompleksitas:
    \begin{itemize}
        \item \textbf{Flex}: Specification lebih declarative, menggunakan regular expressions
        \item \textbf{re2c}: Specification lebih embedded dalam kode C/C++, menggunakan state machine yang lebih eksplisit
        \item \textbf{Kompleksitas}: re2c biasanya menghasilkan kode yang lebih efisien tetapi specification lebih verbose
    \end{itemize}
    
    \item \textbf{Kapan menggunakan hand-written vs generator:}
    
    \textbf{Hand-written lexer cocok untuk:}
    \begin{itemize}
        \item Error messages yang sangat informatif dan customizable
        \item Kasus edge yang kompleks yang sulit diekspresikan dalam regex
        \item Kontrol penuh atas implementasi
        \item Project kecil yang tidak memerlukan generator overhead
    \end{itemize}
    
    \textbf{Generator cocok untuk:}
    \begin{itemize}
        \item Development yang cepat
        \item Grammar yang well-defined dan standard
        \item Project yang memerlukan proven algorithms
        \item Ketika ingin fokus pada logic bukan implementasi detail
    \end{itemize}
    
    \item \textbf{Integrasi Flex dengan Bison:}
    
    Langkah-langkah:
    \begin{enumerate}
        \item Buat Flex specification file (\texttt{lexer.l}) yang meng-include header dari Bison
        \item Buat Bison specification file (\texttt{parser.y}) yang mendefinisikan tokens
        \item Compile: \texttt{flex lexer.l}, \texttt{bison -d parser.y}
        \item Link: \texttt{gcc lex.yy.c parser.tab.c -o program}
    \end{enumerate}
    
    Interface antara Flex dan Bison:
    \begin{itemize}
        \item Bison menghasilkan \texttt{parser.tab.h} dengan definisi token
        \item Flex menggunakan token definitions dari header tersebut
        \item Flex mengisi \texttt{yylval} dengan semantic value sebelum return token
        \item Parser memanggil \texttt{yylex()} untuk mendapatkan token berikutnya
    \end{itemize}
    
    \item \textbf{Performance benchmark:}
    
    Metodologi:
    \begin{itemize}
        \item Siapkan input file besar (10MB)
        \item Ukur waktu eksekusi untuk setiap implementasi
        \item Ukur memory usage
        \item Bandingkan hasil
    
    Hasil yang diharapkan:
    \begin{itemize}
        \item Flex-generated lexer biasanya lebih cepat karena menggunakan optimized DFA
        \item re2c-generated lexer juga sangat efisien
        \item Hand-written lexer mungkin lebih lambat tetapi lebih fleksibel
    \end{itemize}
    \end{itemize}
    
    \item \textbf{Longest match dan rule priority dalam Flex:}
    
    \textbf{Longest match}:
    \begin{itemize}
        \item Flex selalu mencocokkan pattern terpanjang yang mungkin
        \item Contoh: Input \texttt{"if"} akan cocok dengan keyword \texttt{"if"} bukan identifier \texttt{"i"} diikuti \texttt{"f"}
    \end{itemize}
    
    \textbf{Rule priority}:
    \begin{itemize}
        \item Jika beberapa pattern cocok dengan panjang yang sama, Flex menggunakan rule yang muncul pertama dalam specification
        \item Contoh: Jika keyword \texttt{"if"} didefinisikan sebelum identifier pattern, maka \texttt{"if"} akan dikenali sebagai keyword
        \item Urutan rule penting: keyword harus didefinisikan sebelum identifier pattern
    \end{itemize}
\end{enumerate}

\subsection{Jawaban Latihan Bab 5: Context-Free Grammar dan Parsing}

\begin{enumerate}
    \item \textbf{Grammar dalam BNF:}
    
    \textbf{Ekspresi boolean:}
    \begin{verbatim}
    <boolean_expr> ::= <boolean_expr> AND <boolean_term>
                     | <boolean_expr> OR <boolean_term>
                     | <boolean_term>
    
    <boolean_term> ::= NOT <boolean_term>
                    | <boolean_factor>
    
    <boolean_factor> ::= TRUE | FALSE | ( <boolean_expr> )
    \end{verbatim}
    
    \textbf{Assignment statement:}
    \begin{verbatim}
    <assignment> ::= <identifier> = <expression> ;
    \end{verbatim}
    
    \textbf{For loop:}
    \begin{verbatim}
    <for_loop> ::= for ( <init> ; <condition> ;
              <update> ) <statement>
    
    <init> ::= <declaration> | <expression> | epsilon
    <condition> ::= <expression>
    <update> ::= <expression>
    \end{verbatim}
    
    \item \textbf{Konversi ke EBNF:}
    
    Grammar asli:
    \begin{verbatim}
    <list> ::= <item> | <list> , <item>
    <item> ::= <number> | <string>
    \end{verbatim}
    
    Dalam EBNF:
    \begin{verbatim}
    list = item { "," item }
    item = number | string
    \end{verbatim}
    
    Penjelasan: EBNF menggunakan \texttt{\{ \}} untuk repetition (nol atau lebih), sehingga \texttt{<list> , <item>} menjadi \texttt{\{ "," item \}}.
    
    \item \textbf{Leftmost dan rightmost derivation untuk \texttt{(2 + 3) * 4}:}
    
    Grammar:
    \begin{verbatim}
    E → E + T | E - T | T
    T → T * F | T / F | F
    F → ( E ) | number
    \end{verbatim}
    
    \textbf{Leftmost derivation:}
    \begin{align*}
    E &\Rightarrow T \\
      &\Rightarrow T * F \\
      &\Rightarrow F * F \\
      &\Rightarrow ( E ) * F \\
      &\Rightarrow ( E + T ) * F \\
      &\Rightarrow ( T + T ) * F \\
      &\Rightarrow ( F + T ) * F \\
      &\Rightarrow ( 2 + T ) * F \\
      &\Rightarrow ( 2 + F ) * F \\
      &\Rightarrow ( 2 + 3 ) * F \\
      &\Rightarrow ( 2 + 3 ) * 4
    \end{align*}
    
    \textbf{Rightmost derivation:}
    \begin{align*}
    E &\Rightarrow T \\
      &\Rightarrow T * F \\
      &\Rightarrow T * 4 \\
      &\Rightarrow F * 4 \\
      &\Rightarrow ( E ) * 4 \\
      &\Rightarrow ( E + T ) * 4 \\
      &\Rightarrow ( E + F ) * 4 \\
      &\Rightarrow ( E + 3 ) * 4 \\
      &\Rightarrow ( T + 3 ) * 4 \\
      &\Rightarrow ( F + 3 ) * 4 \\
      &\Rightarrow ( 2 + 3 ) * 4
    \end{align*}
    
    \item \textbf{Parse tree untuk ekspresi:}
    
    Parse tree menunjukkan struktur hierarkis ekspresi berdasarkan grammar. Untuk \texttt{1 + 2 * 3}, parse tree menunjukkan bahwa \texttt{*} memiliki precedence lebih tinggi daripada \texttt{+}, sehingga \texttt{2 * 3} dievaluasi terlebih dahulu.
    
    \item \textbf{Identifikasi ambiguity:}
    
    Grammar:
    \begin{verbatim}
    S → a S a | b S b | a | b | epsilon
    \end{verbatim}
    
    Grammar ini menghasilkan bahasa palindrome dengan panjang ganjil. Contoh string yang dapat di-parse dengan lebih dari satu cara: \texttt{aba} dapat dihasilkan dengan:
    \begin{itemize}
        \item \texttt{S → a S a → a b a} (menggunakan \texttt{S → b})
        \item Atau dengan cara lain tergantung pada urutan aplikasi rules
    \end{itemize}
    
    \item \textbf{Eliminasi left recursion:}
    
    Grammar asli:
    \begin{verbatim}
    A → A + B | A - B | B
    B → B * C | B / C | C
    C → ( A ) | number
    \end{verbatim}
    
    Setelah eliminasi left recursion:
    \begin{verbatim}
    A → B A'
    A' → + B A' | - B A' | epsilon
    
    B → C B'
    B' → * C B' | / C B' | epsilon
    
    C → ( A ) | number
    \end{verbatim}
    
    \item \textbf{Left factoring:}
    
    Grammar asli:
    \begin{verbatim}
    S → if E then S else S
      | if E then S
      | while E do S
      | id = E
    \end{verbatim}
    
    Setelah left factoring:
    \begin{verbatim}
    S → if E then S S'
      | while E do S
      | id = E
    
    S' → else S | epsilon
    \end{verbatim}
    
    \item \textbf{Grammar untuk bahasa sederhana:}
    
    Dalam EBNF:
    \begin{verbatim}
    program = { declaration | statement }
    
    declaration = type identifier ";"
    
    statement = assignment
              | if_statement
              | while_statement
              | block
    
    assignment = identifier "=" expression ";"
    
    if_statement = "if" "(" expression ")" statement
                  [ "else" statement ]
    
    while_statement = "while" "(" expression ")" statement
    
    block = "{" { statement } "}"
    
    expression = term { ("+" | "-") term }
    term = factor { ("*" | "/") factor }
    factor = identifier | number | "(" expression ")"
    
    type = "int" | "float"
    identifier = letter { letter | digit }
    number = digit { digit }
    \end{verbatim}
    
    Contoh program valid:
    \begin{verbatim}
    int x;
    x = 5;
    if (x > 0) {
        int y;
        y = 10;
        while (y > 0) {
            y = y - 1;
        }
    }
    \end{verbatim}
\end{enumerate}

\subsection{Jawaban Latihan Bab 6: Top-Down Parsing dan Recursive Descent}

\begin{enumerate}
    \item \textbf{Implementasi recursive descent parser:}
    
    \textbf{Langkah 1: Eliminasi left recursion}
    
    Grammar asli memiliki left recursion pada E dan T. Setelah eliminasi:
    \begin{verbatim}
    S → if E then S else S | id := E | while E do S
    E → T E'
    E' → + T E' | epsilon
    T → F T'
    T' → * F T' | epsilon
    F → ( E ) | id | num
    \end{verbatim}
    
    \textbf{Langkah 2: Implementasi dalam C++}
    
    Setiap nonterminal menjadi fungsi yang sesuai:
    \begin{itemize}
        \item \texttt{parseS()} untuk S
        \item \texttt{parseE()}, \texttt{parseEPrime()} untuk E dan E'
        \item \texttt{parseT()}, \texttt{parseTPrime()} untuk T dan T'
        \item \texttt{parseF()} untuk F
    \end{itemize}
    
    \item \textbf{Modifikasi untuk operator unary minus:}
    
    Tambahkan production untuk unary minus di level factor:
    \begin{verbatim}
    F → ( E ) | id | num | - F
    \end{verbatim}
    
    Implementasi dalam \texttt{parseF()}:
    \begin{itemize}
        \item Cek apakah token berikutnya adalah \texttt{-}
        \item Jika ya, consume token dan parse F secara rekursif
        \item Return negated value
    \end{itemize}
    
    \item \textbf{Error recovery:}
    
    Strategi:
    \begin{itemize}
        \item \textbf{Synchronization points}: Token-token yang dapat digunakan untuk recovery (misalnya \texttt{;}, \texttt{\}}, keywords)
        \item \textbf{Panic mode}: Skip token sampai menemukan synchronization point
        \item \textbf{Error reporting}: Kumpulkan semua error, jangan berhenti pada error pertama
        \item \textbf{Insertion/deletion recovery}: Coba insert token yang diharapkan atau skip token yang tidak diharapkan
    \end{itemize}
    
    \item \textbf{Parser untuk ekspresi boolean:}
    
    Grammar dengan precedence:
    \begin{verbatim}
    E → T E'        (OR level, lowest precedence)
    E' → OR T E' | epsilon
    
    T → F T'        (AND level)
    T' → AND F T' | epsilon
    
    F → NOT F | ( E ) | comparison
    \end{verbatim}
    
    Precedence: NOT > AND > OR
    
    \item \textbf{Perbandingan recursive descent vs table-driven LL:}
    
    \textbf{Recursive Descent:}
    \begin{itemize}
        \item \textbf{Keuntungan}: Kode lebih readable, error recovery lebih baik, mudah di-debug
        \item \textbf{Kerugian}: Hanya cocok untuk LL(1) grammar, lebih banyak kode manual
    \end{itemize}
    
    \textbf{Table-driven LL:}
    \begin{itemize}
        \item \textbf{Keuntungan}: Grammar dapat diubah tanpa mengubah kode parser, lebih compact
        \item \textbf{Kerugian}: Error messages kurang informatif, lebih sulit di-debug, memerlukan table construction
    \end{itemize}
    
    \item \textbf{Parser untuk right-associative operator:}
    
    Untuk operator assignment \texttt{=} yang right-associative:
    \begin{verbatim}
    assignment → identifier = assignment | expression
    \end{verbatim}
    
    Implementasi: Parse identifier dan \texttt{=}, kemudian parse assignment secara rekursif (right-associative).
\end{enumerate}

\subsection{Jawaban Latihan Bab 7: Bottom-Up Parsing dan Parser Generator}

\begin{enumerate}
    \item \textbf{Perbedaan top-down dan bottom-up parsing:}
    
    \textbf{Top-down parsing:}
    \begin{itemize}
        \item Mulai dari start symbol, turun ke terminal
        \item Menggunakan leftmost derivation
        \item Contoh: Recursive descent, LL parsers
        \item Cocok untuk: Grammar yang tidak memiliki left recursion, grammar yang lebih sederhana
    \end{itemize}
    
    \textbf{Bottom-up parsing:}
    \begin{itemize}
        \item Mulai dari terminal, naik ke start symbol
        \item Menggunakan rightmost derivation dalam reverse
        \item Contoh: LR, LALR, SLR parsers
        \item Cocok untuk: Grammar yang lebih kompleks, grammar dengan left recursion
    \end{itemize}
    
    \item \textbf{Shift-reduce parsing manual untuk \texttt{id + id * id}:}
    
    Grammar:
    \begin{verbatim}
    E → E + T | T
    T → T * F | F
    F → ( E ) | id
    \end{verbatim}
    
    \begin{tabular}{|l|l|l|l|}
    \hline
    \textbf{Stack} & \textbf{Input} & \textbf{Action} & \textbf{Production} \\
    \hline
    \$ & id + id * id \$ & Shift & \\
    \$ id & + id * id \$ & Reduce & F → id \\
    \$ F & + id * id \$ & Reduce & T → F \\
    \$ T & + id * id \$ & Reduce & E → T \\
    \$ E & + id * id \$ & Shift & \\
    \$ E + & id * id \$ & Shift & \\
    \$ E + id & * id \$ & Reduce & F → id \\
    \$ E + F & * id \$ & Reduce & T → F \\
    \$ E + T & * id \$ & Shift & \\
    \$ E + T * & id \$ & Shift & \\
    \$ E + T * id & \$ & Reduce & F → id \\
    \$ E + T * F & \$ & Reduce & T → T * F \\
    \$ E + T & \$ & Reduce & E → E + T \\
    \$ E & \$ & Accept & \\
    \hline
    \end{tabular}
    
    \item \textbf{Perbedaan SLR(1), CLR(1), dan LALR(1):}
    
    \textbf{SLR(1) - Simple LR:}
    \begin{itemize}
        \item Menggunakan LR(0) item sets
        \item Reduce hanya jika lookahead dalam Follow set
        \item Tabel lebih kecil, tetapi kurang powerful
    \end{itemize}
    
    \textbf{CLR(1) - Canonical LR:}
    \begin{itemize}
        \item Menggunakan LR(1) items dengan lookahead spesifik
        \item Paling powerful, dapat menangani lebih banyak grammar
        \item Tabel sangat besar
    \end{itemize}
    
    \textbf{LALR(1) - Look-Ahead LR:}
    \begin{itemize}
        \item Merge states dari CLR(1) yang memiliki LR(0) core sama
        \item Kompromi praktis: tabel lebih kecil dari CLR(1), lebih powerful dari SLR(1)
        \item Digunakan oleh Bison dan Yacc
    \end{itemize}
    
    \textbf{Mengapa LALR(1) populer:}
    \begin{itemize}
        \item Balance yang baik antara power dan table size
        \item Dapat menangani sebagian besar grammar praktis
        \item Tabel cukup kecil untuk efisiensi
    \end{itemize}
    
    \item \textbf{File Bison untuk ekspresi aritmatika:}
    
    \begin{verbatim}
    %{
    #include <stdio.h>
    %}
    
    %token NUMBER
    %left '+' '-'
    %left '*' '/'
    
    %%
    expr: expr '+' expr { printf("+ "); }
       | expr '-' expr { printf("- "); }
       | expr '*' expr { printf("* "); }
       | expr '/' expr { printf("/ "); }
       | '(' expr ')' { /* no action */ }
       | NUMBER { printf("%s ", $1); }
    %%
    \end{verbatim}
    
    \item \textbf{Integrasi Flex dan Bison untuk calculator:}
    
    Langkah-langkah:
    \begin{enumerate}
        \item Buat Flex lexer yang menghasilkan NUMBER token
        \item Buat Bison parser dengan semantic actions untuk evaluasi
        \item Link kedua file dan compile
    \end{enumerate}
    
    Semantic actions mengevaluasi ekspresi dan mencetak hasil.
    
    \item \textbf{Error recovery dalam Bison:}
    
    Menggunakan token \texttt{error}:
    \begin{verbatim}
    expr: expr '+' expr
       | error { yyerror("Syntax error in expression"); }
       | error ';' { /* recover by skipping to semicolon */ }
    \end{verbatim}
    
    Strategi: Skip token sampai menemukan synchronization point (misalnya \texttt{;}).
    
    \item \textbf{Perbandingan performa:}
    
    \textbf{Recursive descent:}
    \begin{itemize}
        \item Lebih cepat untuk grammar sederhana
        \item Overhead function calls
    \end{itemize}
    
    \textbf{Bison-generated:}
    \begin{itemize}
        \item Table lookup overhead
        \item Lebih efisien untuk grammar kompleks
        \item Dapat dioptimasi dengan table compression
    \end{itemize}
\end{enumerate}

\subsection{Jawaban Latihan Bab 8: Semantic Actions dan AST Construction}

\begin{enumerate}
    \item \textbf{Parser untuk ekspresi boolean:}
    
    Grammar dengan semantic actions untuk membangun AST:
    \begin{verbatim}
    %union {
        ASTNode* node;
    }
    
    %type <node> expr
    
    %%
    expr: expr AND expr { $$ = createBinaryNode(AND, $1, $3); }
       | expr OR expr  { $$ = createBinaryNode(OR, $1, $3); }
       | NOT expr      { $$ = createUnaryNode(NOT, $2); }
       | comparison    { $$ = $1; }
    
    comparison: expr '<' expr
        { $$ = createBinaryNode(LT, $1, $3); }
             | expr '>' expr
        { $$ = createBinaryNode(GT, $1, $3); }
             | expr EQ expr
        { $$ = createBinaryNode(EQ, $1, $3); }
             | expr NE expr
        { $$ = createBinaryNode(NE, $1, $3); }
    %%
    \end{verbatim}
    
    \item \textbf{Modifikasi calculator:}
    
    Fitur tambahan:
    \begin{itemize}
        \item \textbf{Variabel}: Symbol table untuk menyimpan nilai variabel
        \item \textbf{Fungsi matematika}: Built-in functions (sin, cos, sqrt)
        \item \textbf{Error handling}: Type checking, undefined variable detection
    \end{itemize}
    
    \item \textbf{Parser untuk konfigurasi file:}
    
    Grammar:
    \begin{verbatim}
    config: { /* init */ } config_items
    
    config_items: config_items config_item | config_item
    
    config_item: key '=' value '\n'
              | section
    
    section: IDENTIFIER '{' config_items '}'
    
    key: IDENTIFIER
    value: STRING | NUMBER
    \end{verbatim}
    
    Semantic actions membangun struktur data konfigurasi.
    
    \item \textbf{Semantic actions untuk AST lengkap:}
    
    Fungsi-fungsi yang diperlukan:
    \begin{itemize}
        \item \textbf{Print AST}: Traverse AST dan print dalam format tree (pre-order atau in-order)
        \item \textbf{Evaluate AST}: Jika semua nilai diketahui, evaluasi ekspresi
        \item \textbf{Optimize AST}: Constant folding - ganti ekspresi konstanta dengan hasilnya
    \end{itemize}
    
    \item \textbf{Perbedaan LALR(1), GLR parsing:}
    
    \textbf{LALR(1) - Default Bison:}
    \begin{itemize}
        \item Deterministic parsing
        \item Satu parse tree untuk setiap input
        \item Tidak dapat menangani ambiguous grammar
        \item Lebih cepat dan efisien
    \end{itemize}
    
    \textbf{GLR - Generalized LR:}
    \begin{itemize}
        \item Dapat menangani ambiguous grammar
        \item Menjaga multiple parse trees aktif secara bersamaan
        \item Merge stack prefixes yang mungkin
        \item Lebih lambat tetapi lebih powerful
    \end{itemize}
    
    \textbf{Kapan digunakan:}
    \begin{itemize}
        \item LALR(1): Grammar yang unambiguous, sebagian besar kasus praktis
        \item GLR: Grammar yang ambiguous, natural language processing, extensible syntax
    \end{itemize}
\end{enumerate}

\subsection{Jawaban Latihan Bab 9: Abstract Syntax Tree (AST)}

\begin{enumerate}
    \item \textbf{AST untuk program:}
    
    Program:
    \begin{verbatim}
    int x = 10;
    int y = 20;
    int z = x + y * 2;
    \end{verbatim}
    
    Struktur AST:
    \begin{itemize}
        \item Root: Program node dengan tiga children (declarations)
        \item Setiap declaration: VarDecl node dengan type, identifier, dan optional initializer
        \item Ekspresi \texttt{x + y * 2}: BinaryExpr node dengan operator \texttt{+}, left adalah Identifier \texttt{x}, right adalah BinaryExpr dengan operator \texttt{*}
    \end{itemize}
    
    \item \textbf{Implementasi AST node:}
    
    \textbf{For loop statement:}
    \begin{itemize}
        \item Node: ForStmt dengan fields: init (optional), condition, update (optional), body
    \end{itemize}
    
    \textbf{Array access expression:}
    \begin{itemize}
        \item Node: ArrayAccess dengan fields: array (expression), index (expression)
    \end{itemize}
    
    \textbf{String literal:}
    \begin{itemize}
        \item Node: StringLiteral dengan field: value (string)
    \end{itemize}
    
    \textbf{Boolean literal:}
    \begin{itemize}
        \item Node: BoolLiteral dengan field: value (bool)
    \end{itemize}
    
    \item \textbf{Visitor untuk menghitung jumlah node:}
    
    Implementasi menggunakan visitor pattern:
    \begin{itemize}
        \item Visitor memiliki counter
        \item Setiap node memanggil \texttt{accept(visitor)}
        \item Visitor increment counter dan traverse children
        \item Hasil: total jumlah node dalam AST
    \end{itemize}
    
    \item \textbf{Visitor untuk constant folding:}
    
    Algoritma:
    \begin{itemize}
        \item Traverse AST secara post-order
        \item Jika menemukan BinaryExpr dengan kedua operan adalah konstanta:
        \begin{itemize}
            \item Evaluasi ekspresi (misalnya 3 + 5 = 8)
            \item Ganti BinaryExpr dengan Literal node yang berisi hasil
        \end{itemize}
        \item Ulangi sampai tidak ada perubahan
    \end{itemize}
    
    \item \textbf{Modifikasi PrettyPrinter:}
    
    Improvements:
    \begin{itemize}
        \item Preserve whitespace dan formatting sebisa mungkin
        \item Handle operator precedence dengan parentheses yang tepat
        \item Format indentation yang konsisten
        \item Preserve comments jika ada
    \end{itemize}
    
    \item \textbf{AST visualizer dengan Graphviz DOT:}
    
    Implementasi:
    \begin{itemize}
        \item Traverse AST dan generate DOT format
        \item Setiap node menjadi node dalam graph
        \item Edges menunjukkan parent-child relationships
        \item Output dapat di-render dengan \texttt{dot} command
    \end{itemize}
    
    \item \textbf{Mengapa AST lebih disukai daripada parse tree:}
    
    Alasan:
    \begin{itemize}
        \item \textbf{Lebih kompak}: Menghilangkan detail sintaksis yang tidak relevan
        \item \textbf{Fokus semantik}: Hanya menyertakan informasi yang diperlukan untuk fase selanjutnya
        \item \textbf{Mudah di-manipulasi}: Struktur yang lebih sederhana memudahkan transformasi
        \item \textbf{Efisien}: Ukuran lebih kecil, traversal lebih cepat
    \end{itemize}
    
    \item \textbf{Traversal orders untuk \texttt{(a + b) * (c - d)}:}
    
    \textbf{Pre-order}: \texttt{* + a b - c d} (operator sebelum operan)
    
    \textbf{In-order}: \texttt{(a + b) * (c - d)} (mirip dengan ekspresi asli)
    
    \textbf{Post-order}: \texttt{a b + c d - *} (operator setelah operan, cocok untuk evaluasi)
\end{enumerate}

\subsection{Jawaban Latihan Bab 10: Symbol Table dan Scope Management}

\begin{enumerate}
    \item \textbf{Implementasi symbol table lengkap:}
    
    Fitur-fitur:
    \begin{itemize}
        \item \textbf{Insert}: Menambahkan symbol ke scope saat ini
        \item \textbf{Lookup}: Mencari symbol mulai dari scope saat ini ke parent scopes
        \item \textbf{Delete}: Menghapus symbol dari scope (biasanya saat exit scope)
        \item \textbf{Nested scopes}: Stack of hash tables, setiap scope memiliki parent pointer
        \item \textbf{Shadowing detection}: Warning ketika identifier shadow outer declaration
        \item \textbf{Visualisasi}: Print symbol table dengan indentasi untuk menunjukkan hierarchy
    \end{itemize}
    
    \item \textbf{Test cases:}
    
    \textbf{Nested scopes dengan shadowing:}
    \begin{verbatim}
    int x = 1;
    {
        int x = 2;  // Shadows outer x
        // x refers to inner x (2)
    }
    // x refers to outer x (1)
    \end{verbatim}
    
    \textbf{Duplicate declaration:}
    \begin{verbatim}
    int x = 1;
    int x = 2;  // Error: duplicate declaration
    \end{verbatim}
    
    \textbf{Undeclared identifier:}
    \begin{verbatim}
    x = 10;  // Error: x not declared
    \end{verbatim}
    
    \textbf{Function parameters:}
    \begin{verbatim}
    void func(int x) {
        // x is in function scope
        int y = x + 1;  // OK: x is parameter
    }
    \end{verbatim}
    
    \item \textbf{Visualisasi symbol table untuk program:}
    
    Program:
    \begin{verbatim}
    int a = 1;        // Global scope
    int b = 2;
    
    void func1(int x) {  // Function scope
        int a = 10;      // Shadows global a
        int c = 20;
        
        {                // Block scope
            int b = 30;  // Shadows func1 b
            int d = 40;
        }
    }
    
    void func2() {       // Function scope
        int x = 100;
        int y = 200;
    }
    \end{verbatim}
    
    Symbol table structure:
    \begin{verbatim}
    Level 0 (Global):
      a -> int (line 1)
      b -> int (line 2)
      func1 -> function
      func2 -> function
    
    Level 1 (func1):
      x -> int (parameter)
      a -> int (line 4) [shadows global a]
      c -> int (line 5)
    
    Level 2 (block in func1):
      b -> int (line 8) [shadows func1 b]
      d -> int (line 9)
    
    Level 1 (func2):
      x -> int (line 14)
      y -> int (line 15)
    \end{verbatim}
    
    \item \textbf{Fitur tambahan:}
    
    \textbf{Tracking usages:}
    \begin{itemize}
        \item Simpan list semua lokasi dimana identifier digunakan
        \item Berguna untuk dead code elimination dan optimasi
    \end{itemize}
    
    \textbf{Forward declaration:}
    \begin{itemize}
        \item Simpan declaration tanpa body
        \item Resolve saat body ditemukan
    \end{itemize}
    
    \textbf{Scope numbering:}
    \begin{itemize}
        \item Assign unique number untuk setiap scope
        \item Memudahkan debugging dan visualisasi
    \end{itemize}
    
    \item \textbf{Perbandingan implementasi:}
    
    \textbf{Stack of hash tables:}
    \begin{itemize}
        \item \textbf{Kelebihan}: Simple, efficient lookup dalam scope saat ini
        \item \textbf{Kekurangan}: Lookup di parent scope memerlukan traversal
    \end{itemize}
    
    \textbf{Single hash table dengan per-name stacks:}
    \begin{itemize}
        \item \textbf{Kelebihan}: Fast lookup untuk name tertentu
        \item \textbf{Kekurangan}: Lebih kompleks, perlu manage multiple stacks
    \end{itemize}
\end{enumerate}

\subsection{Jawaban Latihan Bab 11: Type Checking dan Semantic Analysis}

\begin{enumerate}
    \item \textbf{Perbedaan static dan dynamic type checking:}
    
    \textbf{Static type checking:}
    \begin{itemize}
        \item Type checking dilakukan pada waktu kompilasi
        \item Error ditemukan sebelum program dijalankan
        \item Contoh bahasa: C, C++, Java, Rust
        \item Keuntungan: Early error detection, better performance
    \end{itemize}
    
    \textbf{Dynamic type checking:}
    \begin{itemize}
        \item Type checking dilakukan pada waktu runtime
        \item Error ditemukan saat program dijalankan
        \item Contoh bahasa: Python, JavaScript, Ruby
        \item Keuntungan: Lebih fleksibel, rapid prototyping
    \end{itemize}
    
    \item \textbf{Type checker untuk ekspresi aritmatika:}
    
    Implementasi:
    \begin{itemize}
        \item \textbf{Operasi +, -, *, /}: Cek bahwa kedua operan adalah int atau float
        \item \textbf{Type promotion}: Jika salah satu operan float, hasilnya float
        \item \textbf{Operasi perbandingan}: Cek kompatibilitas tipe, hasilnya boolean
    \end{itemize}
    
    \item \textbf{Fungsi type compatibility:}
    
    Aturan:
    \begin{itemize}
        \item Exact match selalu kompatibel
        \item int dapat di-assign ke float (implicit conversion)
        \item float tidak dapat di-assign ke int tanpa explicit cast
    \end{itemize}
    
    \item \textbf{Semantic error detection:}
    
    \textbf{Undeclared variable:}
    \begin{itemize}
        \item Saat menemukan identifier, cek di symbol table
        \item Jika tidak ditemukan, report error
    \end{itemize}
    
    \textbf{Type mismatch pada assignment:}
    \begin{itemize}
        \item Cek tipe left-hand side dan right-hand side
        \item Gunakan fungsi compatibility check
    \end{itemize}
    
    \textbf{Wrong number of arguments:}
    \begin{itemize}
        \item Cek jumlah argument dengan jumlah parameter fungsi
        \item Cek tipe setiap argument dengan parameter yang sesuai
    \end{itemize}
    
    \item \textbf{Test cases:}
    
    \textbf{Valid expressions:}
    \begin{itemize}
        \item \texttt{int x = 42;}
        \item \texttt{float y = 3.14;}
        \item \texttt{int z = x + 10;}
        \item \texttt{bool b = x > 0;}
    \end{itemize}
    
    \textbf{Invalid expressions:}
    \begin{itemize}
        \item \texttt{int x = "string";} // Type mismatch
        \item \texttt{x = 10;} // Undeclared variable
        \item \texttt{add(5);} // Wrong number of arguments
    \end{itemize}
    
    \item \textbf{Mengapa annotated AST diperlukan:}
    
    Alasan:
    \begin{itemize}
        \item \textbf{Type information}: Setiap node menyimpan tipe hasil ekspresi
        \item \textbf{Code generation}: Informasi tipe digunakan untuk memilih instruksi yang tepat
        \item \textbf{Optimization}: Type information memungkinkan optimasi yang lebih baik
    \end{itemize}
    
    \item \textbf{Type checking untuk if dan while:}
    
    Implementasi:
    \begin{itemize}
        \item Cek bahwa kondisi adalah boolean
        \item Jika bukan boolean, report type error
    \end{itemize}
    
    \item \textbf{Perbandingan nominal dan structural typing:}
    
    \textbf{Nominal typing:}
    \begin{itemize}
        \item Tipe kompatibel jika memiliki nama yang sama
        \item Contoh: Java, C++
        \item Keuntungan: Explicit, clear contracts
    \end{itemize}
    
    \textbf{Structural typing:}
    \begin{itemize}
        \item Tipe kompatibel jika memiliki struktur yang sama
        \item Contoh: TypeScript, Go interfaces
        \item Keuntungan: Lebih fleksibel, duck typing
    \end{itemize}
\end{enumerate}

\subsection{Jawaban Latihan Bab 12: Intermediate Code Generation}

\begin{enumerate}
    \item \textbf{TAC untuk ekspresi:}
    
    \textbf{\texttt{a = b + c * d - e}:}
    \begin{verbatim}
    t1 = c * d
    t2 = b + t1
    t3 = t2 - e
    a = t3
    \end{verbatim}
    
    \textbf{\texttt{x = (a + b) * (c - d)}:}
    \begin{verbatim}
    t1 = a + b
    t2 = c - d
    t3 = t1 * t2
    x = t3
    \end{verbatim}
    
    \textbf{\texttt{y = -a + b * -c}:}
    \begin{verbatim}
    t1 = -a
    t2 = -c
    t3 = b * t2
    t4 = t1 + t3
    y = t4
    \end{verbatim}
    
    \item \textbf{Generator TAC untuk operasi khusus:}
    
    \textbf{Unary operations:}
    \begin{itemize}
        \item Negation: \texttt{t1 = -operand}
        \item Logical NOT: \texttt{t1 = !operand}
    \end{itemize}
    
    \textbf{Array access:}
    \begin{itemize}
        \item \texttt{t1 = index * element\_size}
        \item \texttt{t2 = base + t1}
        \item \texttt{t3 = mem[t2]}
    \end{itemize}
    
    \textbf{Member access:}
    \begin{itemize}
        \item \texttt{t1 = object + offset}
        \item \texttt{t2 = mem[t1]}
    \end{itemize}
    
    \item \textbf{TAC untuk for loop:}
    
    Program:
    \begin{verbatim}
    int i, sum;
    sum = 0;
    for (i = 1; i <= 10; i = i + 1) {
        sum = sum + i;
    }
    \end{verbatim}
    
    TAC:
    \begin{verbatim}
    sum = 0
    i = 1
    L1: t1 = i <= 10
        jmpf t1, L2
        t2 = sum + i
        sum = t2
        t3 = i + 1
        i = t3
        jmp L1
    L2:
    \end{verbatim}
    
    \item \textbf{Common subexpression elimination:}
    
    Kode asli:
    \begin{verbatim}
    x = a + b * c
    y = a + b * c
    z = (a + b) * c
    w = (a + b) * c
    \end{verbatim}
    
    Setelah CSE:
    \begin{verbatim}
    t1 = b * c
    t2 = a + b
    x = a + t1
    y = x        // atau y = a + t1
    z = t2 * c
    w = z        // atau w = t2 * c
    \end{verbatim}
    
    \item \textbf{Perbedaan TAC dan quadruples:}
    
    \textbf{Three-address code:}
    \begin{itemize}
        \item Format text: \texttt{t1 = a + b}
        \item Mudah dibaca manusia
        \item Sequential representation
    \end{itemize}
    
    \textbf{Quadruples:}
    \begin{itemize}
        \item Format struktural: \texttt{(op: +, arg1: a, arg2: b, result: t1)}
        \item Mudah di-reorder untuk optimasi
        \item Lebih mudah untuk manipulasi programmatic
    \end{itemize}
    
    \textbf{Quadruples lebih menguntungkan untuk:}
    \begin{itemize}
        \item Optimasi yang memerlukan reordering
        \item Common subexpression elimination
        \item Code generation yang memerlukan manipulasi struktural
    \end{itemize}
    
    \item \textbf{Generator TAC untuk switch statement:}
    
    Strategi:
    \begin{itemize}
        \item Generate comparison untuk setiap case
        \item Gunakan jump table jika case values consecutive
        \item Atau gunakan chain of if-else dengan labels
    \end{itemize}
    
    \item \textbf{Constant folding pada TAC generator:}
    
    Implementasi:
    \begin{itemize}
        \item Saat generate TAC, cek apakah kedua operan adalah konstanta
        \item Jika ya, evaluasi langsung dan generate assignment konstanta hasil
        \item Contoh: \texttt{x = 3 + 5} langsung menjadi \texttt{x = 8}
    \end{itemize}
    
    \item \textbf{Perbandingan pendekatan TAC generation:}
    
    \textbf{Top-down (generate sambil traverse):}
    \begin{itemize}
        \item Generate TAC langsung saat traverse AST
        \item Keuntungan: Simple, langsung menghasilkan output
        \item Kerugian: Sulit untuk optimasi lintas ekspresi
    \end{itemize}
    
    \textbf{Bottom-up (build IR structure dulu):}
    \begin{itemize}
        \item Build struktur IR lengkap dulu, kemudian generate TAC
        \item Keuntungan: Memungkinkan optimasi sebelum code generation
        \item Kerugian: Lebih kompleks, memerlukan lebih banyak memory
    \end{itemize}
\end{enumerate}

\subsection{Jawaban Latihan Bab 13: Runtime Environment dan Memory Management}

\begin{enumerate}
    \item \textbf{Perbedaan static, stack, dan heap allocation:}
    
    \textbf{Static allocation:}
    \begin{itemize}
        \item Alokasi pada waktu kompilasi
        \item Lifetime: Selama program berjalan
        \item Contoh: Global variables, static variables
        \item Lokasi: Data segment
    \end{itemize}
    
    \textbf{Stack allocation:}
    \begin{itemize}
        \item Alokasi pada waktu runtime (function call)
        \item Lifetime: Selama fungsi aktif
        \item Contoh: Local variables, function parameters
        \item Lokasi: Stack segment
        \item Management: Automatic (dikelola oleh compiler)
    \end{itemize}
    
    \textbf{Heap allocation:}
    \begin{itemize}
        \item Alokasi dinamis pada waktu runtime
        \item Lifetime: Sampai secara eksplisit di-deallocate
        \item Contoh: Dynamic arrays, objects dengan lifetime fleksibel
        \item Lokasi: Heap segment
        \item Management: Manual (programmer) atau garbage collection
    \end{itemize}
    
    \item \textbf{Diagram activation records untuk \texttt{factorial(3)}:}
    
    Stack saat \texttt{factorial(3)} sedang dieksekusi (recursive call):
    \begin{verbatim}
    High Address
    +---------------------+
    | main() AR           |
    |   result            |
    +---------------------+
    | factorial(3) AR     | <- Current (top)
    |   n = 3            |
    |   return address   |
    |   control link     | -> main AR
    +---------------------+
    | factorial(2) AR    |
    |   n = 2            |
    |   return address   |
    |   control link     | -> factorial(3) AR
    +---------------------+
    | factorial(1) AR    |
    |   n = 1            |
    |   return address   |
    |   control link     | -> factorial(2) AR
    Low Address
    \end{verbatim}
    
    \item \textbf{Runtime stack simulator:}
    
    Implementasi:
    \begin{itemize}
        \item \textbf{Stack structure}: Linked list atau array of activation records
        \item \textbf{Push frame}: Saat function call, buat AR baru dan push ke stack
        \item \textbf{Pop frame}: Saat function return, pop AR dari stack
        \item \textbf{Parameter passing}: Simpan parameters dalam AR
        \item \textbf{Local variables}: Simpan dalam AR
        \item \textbf{Return value}: Simpan dalam AR sebelum pop
    \end{itemize}
    
    \item \textbf{Calling sequence untuk fungsi dengan 3 parameters:}
    
    Assembly code (simplified):
    \begin{verbatim}
    ; Caller sequence
    push param3      ; Push parameter 3
    push param2      ; Push parameter 2
    push param1      ; Push parameter 1
    call function    ; Call function
    add esp, 12      ; Clean up parameters (3 * 4 bytes)
    
    ; Callee sequence (function prologue)
    push ebp         ; Save frame pointer
    mov ebp, esp     ; Set new frame pointer
    sub esp, N       ; Allocate space for locals
    
    ; Function body
    ...
    
    ; Return sequence (function epilogue)
    mov eax, return_value  ; Set return value
    mov esp, ebp     ; Restore stack pointer
    pop ebp          ; Restore frame pointer
    ret              ; Return
    \end{verbatim}
    
    \item \textbf{Perbandingan manual memory management vs garbage collection:}
    
    \textbf{Manual memory management:}
    \begin{itemize}
        \item \textbf{Keuntungan}: Kontrol penuh, predictable performance, no GC overhead
        \item \textbf{Kekurangan}: Mudah terjadi memory leak, use-after-free bugs, lebih kompleks
        \item Contoh: C, C++
    \end{itemize}
    
    \textbf{Garbage collection:}
    \begin{itemize}
        \item \textbf{Keuntungan}: Tidak ada memory leak, lebih aman, programmer tidak perlu manage memory
        \item \textbf{Kekurangan}: GC pause, overhead, unpredictable timing
        \item Contoh: Java, Python, Go
    \end{itemize}
    
    \item \textbf{Implementasi mark-and-sweep garbage collector:}
    
    Algoritma:
    \begin{enumerate}
        \item \textbf{Mark phase}: Traverse dari root set (stack, global variables, registers), mark semua reachable objects
        \item \textbf{Sweep phase}: Scan semua objects, free yang tidak ter-mark
        \item \textbf{Handle cyclic references}: Mark phase secara otomatis menangani cycles karena menggunakan graph traversal
    \end{enumerate}
    
    \item \textbf{Memory layout untuk program:}
    
    \begin{verbatim}
    int global;           // Static/Global segment
    static int static_var; // Static/Global segment
    
    void func() {
        int local;              // Stack segment
        static int static_local; // Static (meskipun dalam fungsi)
        int* ptr = new int;     // Heap segment (yang ditunjuk ptr)
        // ptr sendiri ada di stack
    }
    \end{verbatim}
    
    \item \textbf{Recursive call yang sangat dalam:}
    
    Masalah yang mungkin terjadi:
    \begin{itemize}
        \item \textbf{Stack overflow}: Stack segment terbatas, recursive call yang sangat dalam dapat melebihi batas
        \item \textbf{Memory exhaustion}: Setiap call memerlukan activation record
        \item \textbf{Performance degradation}: Overhead function calls
    \end{itemize}
    
    Solusi:
    \begin{itemize}
        \item Tail call optimization (jika compiler mendukung)
        \item Iterative implementation
        \item Increase stack size (jika memungkinkan)
    \end{itemize}
\end{enumerate}

\subsection{Jawaban Latihan Bab 14: Code Generation}

\begin{enumerate}
    \item \textbf{Code generator untuk operasi aritmatika RISC-V:}
    
    Implementasi:
    \begin{itemize}
        \item \textbf{Addition}: \texttt{ADD rd, rs1, rs2}
        \item \textbf{Subtraction}: \texttt{SUB rd, rs1, rs2}
        \item \textbf{Multiplication}: \texttt{MUL rd, rs1, rs2}
        \item \textbf{Division}: \texttt{DIV rd, rs1, rs2}
    \end{itemize}
    
    \item \textbf{Code generator untuk assignment:}
    
    \textbf{Constant ke variabel:}
    \begin{verbatim}
    LI t1, 42        ; Load immediate
    SW t1, x         ; Store to variable
    \end{verbatim}
    
    \textbf{Variabel ke variabel:}
    \begin{verbatim}
    LW t1, x         ; Load from x
    SW t1, y         ; Store to y
    \end{verbatim}
    
    \textbf{Ekspresi ke variabel:}
    \begin{verbatim}
    LW t1, a
    LW t2, b
    ADD t3, t1, t2
    SW t3, result
    \end{verbatim}
    
    \item \textbf{Local register allocation:}
    
    Algoritma sederhana:
    \begin{itemize}
        \item Scan basic block, assign register untuk setiap variabel aktif
        \item Jika register penuh, spill variabel yang paling lama tidak digunakan ke memory
        \item Load dari memory saat diperlukan kembali
    \end{itemize}
    
    \item \textbf{Code generator untuk function call:}
    
    RISC-V calling convention:
    \begin{itemize}
        \item Parameters: a0-a7 (first 8 parameters), kemudian stack
        \item Return value: a0
        \item Caller-saved: t0-t6, a0-a7
        \item Callee-saved: s0-s11
    \end{itemize}
    
    Code generation:
    \begin{verbatim}
    ; Caller
    ADDI sp, sp, -16    ; Allocate stack space
    SW ra, 12(sp)       ; Save return address
    MV a0, param1       ; Pass parameter 1
    MV a1, param2       ; Pass parameter 2
    CALL function       ; Call function
    LW ra, 12(sp)       ; Restore return address
    ADDI sp, sp, 16     ; Deallocate
    MV result, a0       ; Get return value
    
    ; Callee
    function:
        ADDI sp, sp, -16  ; Allocate frame
        SW ra, 12(sp)     ; Save return address
        SW s0, 8(sp)      ; Save callee-saved
        ADDI s0, sp, 16   ; Set frame pointer
        ; Function body
        MV a0, return_val ; Set return value
        LW s0, 8(sp)      ; Restore
        LW ra, 12(sp)     ; Restore
        ADDI sp, sp, 16   ; Deallocate
        RET               ; Return
    \end{verbatim}
    
    \item \textbf{Test workflow lengkap:}
    
    Program: \texttt{a * b + c}
    
    \textbf{Compile}:
    \begin{verbatim}
    TAC:
    t1 = a * b
    t2 = t1 + c
    \end{verbatim}
    
    \textbf{Assemble}:
    \begin{verbatim}
    LW t0, a
    LW t1, b
    MUL t2, t0, t1
    LW t3, c
    ADD t4, t2, t3
    \end{verbatim}
    
    \textbf{Link}: Menghasilkan executable
    
    \textbf{Run}: Eksekusi program
    
    \item \textbf{Perbandingan dengan dan tanpa optimasi register allocation:}
    
    \textbf{Tanpa optimasi}:
    \begin{verbatim}
    LW t0, a         ; Load a
    LW t1, b         ; Load b
    MUL t2, t0, t1   ; t2 = a * b
    SW t2, temp      ; Spill to memory
    LW t3, c         ; Load c
    LW t4, temp      ; Reload from memory
    ADD t5, t4, t3   ; t5 = t2 + c
    \end{verbatim}
    Instruksi: 7, Memory access: 5
    
    \textbf{Dengan optimasi}:
    \begin{verbatim}
    LW t0, a
    LW t1, b
    MUL t2, t0, t1   ; Keep in register
    LW t3, c
    ADD t4, t2, t3   ; Use register directly
    \end{verbatim}
    Instruksi: 5, Memory access: 3
    
    \textbf{Improvement}: Mengurangi instruksi dan memory access.
    
    \item \textbf{Code generator untuk if-else:}
    
    \begin{verbatim}
    ; Condition evaluation
    LW t0, x
    LI t1, 0
    BGT t0, t1, then_label  ; Branch if x > 0
    
    ; Else branch
    else_label:
        LI t2, 0
        SW t2, y
        J end_label
    
    ; Then branch
    then_label:
        LI t2, 1
        SW t2, y
    
    end_label:
    \end{verbatim}
    
    \item \textbf{Code generator untuk loop:}
    
    \begin{verbatim}
    loop_start:
        ; Condition check
        LW t0, i
        LI t1, 10
        BGE t0, t1, loop_end  ; Branch if i >= 10
        
        ; Loop body
        LW t2, sum
        ADD t2, t2, t0
        SW t2, sum
        
        ; Increment
        ADDI t0, t0, 1
        SW t0, i
        
        J loop_start          ; Jump back
    
    loop_end:
    \end{verbatim}
\end{enumerate}

\subsection{Jawaban Latihan Bab 15: Optimasi Kompilator}

\begin{enumerate}
    \item \textbf{Identifikasi basic blocks:}
    
    Kode:
    \begin{verbatim}
    t1 = a + b
    t2 = c * d
    if t1 > t2 goto L1
    t3 = t1 - t2
    goto L2
    L1: t4 = t1 * t2
    L2: t5 = t3 + t4
    return t5
    \end{verbatim}
    
    Basic blocks:
    \begin{itemize}
        \item \textbf{Block 1}: \texttt{t1 = a + b}, \texttt{t2 = c * d}, \texttt{if t1 > t2 goto L1}
        \item \textbf{Block 2}: \texttt{t3 = t1 - t2}, \texttt{goto L2}
        \item \textbf{Block 3 (L1)}: \texttt{t4 = t1 * t2}
        \item \textbf{Block 4 (L2)}: \texttt{t5 = t3 + t4}, \texttt{return t5}
    \end{itemize}
    
    \item \textbf{Constant folding:}
    
    Kode asli:
    \begin{verbatim}
    t1 = 5 + 3
    t2 = t1 * 2
    t3 = 10 / 2
    x = t2 + t3
    \end{verbatim}
    
    Setelah constant folding:
    \begin{verbatim}
    t1 = 8        ; 5 + 3 = 8
    t2 = 16       ; 8 * 2 = 16
    t3 = 5        ; 10 / 2 = 5
    x = 21        ; 16 + 5 = 21
    \end{verbatim}
    
    Atau lebih optimal:
    \begin{verbatim}
    x = 21        ; Semua di-fold menjadi satu nilai
    \end{verbatim}
    
    \item \textbf{Constant propagation dan folding:}
    
    Kode asli:
    \begin{verbatim}
    x = 10
    y = 20
    t1 = x + 5
    t2 = y * 2
    z = t1 + t2
    \end{verbatim}
    
    Setelah constant propagation:
    \begin{verbatim}
    x = 10
    y = 20
    t1 = 10 + 5   ; x diganti dengan 10
    t2 = 20 * 2   ; y diganti dengan 20
    z = t1 + t2
    \end{verbatim}
    
    Setelah constant folding:
    \begin{verbatim}
    x = 10
    y = 20
    t1 = 15       ; 10 + 5 = 15
    t2 = 40       ; 20 * 2 = 40
    z = 55        ; 15 + 40 = 55
    \end{verbatim}
    
    \item \textbf{Dead code elimination:}
    
    Kode asli:
    \begin{verbatim}
    x = 10
    y = 20
    t1 = x + y
    t2 = 5 + 3      // Dead: t2 tidak digunakan
    t3 = t2 - 2     // Dead: t3 tidak digunakan
    z = t1 * 2
    return z
    \end{verbatim}
    
    Setelah dead code elimination:
    \begin{verbatim}
    x = 10
    y = 20
    t1 = x + y
    z = t1 * 2
    return z
    \end{verbatim}
    
    \item \textbf{Implementasi optimizer sederhana:}
    
    Algoritma:
    \begin{enumerate}
        \item Constant folding: Evaluasi ekspresi konstanta
        \item Constant propagation: Ganti variabel konstanta dengan nilainya
        \item Dead code elimination: Hapus assignment yang tidak digunakan
        \item Iterate sampai tidak ada perubahan
    \end{enumerate}
    
    \item \textbf{Perbedaan optimasi:}
    
    \textbf{Local vs Global:}
    \begin{itemize}
        \item Local: Dalam satu basic block
        \item Global: Lintas basic blocks, memerlukan data-flow analysis
    \end{itemize}
    
    \textbf{Machine-independent vs Machine-specific:}
    \begin{itemize}
        \item Machine-independent: Tidak bergantung pada target architecture (constant folding, dead code elimination)
        \item Machine-specific: Bergantung pada target (register allocation, instruction selection)
    \end{itemize}
    
    \textbf{Constant folding vs Constant propagation:}
    \begin{itemize}
        \item Constant folding: Evaluasi ekspresi konstanta langsung
        \item Constant propagation: Ganti penggunaan variabel konstanta dengan nilainya
    \end{itemize}
    
    \item \textbf{Benchmark untuk evaluasi optimasi:}
    
    Metrik:
    \begin{itemize}
        \item \textbf{Code size}: Ukuran executable sebelum dan sesudah optimasi
        \item \textbf{Execution time}: Waktu eksekusi program yang dikompilasi
        \item \textbf{Compilation time}: Waktu kompilasi dengan optimasi
    \end{itemize}
    
    Hasil yang diharapkan:
    \begin{itemize}
        \item Code size: Biasanya lebih kecil setelah optimasi
        \item Execution time: Biasanya lebih cepat setelah optimasi
        \item Compilation time: Biasanya lebih lama karena optimasi memerlukan analisis tambahan
    \end{itemize}
\end{enumerate}

\subsection{Jawaban Latihan Bab 16: Evaluasi dan Project Final}

\begin{enumerate}
    \item \textbf{Prepare Presentation:}
    
    \textbf{Outline presentasi:}
    \begin{enumerate}
        \item Introduction: Overview project
        \item Architecture: Komponen utama compiler
        \item Implementation: Tools dan teknik yang digunakan
        \item Demo: Live demonstration dengan test cases
        \item Evaluation: Benchmark results dan analisis
        \item Challenges: Masalah yang dihadapi dan solusi
        \item Conclusion: Lessons learned dan future work
    \end{enumerate}
    
    \textbf{Demo script dengan 5 test cases:}
    \begin{itemize}
        \item Test case 1: Simple arithmetic expressions
        \item Test case 2: Control flow (if-else, loops)
        \item Test case 3: Function calls
        \item Test case 4: Error handling
        \item Test case 5: Complex program
    \end{itemize}
    
    \item \textbf{Tool Evaluation:}
    
    \textbf{Tabel perbandingan:}
    \begin{itemize}
        \item Hand-written lexer vs Flex: Development time, maintainability, error messages
        \item Recursive descent vs Bison: Grammar support, error recovery, performance
        \item Trade-offs: Flexibility vs correctness, development time vs maintainability
    \end{itemize}
    
    \textbf{Justifikasi pilihan:}
    \begin{itemize}
        \item Pilih tools berdasarkan requirements project
        \item Pertimbangkan complexity, performance, dan maintainability
    \end{itemize}
    
    \item \textbf{Benchmarking:}
    
    \textbf{Test suite:}
    \begin{itemize}
        \item Small programs (10-100 lines)
        \item Medium programs (100-1000 lines)
        \item Large programs (1000+ lines)
    \end{itemize}
    
    \textbf{Metrik:}
    \begin{itemize}
        \item Compilation time
        \item Code size (executable)
        \item Execution time
    \end{itemize}
    
    \textbf{Laporan:}
    \begin{itemize}
        \item Tabel hasil benchmark
        \item Analisis perbandingan
        \item Identifikasi bottleneck
    \end{itemize}
    
    \item \textbf{Documentation:}
    
    \textbf{README.md:}
    \begin{itemize}
        \item Overview project
        \item Build instructions
        \item Usage examples
        \item Test instructions
    \end{itemize}
    
    \textbf{Design document:}
    \begin{itemize}
        \item Architecture overview
        \item Component descriptions
        \item Data structures
        \item Algorithms used
    \end{itemize}
    
    \textbf{API documentation:}
    \begin{itemize}
        \item Public interfaces
        \item Function signatures
        \item Usage examples
    \end{itemize}
    
    \item \textbf{Reflection:}
    
    \textbf{Refleksi pembelajaran:}
    \begin{itemize}
        \item Pemahaman tentang compiler phases
        \item Pengalaman implementasi
        \item Challenges yang dihadapi
        \item Lessons learned
    \end{itemize}
    
    \textbf{3 challenges utama:}
    \begin{enumerate}
        \item Error recovery yang baik
        \item Optimasi yang efektif
        \item Integrasi antar fase
    \end{enumerate}
    
    \textbf{5 lessons learned:}
    \begin{enumerate}
        \item Importance of good data structures
        \item Error messages sangat penting untuk user experience
        \item Testing adalah kunci untuk correctness
        \item Documentation membantu maintenance
        \item Trade-offs selalu ada dalam engineering decisions
    \end{enumerate}
    
    \textbf{3 area untuk improvement:}
    \begin{enumerate}
        \item Advanced optimizations
        \item Better error recovery
        \item Support untuk lebih banyak language features
    \end{enumerate}
    
    \item \textbf{Peer Review:}
    
    \textbf{Aspects to review:}
    \begin{itemize}
        \item Code quality dan organization
        \item Correctness dari compiler
        \item Performance dan optimizations
        \item Documentation quality
        \item Test coverage
    \end{itemize}
    
    \textbf{Feedback konstruktif:}
    \begin{itemize}
        \item Identifikasi strengths
        \item Suggest improvements
        \item Compare different approaches
    \end{itemize}
\end{enumerate}