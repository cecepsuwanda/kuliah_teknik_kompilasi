\section{Type Compatibility}

Type compatibility menentukan apakah satu tipe dapat digunakan di tempat tipe lain. Menurut sumber dari TypeScript documentation:

\begin{quote}
``Two types are compatible if one can be used in place of another without type errors. This often arises when assigning a value to a variable, passing arguments to a function, etc.''\footnote{\url{https://www.typescriptlang.org/docs/handbook/type-compatibility.html}}
\end{quote}

\subsection{Aturan Type Compatibility}

\subsubsection{Exact Match}

Dua tipe yang identik selalu kompatibel:

\begin{lstlisting}[language=C++,basicstyle=\ttfamily\footnotesize,breaklines=true,breakatwhitespace=false]
int x = 42;        // int = int (OK)
float y = 3.14;    // float = float (OK)
\end{lstlisting}

\subsubsection{Implicit Conversion (Type Promotion)}

Beberapa bahasa mengizinkan implicit conversion antara tipe yang "dekat":

\begin{lstlisting}[language=C++,basicstyle=\ttfamily\footnotesize,breaklines=true,breakatwhitespace=false]
int x = 42;
float y = x;       // int -> float (promotion) OK

float a = 3.14;
int b = a;         // float -> int (downgrade) ERROR atau perlu cast
\end{lstlisting}

Aturan umum untuk promotion:
\begin{itemize}
    \item \texttt{int} → \texttt{float} (biasanya diizinkan)
    \item \texttt{int} → \texttt{long} (diizinkan)
    \item \texttt{float} → \texttt{double} (diizinkan)
    \item \texttt{float} → \texttt{int} (biasanya memerlukan explicit cast)
\end{itemize}

\subsubsection{Subtyping}

Dalam bahasa berorientasi objek, tipe turunan kompatibel dengan tipe induk:

\begin{lstlisting}[language=Java,basicstyle=\ttfamily\footnotesize,breaklines=true,breakatwhitespace=false]
class Animal { }
class Dog extends Animal { }

Animal a = new Dog();  // Dog is subtype of Animal (OK)
\end{lstlisting}

\subsection{Implementasi Type Compatibility Check}

\begin{lstlisting}[language=C++, caption=Implementasi Type Compatibility]
bool TypeChecker::isCompatible(Type t1, Type t2) {
    // Exact match
    if (t1.kind == t2.kind) {
        // Untuk tipe kompleks, perlu cek lebih detail
        if (t1.kind == TypeKind::ARRAY) {
            return isCompatible(t1.subtypes[0], t2.subtypes[0]);
        }
        if (t1.kind == TypeKind::FUNCTION) {
            // Cek parameter types dan return type
            if (t1.subtypes.size() != t2.subtypes.size()) {
                return false;
            }
            for (size_t i = 0; i < t1.subtypes.size() - 1; i++) {
                if (!isCompatible(t1.subtypes[i], t2.subtypes[i])) {
                    return false;
                }
            }
            return isCompatible(
                t1.subtypes.back(), 
                t2.subtypes.back()
            );
        }
        return true;
    }
    
    // Implicit conversion rules
    if (t1.kind == TypeKind::INT && t2.kind == TypeKind::FLOAT) {
        return true;  // int dapat di-promote ke float
    }
    
    // Subtyping (jika ada)
    // ... implementasi subtyping check
    
    return false;
}

Type TypeChecker::promoteType(Type t1, Type t2) {
    // Jika salah satu float, hasilnya float
    if (t1.kind == TypeKind::FLOAT || t2.kind == TypeKind::FLOAT) {
        return Type{TypeKind::FLOAT};
    }
    // Default: int
    return Type{TypeKind::INT};
}
\end{lstlisting}