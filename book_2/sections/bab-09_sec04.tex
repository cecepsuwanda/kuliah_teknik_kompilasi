\section{Implementasi AST dalam C++}

Dalam C++, AST biasanya diimplementasikan menggunakan inheritance dan virtual functions. Berikut adalah contoh implementasi dasar:

\subsection{Base Node Class}

\begin{lstlisting}[language=C++, caption=Base AST Node Class]
// ASTNode.hpp
#ifndef ASTNODE_HPP
#define ASTNODE_HPP

#include <string>
#include <memory>
#include <vector>

// Forward declaration
class ASTVisitor;

// Base class untuk semua AST nodes
class ASTNode {
public:
    virtual ~ASTNode() = default;
    
    // Visitor pattern untuk traversal
    virtual void accept(ASTVisitor& visitor) = 0;
    
    // Location information untuk error reporting
    struct Location {
        int line;
        int column;
        std::string filename;
    };
    
    Location location;
};

#endif
\end{lstlisting}

\subsection{Expression Nodes}

\begin{lstlisting}[language=C++, caption=Expression Node Classes]
// Expression.hpp
#ifndef EXPRESSION_HPP
#define EXPRESSION_HPP

#include "ASTNode.hpp"
#include <string>
#include <memory>

// Base class untuk semua expressions
class Expr : public ASTNode {
public:
    // Type information (akan diisi oleh semantic analyzer)
    std::string type;
};

// Integer literal node
class IntLiteral : public Expr {
public:
    int value;
    
    IntLiteral(int val) : value(val) {}
    void accept(ASTVisitor& visitor) override;
};

// Identifier node (variable name, function name, etc.)
class Identifier : public Expr {
public:
    std::string name;
    
    Identifier(const std::string& n) : name(n) {}
    void accept(ASTVisitor& visitor) override;
};

// Binary expression node (+, -, *, /, ==, etc.)
class BinaryExpr : public Expr {
public:
    std::string op;  // Operator: "+", "-", "*", "/", "==", etc.
    std::unique_ptr<Expr> left;
    std::unique_ptr<Expr> right;
    
    BinaryExpr(const std::string& op, 
               std::unique_ptr<Expr> l, 
               std::unique_ptr<Expr> r)
        : op(op), left(std::move(l)), right(std::move(r)) {}
    
    void accept(ASTVisitor& visitor) override;
};

// Unary expression node (-, !, etc.)
class UnaryExpr : public Expr {
public:
    std::string op;
    std::unique_ptr<Expr> operand;
    
    UnaryExpr(const std::string& op, std::unique_ptr<Expr> opnd)
        : op(op), operand(std::move(opnd)) {}
    
    void accept(ASTVisitor& visitor) override;
};

// Function call node
class FunctionCall : public Expr {
public:
    std::unique_ptr<Identifier> functionName;
    std::vector<std::unique_ptr<Expr>> arguments;
    
    FunctionCall(std::unique_ptr<Identifier> name)
        : functionName(std::move(name)) {}
    
    void accept(ASTVisitor& visitor) override;
};

#endif
\end{lstlisting}

\subsection{Statement Nodes}

\begin{lstlisting}[language=C++, caption=Statement Node Classes]
// Statement.hpp
#ifndef STATEMENT_HPP
#define STATEMENT_HPP

#include "ASTNode.hpp"
#include "Expression.hpp"
#include <memory>
#include <vector>

// Base class untuk semua statements
class Stmt : public ASTNode {
};

// Expression statement (expression followed by semicolon)
class ExprStmt : public Stmt {
public:
    std::unique_ptr<Expr> expression;
    
    ExprStmt(std::unique_ptr<Expr> expr) 
        : expression(std::move(expr)) {}
    
    void accept(ASTVisitor& visitor) override;
};

// Variable declaration statement
class VarDecl : public Stmt {
public:
    std::string typeName;
    std::string varName;
    std::unique_ptr<Expr> initializer;  // Optional
    
    VarDecl(const std::string& type, const std::string& name)
        : typeName(type), varName(name), initializer(nullptr) {}
    
    VarDecl(const std::string& type, const std::string& name,
            std::unique_ptr<Expr> init)
        : typeName(type), varName(name), initializer(std::move(init)) {}
    
    void accept(ASTVisitor& visitor) override;
};

// Assignment statement
class AssignStmt : public Stmt {
public:
    std::unique_ptr<Identifier> left;
    std::unique_ptr<Expr> right;
    
    AssignStmt(std::unique_ptr<Identifier> l, std::unique_ptr<Expr> r)
        : left(std::move(l)), right(std::move(r)) {}
    
    void accept(ASTVisitor& visitor) override;
};

// If statement
class IfStmt : public Stmt {
public:
    std::unique_ptr<Expr> condition;
    std::unique_ptr<Stmt> thenBranch;
    std::unique_ptr<Stmt> elseBranch;  // Optional
    
    IfStmt(std::unique_ptr<Expr> cond, std::unique_ptr<Stmt> thenStmt)
        : condition(std::move(cond)), 
          thenBranch(std::move(thenStmt)), 
          elseBranch(nullptr) {}
    
    IfStmt(std::unique_ptr<Expr> cond, 
           std::unique_ptr<Stmt> thenStmt,
           std::unique_ptr<Stmt> elseStmt)
        : condition(std::move(cond)), 
          thenBranch(std::move(thenStmt)), 
          elseBranch(std::move(elseStmt)) {}
    
    void accept(ASTVisitor& visitor) override;
};

// While statement
class WhileStmt : public Stmt {
public:
    std::unique_ptr<Expr> condition;
    std::unique_ptr<Stmt> body;
    
    WhileStmt(std::unique_ptr<Expr> cond, std::unique_ptr<Stmt> b)
        : condition(std::move(cond)), body(std::move(b)) {}
    
    void accept(ASTVisitor& visitor) override;
};

// Block statement (compound statement)
class BlockStmt : public Stmt {
public:
    std::vector<std::unique_ptr<Stmt>> statements;
    
    void addStatement(std::unique_ptr<Stmt> stmt) {
        statements.push_back(std::move(stmt));
    }
    
    void accept(ASTVisitor& visitor) override;
};

// Return statement
class ReturnStmt : public Stmt {
public:
    std::unique_ptr<Expr> expression;  // Optional
    
    ReturnStmt() : expression(nullptr) {}
    ReturnStmt(std::unique_ptr<Expr> expr) : expression(std::move(expr)) {}
    
    void accept(ASTVisitor& visitor) override;
};

#endif
\end{lstlisting}

\subsection{Program Node}

\begin{lstlisting}[language=C++, caption=Program Node Class]
// Program.hpp
#ifndef PROGRAM_HPP
#define PROGRAM_HPP

#include "ASTNode.hpp"
#include "Statement.hpp"
#include <vector>
#include <memory>

// Root node untuk seluruh program
class Program : public ASTNode {
public:
    std::vector<std::unique_ptr<Stmt>> statements;
    
    void addStatement(std::unique_ptr<Stmt> stmt) {
        statements.push_back(std::move(stmt));
    }
    
    void accept(ASTVisitor& visitor) override;
};

#endif
\end{lstlisting}