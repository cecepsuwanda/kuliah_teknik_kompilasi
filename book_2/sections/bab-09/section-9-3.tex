\section{Live Variable Analysis dan Alokasi Register}

Analisis \compiler{Live Variable} adalah masalah \textbf{Backward} dengan meet operator \textbf{Union} ($\cup$). Analisis ini menjawab: "Apakah nilai variabel saat ini akan digunakan lagi di masa depan?".

\subsection{Persamaan Aliran Data (Backward)}
Kebalikan dari Reaching Defs, analisis ini merambat dari bawah ke atas:
\begin{enumerate}
    \item \textbf{Meet Operation}: $OUT[B] = \bigcup_{S \in Succ(B)} IN[S]$.
    \item \textbf{Transfer Function}: $IN[B] = USE[B] \cup (OUT[B] - DEF[B])$.
\end{enumerate}

\subsection{Peran dalam Alokasi Register}
Ini adalah dasar dari \textbf{Register Allocation} yang efisien.
\begin{itemize}
    \item Jika dua variabel tidak pernah "hidup" (\textit{live}) secara bersamaan di titik mana pun, keduanya dapat menempati register fisik yang sama.
    \item Kompilator membangun \textbf{Interference Graph}: simpul adalah variabel, dan sisi ditarik antar variabel yang live bersamaan. Masalah alokasi register kemudian diselesaikan sebagai masalah \textit{Graph Coloring}.
\end{itemize}

\begin{lstlisting}[language=C++]
// Contoh Analisis Liveness
x = 10;
y = 20;
print(x); // x live di sini, y mati (dead)
// y = 20 adalah "Dead Code" karena y tidak live pada titik ini
\end{lstlisting}
Informasi ini memungkinkan \textbf{Dead Code Elimination} skala global yang lebih akurat daripada sekadar analisis di dalam satu blok.
    
    
