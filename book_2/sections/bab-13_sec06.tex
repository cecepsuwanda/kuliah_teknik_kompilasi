\section{Heap Memory Management}

Heap memory management adalah proses mengalokasikan dan membebaskan memory di heap secara dinamis. Terdapat dua pendekatan utama:

\subsection{Manual Memory Management}

Dalam manual memory management (seperti C/C++), programmer harus secara eksplisit:
\begin{itemize}
    \item Mengalokasikan memory: \texttt{malloc()}, \texttt{new}
    \item Membebaskan memory: \texttt{free()}, \texttt{delete}
\end{itemize}

Keuntungan:
\begin{itemize}
    \item Kontrol penuh atas memory
    \item Tidak ada overhead garbage collector
    \item Predictable performance
\end{itemize}

Kekurangan:
\begin{itemize}
    \item Rentan terhadap memory leaks
    \item Dangling pointers
    \item Double free errors
    \item Memory fragmentation
\end{itemize}

\subsection{Allocation Algorithms}

Heap manager menggunakan berbagai algoritma untuk mengalokasikan memory:

\subsubsection{First Fit}

Mencari block pertama yang cukup besar:
\begin{itemize}
    \item Cepat (tidak perlu mencari semua)
    \item Dapat menyebabkan fragmentation
\end{itemize}

\subsubsection{Best Fit}

Mencari block terkecil yang cukup besar:
\begin{itemize}
    \item Mengurangi wasted space
    \item Lebih lambat (harus mencari semua)
    \item Dapat menyebabkan banyak small fragments
\end{itemize}

\subsubsection{Worst Fit}

Mencari block terbesar:
\begin{itemize}
    \item Meninggalkan large free blocks
    \item Dapat mengurangi fragmentation kecil
\end{itemize}

\subsubsection{Buddy Allocation}

Membagi memory menjadi blocks dengan ukuran power of 2:
\begin{itemize}
    \item Mudah untuk merge adjacent blocks
    \item Dapat menyebabkan internal fragmentation
\end{itemize}

\subsection{Garbage Collection}

Garbage collection adalah automatic memory management yang membebaskan memory yang tidak lagi digunakan. Menurut sumber dari StudyLib:

\begin{quote}
``Runtime environment: stack, heap, activation records; garbage collection intro. Managing run-time structures (activation records, memory layout, symbol tables).''\cite{studylib2024obe}
\end{quote}

\subsubsection{Konsep Garbage Collection}

Garbage collector mengidentifikasi dan membebaskan memory yang tidak lagi dapat diakses (unreachable) dari program. Object dianggap garbage jika:
\begin{itemize}
    \item Tidak ada pointer/reference yang menunjuk ke object tersebut
    \item Tidak dapat diakses dari root set (stack, global variables, registers)
\end{itemize}

\subsubsection{Strategi Garbage Collection}

\paragraph{Mark and Sweep}
\begin{enumerate}
    \item \textbf{Mark Phase}: Traverse dari root set, mark semua reachable objects
    \item \textbf{Sweep Phase}: Scan semua objects, free yang tidak di-mark
\end{enumerate}

Keuntungan:
\begin{itemize}
    \item Dapat menangani cyclic references
    \item Tidak memerlukan memory compaction
\end{itemize}

Kekurangan:
\begin{itemize}
    \item Dapat menyebabkan fragmentation
    \item Stop-the-world pauses
\end{itemize}

\paragraph{Reference Counting}
Setiap object memiliki counter yang menghitung jumlah reference ke object tersebut. Ketika counter menjadi 0, object di-free.

Keuntungan:
\begin{itemize}
    \item Incremental (tidak perlu stop-the-world)
    \item Memory dibebaskan segera saat tidak digunakan
\end{itemize}

Kekurangan:
\begin{itemize}
    \item Tidak dapat menangani cyclic references
    \item Overhead untuk setiap assignment
\end{itemize}

\paragraph{Copying Collector (Generational GC)}
Memory dibagi menjadi young generation dan old generation. Young objects yang survive beberapa collections dipromote ke old generation.

Keuntungan:
\begin{itemize}
    \item Efisien untuk short-lived objects
    \item Automatic compaction
\end{itemize}

Kekurangan:
\begin{itemize}
    \item Memerlukan extra memory (copying)
    \item Overhead untuk promotion
\end{itemize}

\subsubsection{Implementasi Sederhana Mark and Sweep}

Berikut adalah implementasi sederhana mark-and-sweep garbage collector:

\begin{lstlisting}[language=C++, caption={Implementasi sederhana mark-and-sweep GC}]
#include <vector>
#include <unordered_set>

class GCObject {
public:
    bool marked;
    std::vector<GCObject*> references;
    
    GCObject() : marked(false) {}
    virtual ~GCObject() {}
    
    void addReference(GCObject* obj) {
        references.push_back(obj);
    }
};

class SimpleGC {
private:
    std::vector<GCObject*> heap;
    std::vector<GCObject*> roots;  // Root set (stack, globals)
    
public:
    // Allocate new object
    GCObject* allocate() {
        GCObject* obj = new GCObject();
        heap.push_back(obj);
        return obj;
    }
    
    // Add to root set
    void addRoot(GCObject* obj) {
        roots.push_back(obj);
    }
    
    // Mark phase: mark all reachable objects
    void mark() {
        std::vector<GCObject*> worklist = roots;
        
        while (!worklist.empty()) {
            GCObject* obj = worklist.back();
            worklist.pop_back();
            
            if (!obj->marked) {
                obj->marked = true;
                // Add all references to worklist
                for (GCObject* ref : obj->references) {
                    if (!ref->marked) {
                        worklist.push_back(ref);
                    }
                }
            }
        }
    }
    
    // Sweep phase: free unmarked objects
    void sweep() {
        auto it = heap.begin();
        while (it != heap.end()) {
            GCObject* obj = *it;
            if (!obj->marked) {
                delete obj;
                it = heap.erase(it);
            } else {
                obj->marked = false;  // Reset for next collection
                ++it;
            }
        }
    }
    
    // Run garbage collection
    void collect() {
        mark();
        sweep();
    }
    
    ~SimpleGC() {
        for (GCObject* obj : heap) {
            delete obj;
        }
    }
};
\end{lstlisting}