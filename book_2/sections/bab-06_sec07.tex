\section{Integrasi Lexer dengan Parser}

\subsection{Arsitektur Integrasi}

Dalam implementasi praktis, lexer dan parser bekerja bersama dalam pipeline:

\begin{lstlisting}[language={},basicstyle=\ttfamily\footnotesize,breaklines=true,breakatwhitespace=false]
Source Code -> Lexer -> Token Stream -> Parser -> Parse Tree/AST
\end{lstlisting}

Lexer membaca source code karakter demi karakter dan menghasilkan stream token. Parser kemudian membaca token dari stream ini.

\subsection{Implementasi Terintegrasi}

Berikut adalah contoh implementasi lexer dan parser yang terintegrasi:

\begin{lstlisting}[language=C++, caption={Lexer dan parser terintegrasi}]
#include <iostream>
#include <string>
#include <cctype>

class IntegratedLexerParser {
private:
    std::string input;
    size_t pos;
    int line, col;
    Token lookahead;
    
    // Lexer functions
    void skipWhitespace() {
        while (pos < input.size() && isspace(input[pos])) {
            if (input[pos] == '\n') {
                line++;
                col = 1;
            } else {
                col++;
            }
            pos++;
        }
    }
    
    Token nextToken() {
        skipWhitespace();
        
        if (pos >= input.size()) {
            return {TOK_END, "", line, col};
        }
        
        char c = input[pos];
        int startCol = col;
        
        // Identifier: [a-zA-Z][a-zA-Z0-9]*
        if (isalpha(c)) {
            std::string lexeme;
            while (pos < input.size() && isalnum(input[pos])) {
                lexeme += input[pos++];
                col++;
            }
            return {TOK_ID, lexeme, line, startCol};
        }
        
        // Number: [0-9]+
        if (isdigit(c)) {
            std::string lexeme;
            while (pos < input.size() && isdigit(input[pos])) {
                lexeme += input[pos++];
                col++;
            }
            return {TOK_NUM, lexeme, line, startCol};
        }
        
        // Operators and punctuation
        pos++;
        col++;
        switch (c) {
            case '+': return {TOK_PLUS, "+", line, startCol};
            case '*': return {TOK_MUL, "*", line, startCol};
            case '(': return {TOK_LPAREN, "(", line, startCol};
            case ')': return {TOK_RPAREN, ")", line, startCol};
            default: return {TOK_ERROR, std::string(1, c), line, startCol};
        }
    }
    
    void match(TokenType expected) {
        if (lookahead.type == expected) {
            lookahead = nextToken();
        } else {
            std::cerr << "Error: Expected " << expected 
                      << " but got " << lookahead.lexeme 
                      << " at line " << lookahead.line 
                      << ", col " << lookahead.col << std::endl;
            exit(1);
        }
    }
    
public:
    IntegratedLexerParser(const std::string& s) 
        : input(s), pos(0), line(1), col(1) {
        lookahead = nextToken();
    }
    
    // Parser functions (same as before)
    void parseE() {
        parseT();
        parseEPrime();
    }
    
    void parseEPrime() {
        if (lookahead.type == TOK_PLUS) {
            match(TOK_PLUS);
            parseT();
            parseEPrime();
        }
    }
    
    void parseT() {
        parseF();
        parseTPrime();
    }
    
    void parseTPrime() {
        if (lookahead.type == TOK_MUL) {
            match(TOK_MUL);
            parseF();
            parseTPrime();
        }
    }
    
    void parseF() {
        if (lookahead.type == TOK_LPAREN) {
            match(TOK_LPAREN);
            parseE();
            match(TOK_RPAREN);
        } else if (lookahead.type == TOK_ID) {
            match(TOK_ID);
        } else if (lookahead.type == TOK_NUM) {
            match(TOK_NUM);
        } else {
            std::cerr << "Error: Expected id, num, or '('" << std::endl;
            exit(1);
        }
    }
    
    void parse() {
        parseE();
        if (lookahead.type != TOK_END) {
            std::cerr << "Error: Extra input" << std::endl;
            exit(1);
        }
        std::cout << "Parse successful!" << std::endl;
    }
};
\end{lstlisting}