\section{Code Generation ke Assembly}

Code generator adalah komponen yang mengubah AST menjadi assembly code. Untuk Windows, kita akan menghasilkan x86-64 assembly code yang menggunakan Windows API untuk output.

\subsection{Target Assembly}

Kita akan menghasilkan assembly code untuk Windows x86-64 yang menggunakan:
\begin{itemize}
    \item Windows API: \texttt{GetStdHandle}, \texttt{WriteFile}, \texttt{ExitProcess}
    \item Format: NASM syntax (Intel syntax)
    \item Calling convention: Windows x64 calling convention
\end{itemize}

\subsection{Struktur Code Generator}

\begin{lstlisting}[language=C, caption={Header file codegen.h}]
#ifndef CODEGEN_H
#define CODEGEN_H

#include "parser.h"
#include <stdio.h>

// Generate assembly code dari AST
void generateCode(ASTNode* ast, FILE* output);

#endif
\end{lstlisting}

\subsection{Implementasi Code Generator}

Berikut adalah implementasi code generator yang menghasilkan assembly code untuk Windows:

\begin{lstlisting}[language=C, caption={Implementasi codegen.c}]
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include "codegen.h"
#include "parser.h"

static void emit(FILE* out, const char* format, ...) {
    va_list args;
    va_start(args, format);
    vfprintf(out, format, args);
    va_end(args);
}

static void escapeString(const char* str, char* buffer, int bufferSize) {
    int j = 0;
    for (int i = 0; str[i] != '\0' && j < bufferSize - 1; i++) {
        if (str[i] == '\'') {
            buffer[j++] = '\'';
            buffer[j++] = '\'';
        } else if (str[i] == '\n') {
            buffer[j++] = '\\';
            buffer[j++] = 'n';
        } else if (str[i] == '\t') {
            buffer[j++] = '\\';
            buffer[j++] = 't';
        } else {
            buffer[j++] = str[i];
        }
    }
    buffer[j] = '\0';
}

void generateCode(ASTNode* ast, FILE* output) {
    if (ast == NULL) return;
    
    // Write data section
    emit(output, "section .data\n");
    emit(output, "    msg db '%s', 0\n", ast->data.print_stmt.string_value);
    emit(output, "    msg_len equ $ - msg - 1\n");
    emit(output, "\n");
    
    // Write text section
    emit(output, "section .text\n");
    emit(output, "    global _start\n");
    emit(output, "    extern ExitProcess\n");
    emit(output, "    extern GetStdHandle\n");
    emit(output, "    extern WriteFile\n");
    emit(output, "\n");
    
    // Write _start function
    emit(output, "_start:\n");
    emit(output, "    ; Get stdout handle\n");
    emit(output, "    mov rcx, -11        ; STD_OUTPUT_HANDLE\n");
    emit(output, "    sub rsp, 32         ; Shadow space\n");
    emit(output, "    call GetStdHandle\n");
    emit(output, "    add rsp, 32\n");
    emit(output, "    mov rbx, rax        ; Save handle in rbx\n");
    emit(output, "\n");
    
    emit(output, "    ; Write to stdout\n");
    emit(output, "    mov rcx, rbx        ; hFile (stdout handle)\n");
    emit(output, "    lea rdx, [msg]      ; lpBuffer (pointer to message)\n");
    emit(output, "    mov r8, msg_len     ; nNumberOfBytesToWrite\n");
    emit(output, "    lea r9, [rsp-8]     ; lpNumberOfBytesWritten (local var)\n");
    emit(output, "    mov qword [rsp-16], 0 ; lpOverlapped (NULL)\n");
    emit(output, "    sub rsp, 32         ; Shadow space\n");
    emit(output, "    call WriteFile\n");
    emit(output, "    add rsp, 32\n");
    emit(output, "\n");
    
    emit(output, "    ; Exit process\n");
    emit(output, "    mov rcx, 0          ; Exit code\n");
    emit(output, "    sub rsp, 32         ; Shadow space\n");
    emit(output, "    call ExitProcess\n");
    emit(output, "    add rsp, 32\n");
}
\end{lstlisting}

\subsection{Penjelasan Assembly Code}

Assembly code yang dihasilkan terdiri dari:

\subsubsection{Data Section}
\begin{verbatim}
section .data
    msg db 'hello world !!!', 0
    msg_len equ $ - msg - 1
\end{verbatim}
\begin{itemize}
    \item \texttt{section .data}: Section untuk data yang dapat diubah
    \item \texttt{msg db}: Define byte - menyimpan string literal
    \item \texttt{msg_len}: Panjang string (tanpa null terminator)
\end{itemize}

\subsubsection{Text Section}
\begin{verbatim}
section .text
    global _start
    extern ExitProcess
    extern GetStdHandle
    extern WriteFile
\end{verbatim}
\begin{itemize}
    \item \texttt{section .text}: Section untuk kode executable
    \item \texttt{global _start}: Entry point program
    \item \texttt{extern}: Deklarasi fungsi eksternal dari Windows API
\end{itemize}

\subsubsection{Main Function}
\begin{verbatim}
_start:
    ; Get stdout handle
    mov rcx, -11        ; STD_OUTPUT_HANDLE
    call GetStdHandle
    mov rbx, rax        ; Save handle
\end{verbatim}
\begin{itemize}
    \item \texttt{-11}: Konstanta \texttt{STD\_OUTPUT\_HANDLE} untuk stdout
    \item \texttt{GetStdHandle}: Windows API untuk mendapatkan handle ke stdout
    \item Handle disimpan di \texttt{rbx} untuk digunakan kemudian
\end{itemize}

\begin{verbatim}
    ; Write to stdout
    mov rcx, rbx        ; hFile
    lea rdx, [msg]      ; lpBuffer
    mov r8, msg_len     ; nNumberOfBytesToWrite
    lea r9, [rsp-8]     ; lpNumberOfBytesWritten
    mov qword [rsp-16], 0 ; lpOverlapped
    call WriteFile
\end{verbatim}
\begin{itemize}
    \item \texttt{WriteFile}: Windows API untuk menulis ke file/handle
    \item Parameter sesuai Windows x64 calling convention:
    \begin{itemize}
        \item \texttt{rcx}: Parameter pertama (handle)
        \item \texttt{rdx}: Parameter kedua (buffer)
        \item \texttt{r8}: Parameter ketiga (length)
        \item \texttt{r9}: Parameter keempat (bytes written)
        \item \texttt{[rsp-16]}: Parameter kelima di stack (overlapped)
    \end{itemize}
    \item Shadow space: 32 bytes yang harus disediakan sebelum call
\end{itemize}

\begin{verbatim}
    ; Exit process
    mov rcx, 0          ; Exit code
    call ExitProcess
\end{verbatim}
\begin{itemize}
    \item \texttt{ExitProcess}: Windows API untuk mengakhiri proses
    \item Exit code 0 berarti sukses
\end{itemize}

\subsection{Contoh Output Assembly}

Untuk program \texttt{print("hello world !!!");}, code generator akan menghasilkan:

\begin{verbatim}
section .data
    msg db 'hello world !!!', 0
    msg_len equ $ - msg - 1

section .text
    global _start
    extern ExitProcess
    extern GetStdHandle
    extern WriteFile

_start:
    ; Get stdout handle
    mov rcx, -11        ; STD_OUTPUT_HANDLE
    sub rsp, 32         ; Shadow space
    call GetStdHandle
    add rsp, 32
    mov rbx, rax        ; Save handle in rbx

    ; Write to stdout
    mov rcx, rbx        ; hFile (stdout handle)
    lea rdx, [msg]      ; lpBuffer (pointer to message)
    mov r8, msg_len     ; nNumberOfBytesToWrite
    lea r9, [rsp-8]     ; lpNumberOfBytesWritten (local var)
    mov qword [rsp-16], 0 ; lpOverlapped (NULL)
    sub rsp, 32         ; Shadow space
    call WriteFile
    add rsp, 32

    ; Exit process
    mov rcx, 0          ; Exit code
    sub rsp, 32         ; Shadow space
    call ExitProcess
    add rsp, 32
\end{verbatim}

\subsection{Windows x64 Calling Convention}

Penting untuk memahami Windows x64 calling convention:
\begin{itemize}
    \item \textbf{First 4 parameters}: \texttt{rcx}, \texttt{rdx}, \texttt{r8}, \texttt{r9} (untuk integer/pointer)
    \item \textbf{Additional parameters}: Di stack, dari kanan ke kiri
    \item \textbf{Shadow space}: 32 bytes harus dialokasikan sebelum call (bahkan jika tidak ada parameter di stack)
    \item \textbf{Return value}: \texttt{rax} untuk integer/pointer
    \item \textbf{Caller-saved registers}: \texttt{rax}, \texttt{rcx}, \texttt{rdx}, \texttt{r8}, \texttt{r9}, \texttt{r10}, \texttt{r11}
    \item \textbf{Callee-saved registers}: \texttt{rbx}, \texttt{rbp}, \texttt{rsi}, \texttt{rdi}, \texttt{r12-r15}
\end{itemize}

\subsection{Testing Code Generator}

Untuk menguji code generator:

\begin{lstlisting}[language=C, caption={test_codegen.c}]
#include "codegen.h"
#include "parser.h"
#include "lexer.h"
#include <stdio.h>

int main() {
    const char* source = "print(\"hello world !!!\");";
    
    initLexer(source);
    ASTNode* ast = parse();
    
    FILE* output = fopen("hello.asm", "w");
    if (output == NULL) {
        fprintf(stderr, "Cannot open output file\n");
        return 1;
    }
    
    generateCode(ast, output);
    fclose(output);
    
    printf("Assembly code generated: hello.asm\n");
    
    freeAST(ast);
    freeLexer();
    return 0;
}
\end{lstlisting}

Code generator sudah siap. File assembly yang dihasilkan akan di-assemble dan di-link pada tahap berikutnya.
