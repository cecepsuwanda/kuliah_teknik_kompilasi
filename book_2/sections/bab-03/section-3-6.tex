\section{Logika State Machine Token}

\subsection{Prinsip Maximal Munch (Longest Match)}
Dalam implementasi lexer, sering terjadi ambiguitas. Misalnya, input \texttt{>=} bisa dibaca sebagai \texttt{>} lalu \texttt{=}, atau sebagai satu token \texttt{>=}. Prinsip standar yang digunakan adalah \textbf{Maximal Munch}: \textit{selalu ambil token terpanjang yang mungkin}.
\begin{itemize}
    \item Jika input adalah \texttt{>=}, lexer akan melihat \texttt{>}. Jangan berhenti! Lihat karakter berikutnya \texttt{=}. Karena \texttt{>=} valid, ambil keduanya.
    \item Jika input adalah \texttt{>a}, lexer melihat \texttt{>}. Karakter berikutnya \texttt{a} tidak membentuk operator valid dengan \texttt{>}. Maka, kembalikan hanya \texttt{>} dan mundurkan kursor dari \texttt{a}.
\end{itemize}

\subsection{Prinsip Prioritas: Keyword vs Identifier}
Pola \texttt{if} cocok dengan aturan \textit{Keyword IF}, tapi juga cocok dengan pola \textit{Identifier}. Bagaimana membedakannya?
\begin{enumerate}
    \item \textbf{Rule Order}: Dalam alat seperti Flex, aturan yang ditulis lebih awal menang. Tulis aturan \texttt{if} sebelum aturan Identifier.
    \item \textbf{Lookup Table}: Dalam lexer manual, kita biasanya menganggap semuanya sebagai Identifier dulu. Setelah lexeme terkumpul ("if"), kita cek ke dalam tabel hash berisi daftar kata kunci. Jika ada, ubah tipe tokennya menjadi \texttt{KW\_IF}. Ini lebih efisien daripada membuat state machine DFA yang sangat kompleks untuk setiap kata kunci.
\end{enumerate}

\begin{figure}[!htbp]
    \centering
    \adjustbox{max width=0.8\textwidth,center}{%
    \begin{tikzpicture}[
        state/.style={circle, draw=blue!50, fill=blue!10, minimum size=0.8cm, font=\tiny, align=center},
        start/.style={circle, draw=red!50, fill=red!10, minimum size=0.8cm, font=\tiny, align=center},
        accept/.style={circle, draw=green!50, fill=green!10, minimum size=0.8cm, font=\tiny, double},
        arrow/.style={->, >=stealth, thick}
    ]
    \node[start] (q0) {START};
    \node[state, right=2cm of q0] (q1) {IN\_ID};
    \node[accept, right=2cm of q1] (q2) {DONE};
    \draw[arrow] (q0) -- node[above, font=\tiny] {letter/\_} (q1);
    \draw[arrow] (q1) to[loop above] node[above, font=\tiny] {alnum/\_} (q1);
    \draw[arrow] (q1) -- node[above, font=\tiny] {other} (q2);
    \node[below=0.5cm of q1, font=\itshape\footnotesize] {Setelah DONE, cek HashMap Keywords};
    \end{tikzpicture}%
    }
    \caption{State machine generik untuk Identifier/Keyword}
\end{figure}

\subsection{State Machine untuk Angka}
Menangani angka juga membutuhkan logika \textit{lookahead}. Saat melihat titik (\texttt{.}), lexer harus memastikan karakter selanjutnya adalah digit sebelum memutuskannya sebagai \texttt{FLOAT\_LITERAL}. Jika tidak (misal \texttt{1..10} di Pascal), titik tersebut mungkin token terpisah (\textit{range operator}).

\begin{lstlisting}[language=C++]
Token Lexer::scanNumber() {
    std::string text;
    while (isdigit(peek())) text += advance();
    
    if (peek() == '.' && isdigit(peekNext())) { // Lookahead 2 langkah
        text += advance(); // makan titik
        while (isdigit(peek())) text += advance();
        return Token(FLOAT, text);
    }
    return Token(INT, text);
}
\end{lstlisting}
