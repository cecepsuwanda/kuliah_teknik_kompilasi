\section{LR Parsers}

\subsection{Definisi LR Parser}

LR parser adalah kelas bottom-up parser yang membaca input dari \textbf{L}eft ke right dan menghasilkan \textbf{R}ightmost derivation dalam reverse. Notasi LR(k) menunjukkan bahwa parser menggunakan k token lookahead.

Menurut GeeksforGeeks:

\begin{quote}
``LR parsers read input Left-to-right and produce a Rightmost derivation in reverse. They use a parsing table to decide when to shift and when to reduce.''\footnote{\url{https://www.geeksforgeeks.org/bottom-up-or-shift-reduce-parsers-set-2/}}
\end{quote}

LR parser menggunakan dua tabel utama:
\begin{itemize}
    \item \textbf{Action Table}: Menentukan aksi (shift, reduce, accept, error) berdasarkan state saat ini dan lookahead token
    \item \textbf{GOTO Table}: Menentukan state berikutnya setelah reduce berdasarkan state saat ini dan non-terminal yang dihasilkan
\end{itemize}

\subsection{Jenis-jenis LR Parser}

Terdapat beberapa varian LR parser, masing-masing dengan karakteristik berbeda:

\subsubsection{LR(0)}

LR(0) adalah varian paling sederhana yang tidak menggunakan lookahead. Karakteristik:
\begin{itemize}
    \item Tidak memerlukan lookahead token
    \item Tabel parsing kecil
    \item Sangat terbatas dalam kemampuan parsing (banyak grammar menghasilkan conflict)
    \item Jarang digunakan dalam praktik
\end{itemize}

\subsubsection{SLR(1) - Simple LR}

SLR(1) menggunakan 1 token lookahead dan Follow sets untuk menentukan kapan melakukan reduce. Karakteristik:
\begin{itemize}
    \item Menggunakan LR(0) item sets
    \item Reduce hanya dilakukan jika lookahead token berada dalam Follow set dari non-terminal yang di-reduce
    \item Lebih powerful daripada LR(0)
    \item Tabel lebih kecil daripada CLR(1)
    \item Masih dapat menghasilkan conflict untuk beberapa grammar
\end{itemize}

Menurut GeeksforGeeks:

\begin{quote}
``SLR(1) uses LR(0) item sets, and reduction is allowed on lookahead symbols in Follow(A) for production A -> $\alpha$ when the item [A -> $\alpha$ â€¢] appears in the state. This can lead to conflicts CLR(1) avoids.''\footnote{\url{https://www.geeksforgeeks.org/bottom-up-or-shift-reduce-parsers-set-2/}}
\end{quote}

\subsubsection{CLR(1) - Canonical LR}

CLR(1) adalah varian paling powerful yang menggunakan full LR(1) items dengan lookahead spesifik. Karakteristik:
\begin{itemize}
    \item Menggunakan LR(1) items (production dengan lookahead spesifik)
    \item Reduce hanya dilakukan pada lookahead token yang spesifik
    \item Dapat menangani lebih banyak grammar daripada SLR(1)
    \item Tabel parsing sangat besar (banyak states)
    \item Lebih lambat dalam konstruksi tabel
\end{itemize}

\subsubsection{LALR(1) - Look-Ahead LR}

LALR(1) adalah kompromi praktis antara SLR(1) dan CLR(1). Karakteristik:
\begin{itemize}
    \item Merge states dari CLR(1) yang memiliki LR(0) core yang sama
    \item Menggabungkan lookahead sets dari states yang di-merge
    \item Jumlah states sama atau mendekati SLR(1)
    \item Lebih powerful daripada SLR(1), hampir sekuat CLR(1)
    \item Digunakan oleh Yacc dan Bison (parser generator populer)
\end{itemize}

Menurut GeeksforGeeks:

\begin{quote}
``LALR(1) merges states in the CLR(1) automaton that have identical LR(0) cores (i.e. same productions \& dot positions), combining their lookahead sets. Then construct table using merged states. This reduces size while often preserving correctness.''\footnote{\url{https://www.geeksforgeeks.org/compiler-design/lalr-parser-with-examples/}}
\end{quote}

Gambar \ref{fig:lr-variants-comparison} menunjukkan perbandingan visual varian LR parser.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.9\textwidth,center}{%
    \begin{tikzpicture}[
        variant/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.5cm, text centered, minimum height=0.6cm, rounded corners, font=\footnotesize, inner sep=4pt, align=center},
        power/.style={rectangle, draw=green!50, fill=green!10, minimum width=0.5cm, minimum height=0.5cm, font=\tiny, align=center},
        size/.style={rectangle, draw=orange!50, fill=orange!10, minimum width=0.5cm, minimum height=0.5cm, font=\tiny, align=center},
        node distance=0.4cm and 0.2cm
    ]
    
    \node[variant] (lr0) {LR(0)};
    \node[power, right=of lr0, minimum width=0.8cm] (p1) {Weak};
    \node[size, right=of p1, minimum width=1.2cm] {Small};
    
    \node[variant, below=of lr0] (slr) {SLR(1)};
    \node[power, right=of slr, minimum width=1.2cm] (p2) {Moderate};
    \node[size, right=of p2, minimum width=1.2cm] {Small};
    
    \node[variant, below=of slr] (lalr) {LALR(1)};
    \node[power, right=of lalr, minimum width=1.5cm] (p3) {Strong};
    \node[size, right=of p3, minimum width=1.5cm] {Medium};
    
    \node[variant, below=of lalr] (clr) {CLR(1)};
    \node[power, right=of clr, minimum width=1.8cm] (p4) {Strongest};
    \node[size, right=of p4, minimum width=2cm] {Large};
    
    \end{tikzpicture}%
    }
    \caption{Perbandingan varian LR parser: power vs table size}
    \label{fig:lr-variants-comparison}
\end{figure}

\subsection{Perbandingan LR Parser Variants}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Variant} & \textbf{Lookahead} & \textbf{Table Size} & \textbf{Parsing Power} \\
\hline
LR(0) & None & Smallest & Weakest \\
\hline
SLR(1) & 1 token (Follow sets) & Small & Moderate \\
\hline
LALR(1) & 1 token (merged) & Small-Medium & Strong \\
\hline
CLR(1) & 1 token (full) & Largest & Strongest \\
\hline
\end{tabular}
\caption{Perbandingan varian LR parser}
\label{tab:lr-variants}
\end{table}