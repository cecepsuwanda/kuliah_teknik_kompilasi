\section{Soal}

\subsection{Latihan Bab 1: Pengenalan Kompilator dan Fase-Fase Kompilasi}

\begin{enumerate}
    \item Jelaskan perbedaan antara kompilator dan interpreter. Berikan contoh bahasa pemrograman yang menggunakan masing-masing pendekatan.
    
    \item Buatlah diagram yang menunjukkan alur kerja kompilator dari source code C sampai menjadi executable. Sertakan semua fase yang telah dipelajari.
    
    \item Identifikasi fase kompilasi yang bertanggung jawab untuk:
    \begin{itemize}
        \item Menghapus whitespace dan comments
        \item Memeriksa apakah variabel dideklarasi sebelum digunakan
        \item Mengoptimasi kode dengan menghilangkan kode yang tidak pernah dieksekusi
        \item Mengkonversi ekspresi \texttt{a + b * c} menjadi three-address code
    \end{itemize}
    
    \item Jelaskan mengapa kompilator modern menggunakan pendekatan multi-pass. Apa keuntungannya dibanding single-pass?
    
    \item Carilah informasi tentang satu kompilator open source (misalnya GCC, Clang, atau TinyCC) dan identifikasi:
    \begin{itemize}
        \item Bahasa sumber dan target yang didukung
        \item Tools yang digunakan untuk lexical dan syntax analysis
        \item Format intermediate representation yang digunakan
    \end{itemize}
\end{enumerate}

\subsection{Latihan Bab 2: Regular Expression dan Finite Automata}

\begin{enumerate}
    \item Buatlah regular expression untuk:
    \begin{itemize}
        \item Email address sederhana (format: \texttt{user@domain.com})
        \item Phone number (format: \texttt{+62-812-3456-7890})
        \item C-style comment (\texttt{/* ... */})
    \end{itemize}
    
    \item Konstruksi NFA untuk regular expression berikut menggunakan algoritma Thompson:
    \begin{itemize}
        \item \texttt{a*b+}
        \item \texttt{(a|b)*ab}
        \item \texttt{[0-9]+(\textbackslash.[0-9]+)?}
    \end{itemize}
    
    \item Konversi NFA dari soal nomor 2 menjadi DFA menggunakan subset construction. Gambarkan state diagram untuk DFA yang dihasilkan.
    
    \item Implementasikan kelas \texttt{NFA} dan \texttt{DFA} dalam C++ dengan fungsi:
    \begin{itemize}
        \item Konstruksi NFA dari regular expression (sederhana)
        \item Konversi NFA ke DFA
        \item Simulasi DFA untuk string input
    \end{itemize}
    
    \item Buat program recognizer yang dapat mengenali token-token berikut:
    \begin{itemize}
        \item Identifier: \texttt{[a-zA-Z\_][a-zA-Z0-9\_]*}
        \item Integer: \texttt{[0-9]+}
        \item Float: \texttt{[0-9]+\textbackslash.[0-9]+}
        \item Operator: \texttt{+|-|*|/|=|==|!=}
    \end{itemize}
    
    \item Jelaskan mengapa DFA lebih efisien untuk simulasi dibanding NFA. Berikan contoh kompleksitas waktu untuk keduanya.
    
    \item Implementasikan algoritma minimisasi DFA (dapat menggunakan versi sederhana). Uji dengan DFA yang dihasilkan dari soal nomor 3.
\end{enumerate}

\subsection{Latihan Bab 3: Implementasi Lexer}

\begin{enumerate}
    \item \textbf{Implementasi Dasar}: Implementasikan lexer sederhana yang dapat mengenali:
    \begin{itemize}
        \item Identifier (huruf, angka, underscore)
        \item Integer literals
        \item Operator dasar: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{=}
        \item Punctuation: \texttt{;}, \texttt{,}, \texttt{(}, \texttt{)}
    \end{itemize}
    
    \item \textbf{Handling Comments}: Tambahkan support untuk:
    \begin{itemize}
        \item Single-line comments (\texttt{//})
        \item Multi-line comments (\texttt{/* */})
        \item Error handling untuk unclosed block comments
    \end{itemize}
    
    \item \textbf{String Literals}: Implementasikan scanning untuk string literals dengan:
    \begin{itemize}
        \item Support escape sequences: \texttt{\textbackslash n}, \texttt{\textbackslash t}, \texttt{\textbackslash "}, \texttt{\textbackslash\textbackslash}
        \item Error handling untuk unclosed strings
    \end{itemize}
    
    \item \textbf{Float Literals}: Extend number scanning untuk mendukung:
    \begin{itemize}
        \item Float dengan decimal point: \texttt{3.14}
        \item Scientific notation: \texttt{1.5e10}, \texttt{2.3E-5}
    \end{itemize}
    
    \item \textbf{Unit Testing}: Buat test suite yang mencakup:
    \begin{itemize}
        \item Valid tokens dari semua kategori
        \item Edge cases (unclosed strings, invalid characters, dll.)
        \item Position tracking (line dan column)
    \end{itemize}
    
    \item \textbf{Error Recovery}: Implementasikan error recovery strategy:
    \begin{itemize}
        \item Skip invalid characters dan lanjut scanning
        \item Report multiple errors dalam satu pass jika memungkinkan
    \end{itemize}
    
    \item \textbf{Performance}: Analisis dan optimasi:
    \begin{itemize}
        \item Bandingkan performa dengan lexer generator (jika tersedia)
        \item Identifikasi bottleneck dalam implementasi
    \end{itemize}
\end{enumerate}

\subsection{Latihan Bab 4: Lexer Generator}

\begin{enumerate}
    \item Buatlah specification file Flex untuk mengenali token-token berikut:
    \begin{itemize}
        \item Keywords: \texttt{for}, \texttt{break}, \texttt{continue}
        \item String literals (dengan escape sequences: \texttt{\textbackslash n}, \texttt{\textbackslash t}, \texttt{\textbackslash "})
        \item Character literals (dalam single quotes)
        \item Operators: \texttt{++}, \texttt{--}, \texttt{+=}, \texttt{-=}
    \end{itemize}
    
    \item Implementasikan lexer menggunakan re2c untuk bahasa yang sama seperti soal 1. Bandingkan kompleksitas specification antara Flex dan re2c.
    
    \item Jelaskan kapan sebaiknya menggunakan hand-written lexer dan kapan menggunakan generator. Berikan contoh kasus untuk masing-masing.
    
    \item Buatlah program yang mengintegrasikan Flex lexer dengan Bison parser sederhana untuk:
    \begin{itemize}
        \item Parsing ekspresi aritmatika: \texttt{a + b * c}
        \item Parsing assignment: \texttt{x = 42;}
        \item Parsing conditional: \texttt{if (x > 0) \{ ... \}}
    \end{itemize}
    
    \item Analisis performa: Buat benchmark untuk membandingkan:
    \begin{itemize}
        \item Hand-written lexer (dari Bab 3)
        \item Flex-generated lexer
        \item re2c-generated lexer
    \end{itemize}
    Gunakan input file yang besar (misalnya 10MB) dan ukur waktu eksekusi.
    
    \item Jelaskan bagaimana Flex menangani longest match dan rule priority. Berikan contoh yang menunjukkan perbedaan hasil ketika urutan rule diubah.
\end{enumerate}

\subsection{Latihan Bab 5: Context-Free Grammar dan Parsing}

\begin{enumerate}
    \item Tuliskan grammar dalam BNF untuk:
    \begin{itemize}
        \item Ekspresi boolean dengan operator AND, OR, NOT
        \item Assignment statement: \texttt{variable = expression;}
        \item For loop: \texttt{for (init; condition; update) statement}
    \end{itemize}
    
    \item Konversi grammar berikut ke EBNF:
    \begin{verbatim}
    <list> ::= <item> | <list> , <item>
    <item> ::= <number> | <string>
    \end{verbatim}
    
    \item Buatlah leftmost dan rightmost derivation untuk ekspresi \texttt{(2 + 3) * 4} menggunakan grammar ekspresi aritmatika yang telah dipelajari.
    
    \item Gambarkan parse tree untuk ekspresi berikut menggunakan grammar yang sesuai:
    \begin{itemize}
        \item \texttt{1 + 2 * 3}
        \item \texttt{10 / 2 - 3}
        \item \texttt{(5 + 3) * 2}
    \end{itemize}
    
    \item Identifikasi apakah grammar berikut ambiguous. Jika ya, berikan contoh string yang dapat di-parse dengan lebih dari satu cara:
    \begin{verbatim}
    S → a S a | b S b | a | b | epsilon
    \end{verbatim}
    
    \item Eliminasi left recursion dari grammar berikut:
    \begin{verbatim}
    A → A + B | A - B | B
    B → B * C | B / C | C
    C → ( A ) | number
    \end{verbatim}
    
    \item Lakukan left factoring pada grammar berikut:
    \begin{verbatim}
    S → if E then S else S
      | if E then S
      | while E do S
      | id = E
    \end{verbatim}
    
    \item Rancang grammar untuk bahasa sederhana yang mendukung:
    \begin{itemize}
        \item Variable declarations: \texttt{int x;}
        \item Assignments: \texttt{x = 5;}
        \item If-else statements
        \item While loops
        \item Arithmetic expressions
    \end{itemize}
    Tulis grammar dalam EBNF dan berikan contoh program valid.
\end{enumerate}

\subsection{Latihan Bab 6: Top-Down Parsing dan Recursive Descent}

\begin{enumerate}
    \item Implementasikan recursive descent parser untuk grammar berikut:
    \begin{verbatim}
    S -> if E then S else S | id := E | while E do S
    E -> E + T | T
    T -> T * F | F
    F -> ( E ) | id | num
    \end{verbatim}
    
    \textbf{Perhatikan:} Grammar ini memiliki left recursion. Anda perlu mengeliminasi left recursion terlebih dahulu.
    
    \item Modifikasi parser ekspresi aritmatika untuk menambahkan operator unary minus (misalnya \texttt{-5} atau \texttt{-(3 + 4)}).
    
    \item Implementasikan error recovery pada parser yang telah Anda buat. Test dengan input yang mengandung multiple errors.
    
    \item Buatlah parser yang dapat mengevaluasi ekspresi boolean dengan operator \texttt{AND}, \texttt{OR}, dan \texttt{NOT}. Perhatikan precedence: \texttt{NOT} > \texttt{AND} > \texttt{OR}.
    
    \item Bandingkan recursive descent parser dengan table-driven LL parser. Apa keuntungan dan kerugian masing-masing pendekatan?
    
    \item Implementasikan parser untuk ekspresi dengan right-associative operator (misalnya operator assignment \texttt{=}).
\end{enumerate}

\subsection{Latihan Bab 7: Bottom-Up Parsing dan Parser Generator}

\begin{enumerate}
    \item Jelaskan perbedaan antara top-down dan bottom-up parsing. Berikan contoh situasi di mana masing-masing lebih cocok digunakan.
    
    \item Untuk grammar berikut:
    \begin{verbatim}
    E -> E + T | T
    T -> T * F | F
    F -> ( E ) | id
    \end{verbatim}
    Lakukan shift-reduce parsing manual untuk input \texttt{id + id * id}. Tunjukkan stack, input, dan action pada setiap langkah.
    
    \item Jelaskan perbedaan antara SLR(1), CLR(1), dan LALR(1). Mengapa LALR(1) menjadi pilihan populer untuk parser generator?
    
    \item Buatlah file Bison sederhana untuk grammar ekspresi aritmatika dengan:
    \begin{itemize}
        \item Operator +, -, *, / dengan precedence yang benar
        \item Parentheses untuk grouping
        \item Semantic actions yang mencetak ekspresi yang di-parse
    \end{itemize}
    
    \item Integrasikan Flex lexer dengan Bison parser untuk membuat calculator sederhana yang dapat mengevaluasi ekspresi aritmatika.
    
    \item Implementasikan error recovery dalam Bison untuk menangani syntax error dengan baik. Test dengan input yang mengandung error.
    
    \item Bandingkan performa dan kompleksitas implementasi antara recursive descent parser (top-down) dan parser yang di-generate oleh Bison (bottom-up) untuk grammar yang sama.
\end{enumerate}

\subsection{Latihan Bab 8: Semantic Actions dan AST Construction}

\begin{enumerate}
    \item Buatlah parser untuk ekspresi boolean yang mendukung:
    \begin{itemize}
        \item Operasi AND (\texttt{\&\&}), OR (\texttt{||}), NOT (\texttt{!})
        \item Perbandingan (\texttt{<}, \texttt{>}, \texttt{==}, \texttt{!=})
        \item Precedence yang benar
    \end{itemize}
    
    \item Modifikasi calculator untuk mendukung:
    \begin{itemize}
        \item Variabel (assignment dan penggunaan)
        \item Fungsi matematika dasar (sin, cos, sqrt)
        \item Error handling yang lebih baik
    \end{itemize}
    
    \item Buatlah parser untuk konfigurasi file sederhana dengan format:
    \begin{verbatim}
    key1 = value1
    key2 = value2
    section {
        key3 = value3
    }
    \end{verbatim}
    
    \item Implementasikan semantic actions untuk membangun AST lengkap dari subset C, kemudian buat fungsi untuk:
    \begin{itemize}
        \item Print AST dalam format tree
        \item Evaluate AST (jika semua nilai diketahui)
        \item Optimize AST (constant folding)
    \end{itemize}
    
    \item Pelajari dokumentasi Bison dan jelaskan perbedaan antara:
    \begin{itemize}
        \item LALR(1) parsing (default Bison)
        \item GLR parsing
        \item Kapan masing-masing digunakan?
    \end{itemize}
\end{enumerate}

\subsection{Latihan Bab 9: Abstract Syntax Tree (AST)}

\begin{enumerate}
    \item Buatlah AST untuk program berikut:
    \begin{verbatim}
    int x = 10;
    int y = 20;
    int z = x + y * 2;
    \end{verbatim}
    Gambarkan struktur AST-nya.
    
    \item Implementasikan AST node untuk:
    \begin{itemize}
        \item For loop statement
        \item Array access expression
        \item String literal
        \item Boolean literal
    \end{itemize}
    
    \item Buatlah visitor yang menghitung jumlah node dalam AST.
    
    \item Buatlah visitor yang melakukan constant folding sederhana (misalnya: \texttt{3 + 5} → \texttt{8}).
    
    \item Modifikasi PrettyPrinter untuk menghasilkan output yang lebih mirip dengan source code asli.
    
    \item Implementasikan AST visualizer yang menghasilkan output dalam format Graphviz DOT untuk visualisasi grafis.
    
    \item Jelaskan mengapa AST lebih disukai daripada parse tree untuk fase-fase selanjutnya dalam kompilator.
    
    \item Buatlah contoh program yang menunjukkan perbedaan antara pre-order, post-order, dan in-order traversal pada AST ekspresi \texttt{(a + b) * (c - d)}.
\end{enumerate}

\subsection{Latihan Bab 10: Symbol Table dan Scope Management}

\begin{enumerate}
    \item Implementasikan symbol table lengkap dengan fitur-fitur berikut:
    \begin{itemize}
        \item Insert, lookup, delete operations
        \item Nested scopes support
        \item Shadowing detection dengan warning
        \item Visualisasi symbol table
    \end{itemize}
    
    \item Buatlah test cases untuk berbagai skenario:
    \begin{itemize}
        \item Nested scopes dengan shadowing
        \item Duplicate declaration dalam scope yang sama
        \item Undeclared identifier usage
        \item Function parameters dalam function scope
    \end{itemize}
    
    \item Analisis program berikut dan buat visualisasi symbol table-nya:
    \begin{lstlisting}[language=C++]
    int a = 1;
    int b = 2;
    
    void func1(int x) {
        int a = 10;
        int c = 20;
        
        {
            int b = 30;
            int d = 40;
        }
    }
    
    void func2() {
        int x = 100;
        int y = 200;
    }
    \end{lstlisting}
    
    \item Implementasikan fitur tambahan:
    \begin{itemize}
        \item Tracking semua usages dari setiap identifier (bukan hanya deklarasi)
        \item Support untuk forward declaration
        \item Scope numbering untuk debugging
    \end{itemize}
    
    \item Bandingkan implementasi symbol table menggunakan:
    \begin{itemize}
        \item Stack of hash tables (seperti yang dibahas)
        \item Single hash table dengan per-name stacks
    \end{itemize}
    Apa kelebihan dan kekurangan masing-masing pendekatan?
\end{enumerate}

\subsection{Latihan Bab 11: Type Checking dan Semantic Analysis}

\begin{enumerate}
    \item Jelaskan perbedaan antara static type checking dan dynamic type checking. Berikan contoh bahasa pemrograman untuk masing-masing.
    
    \item Implementasikan type checker sederhana untuk ekspresi aritmatika dengan mendukung:
    \begin{itemize}
        \item Operasi +, -, *, / untuk int dan float
        \item Operasi perbandingan ==, !=, <, > yang menghasilkan boolean
        \item Type promotion (int → float)
    \end{itemize}
    
    \item Buatlah fungsi untuk mengecek type compatibility dengan aturan:
    \begin{itemize}
        \item Exact match selalu kompatibel
        \item int dapat di-assign ke float (implicit conversion)
        \item float tidak dapat di-assign ke int tanpa explicit cast
    \end{itemize}
    
    \item Implementasikan semantic error detection untuk:
    \begin{itemize}
        \item Undeclared variable
        \item Type mismatch pada assignment
        \item Wrong number of arguments pada function call
    \end{itemize}
    
    \item Buatlah test cases untuk type checker yang mencakup:
    \begin{itemize}
        \item Valid expressions (harus pass type checking)
        \item Invalid expressions (harus menghasilkan error yang sesuai)
        \item Edge cases (null, empty, boundary values)
    \end{itemize}
    
    \item Jelaskan mengapa annotated AST diperlukan. Bagaimana informasi tipe pada AST digunakan pada fase code generation?
    
    \item Implementasikan type checking untuk if statement dan while loop. Pastikan kondisi harus bertipe boolean.
    
    \item Bandingkan nominal typing dan structural typing. Berikan contoh situasi di mana masing-masing pendekatan lebih menguntungkan.
\end{enumerate}

\subsection{Latihan Bab 12: Intermediate Code Generation}

\begin{enumerate}
    \item Buatlah TAC untuk ekspresi berikut:
    \begin{itemize}
        \item \texttt{a = b + c * d - e}
        \item \texttt{x = (a + b) * (c - d)}
        \item \texttt{y = -a + b * -c}
    \end{itemize}
    
    \item Implementasikan generator TAC untuk:
    \begin{itemize}
        \item Unary operations (negation, logical NOT)
        \item Array access (\texttt{array[index]})
        \item Member access (\texttt{object.member})
    \end{itemize}
    
    \item Buatlah TAC untuk program berikut:
    \begin{verbatim}
    int i, sum;
    sum = 0;
    for (i = 1; i <= 10; i = i + 1) {
        sum = sum + i;
    }
    \end{verbatim}
    
    \item Implementasikan common subexpression elimination untuk basic block. Test dengan contoh:
    \begin{verbatim}
    x = a + b * c
    y = a + b * c
    z = (a + b) * c
    w = (a + b) * c
    \end{verbatim}
    
    \item Jelaskan perbedaan antara three-address code dan quadruples. Kapan quadruples lebih menguntungkan?
    
    \item Buatlah generator TAC untuk switch statement. Bagaimana cara menangani multiple cases?
    
    \item Implementasikan optimasi constant folding pada TAC generator. Contoh: \texttt{x = 3 + 5} langsung menjadi \texttt{x = 8}
    
    \item Bandingkan pendekatan top-down (generate sambil traverse) dan bottom-up (build IR structure dulu) untuk TAC generation. Apa keuntungan masing-masing?
\end{enumerate}

\subsection{Latihan Bab 13: Runtime Environment dan Memory Management}

\begin{enumerate}
    \item Jelaskan perbedaan antara static, stack, dan heap allocation. Berikan contoh penggunaan masing-masing.
    
    \item Buatlah diagram activation records untuk program berikut saat \texttt{factorial(3)} sedang dieksekusi:
    \begin{lstlisting}[language=C++]
    int factorial(int n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    }
    
    int main() {
        int result = factorial(3);
        return 0;
    }
    \end{lstlisting}
    
    \item Implementasikan runtime stack simulator yang dapat menangani:
    \begin{itemize}
        \item Function calls dengan parameters
        \item Local variables
        \item Return values
        \item Nested function calls
    \end{itemize}
    
    \item Jelaskan calling sequence untuk fungsi dengan 3 parameters. Sertakan assembly code (simplified).
    
    \item Bandingkan manual memory management dengan garbage collection. Apa keuntungan dan kekurangan masing-masing?
    
    \item Implementasikan mark-and-sweep garbage collector sederhana yang dapat:
    \begin{itemize}
        \item Mark reachable objects dari root set
        \item Sweep dan free unreachable objects
        \item Handle cyclic references
    \end{itemize}
    
    \item Analisis memory layout untuk program berikut dan identifikasi di mana setiap variabel dialokasikan:
    \begin{lstlisting}[language=C++]
    int global;
    static int static_var;
    
    void func() {
        int local;
        static int static_local;
        int* ptr = new int;
        // ...
    }
    \end{lstlisting}
    
    \item Jelaskan apa yang terjadi pada stack saat terjadi recursive call yang sangat dalam (misalnya 1000 level). Apa masalah yang mungkin terjadi?
\end{enumerate}

\subsection{Latihan Bab 14: Code Generation}

\begin{enumerate}
    \item Implementasikan code generator sederhana untuk operasi aritmatika dasar (+, -, *, /) yang menghasilkan RISC-V assembly.
    
    \item Buatlah code generator untuk assignment statement. Test dengan berbagai skenario:
    \begin{itemize}
        \item Assignment dari constant ke variabel
        \item Assignment dari variabel ke variabel
        \item Assignment dari ekspresi ke variabel
    \end{itemize}
    
    \item Implementasikan local register allocation dengan algoritma sederhana. Test dengan basic block yang memiliki lebih banyak variabel aktif daripada jumlah register yang tersedia.
    
    \item Buatlah code generator untuk function call sederhana dengan 2-3 parameter. Implementasikan calling convention RISC-V.
    
    \item Test workflow lengkap: compile → assemble → link → run untuk program sederhana yang menghitung \texttt{a * b + c}.
    
    \item Bandingkan code yang dihasilkan untuk ekspresi \texttt{a + b * c} dengan dan tanpa optimasi register allocation. Hitung jumlah instruksi dan memory access.
    
    \item Implementasikan code generator untuk conditional statement (if-else) dengan branch instructions.
    
    \item Buatlah code generator untuk loop (for/while) dengan label dan jump instructions.
\end{enumerate}

\subsection{Latihan Bab 15: Optimasi Kompilator}

\begin{enumerate}
    \item Identifikasi basic blocks dari kode three-address berikut:
    \begin{verbatim}
    t1 = a + b
    t2 = c * d
    if t1 > t2 goto L1
    t3 = t1 - t2
    goto L2
    L1: t4 = t1 * t2
    L2: t5 = t3 + t4
    return t5
    \end{verbatim}
    
    \item Lakukan constant folding pada kode berikut:
    \begin{verbatim}
    t1 = 5 + 3
    t2 = t1 * 2
    t3 = 10 / 2
    x = t2 + t3
    \end{verbatim}
    
    \item Lakukan constant propagation dan folding pada kode berikut:
    \begin{verbatim}
    x = 10
    y = 20
    t1 = x + 5
    t2 = y * 2
    z = t1 + t2
    \end{verbatim}
    
    \item Identifikasi dan hapus dead code dari kode berikut:
    \begin{verbatim}
    x = 10
    y = 20
    t1 = x + y
    t2 = 5 + 3      // Dead
    t3 = t2 - 2     // Dead
    z = t1 * 2
    return z
    \end{verbatim}
    
    \item Implementasikan optimizer sederhana yang melakukan:
    \begin{itemize}
        \item Constant folding
        \item Constant propagation (local)
        \item Dead code elimination (basic)
    \end{itemize}
    Uji dengan beberapa contoh program dan evaluasi hasilnya.
    
    \item Jelaskan perbedaan antara:
    \begin{itemize}
        \item Local optimization vs global optimization
        \item Machine-independent vs machine-specific optimization
        \item Constant folding vs constant propagation
    \end{itemize}
    
    \item Buatlah benchmark untuk mengevaluasi efektivitas optimasi. Bandingkan:
    \begin{itemize}
        \item Ukuran kode sebelum dan sesudah optimasi
        \item Waktu eksekusi sebelum dan sesudah optimasi
        \item Waktu kompilasi sebelum dan sesudah optimasi
    \end{itemize}
\end{enumerate}

\subsection{Latihan Bab 16: Evaluasi dan Project Final}

\begin{enumerate}
    \item \textbf{Prepare Presentation}:
    \begin{itemize}
        \item Buat outline presentasi untuk project final Anda
        \item Siapkan demo script dengan minimal 5 test cases
        \item Latih presentasi untuk memastikan sesuai waktu
    \end{itemize}
    
    \item \textbf{Tool Evaluation}:
    \begin{itemize}
        \item Buat tabel perbandingan hand-written vs generator tools yang Anda gunakan
        \item Identifikasi trade-off yang Anda hadapi
        \item Justifikasi pilihan tools yang Anda buat
    \end{itemize}
    
    \item \textbf{Benchmarking}:
    \begin{itemize}
        \item Siapkan test suite dengan berbagai ukuran program
        \item Ukur metrik: compilation time, code size, execution time
        \item Buat laporan benchmark dengan tabel dan analisis
    \end{itemize}
    
    \item \textbf{Documentation}:
    \begin{itemize}
        \item Tulis README.md yang komprehensif
        \item Buat design document
        \item Dokumentasikan API jika ada
    \end{itemize}
    
    \item \textbf{Reflection}:
    \begin{itemize}
        \item Tulis refleksi pembelajaran (minimal 500 kata)
        \item Identifikasi 3 challenges utama yang dihadapi
        \item Rangkum 5 lessons learned yang paling penting
        \item Identifikasi 3 area untuk improvement
    \end{itemize}
    
    \item \textbf{Peer Review}:
    \begin{itemize}
        \item Review project final dari teman sekelas
        \item Berikan feedback konstruktif
        \item Bandingkan pendekatan yang berbeda
    \end{itemize}
\end{enumerate}