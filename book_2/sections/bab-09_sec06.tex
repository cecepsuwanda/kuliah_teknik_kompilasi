\section{Tree Traversal Methods}

Ada tiga metode utama untuk traversing tree: pre-order, post-order, dan in-order.

\subsection{Pre-Order Traversal}

Pre-order traversal mengunjungi node sebelum children-nya. Urutan: Root → Left → Right.

Contoh untuk ekspresi \texttt{3 + 4 * 5}:
\begin{verbatim}
Visit: +
Visit: 3
Visit: *
Visit: 4
Visit: 5
\end{verbatim}

Pre-order berguna untuk:
\begin{itemize}
    \item Menyalin tree
    \item Prefix notation (Polish notation)
    \item Print struktur tree
\end{itemize}

\subsection{Post-Order Traversal}

Post-order traversal mengunjungi node setelah children-nya. Urutan: Left → Right → Root.

Contoh untuk ekspresi \texttt{3 + 4 * 5}:
\begin{verbatim}
Visit: 3
Visit: 4
Visit: 5
Visit: *
Visit: +
\end{verbatim}

Post-order berguna untuk:
\begin{itemize}
    \item Menghapus tree (deallocate memory)
    \item Postfix notation (Reverse Polish notation)
    \item Evaluasi ekspresi
    \item Code generation (stack-based)
\end{itemize}

\subsection{In-Order Traversal}

In-order traversal mengunjungi left child, kemudian node, kemudian right child. Urutan: Left → Root → Right.

Contoh untuk ekspresi \texttt{3 + 4 * 5}:
\begin{verbatim}
Visit: 3
Visit: +
Visit: 4
Visit: *
Visit: 5
\end{verbatim}

In-order berguna untuk:
\begin{itemize}
    \item Infix notation (seperti yang ditulis dalam source code)
    \item Binary search tree operations
\end{itemize}

\subsection{Implementasi Traversal dengan Visitor}

Berikut adalah contoh implementasi PrettyPrinter visitor yang menggunakan pre-order traversal:

\begin{lstlisting}[language=C++, caption=PrettyPrinter Visitor]
// PrettyPrinter.hpp
#ifndef PRETTYPRINTER_HPP
#define PRETTYPRINTER_HPP

#include "ASTVisitor.hpp"
#include <iostream>
#include <string>

class PrettyPrinter : public ASTVisitor {
private:
    int indentLevel;
    
    std::string indent() const {
        return std::string(indentLevel * 2, ' ');
    }
    
public:
    PrettyPrinter() : indentLevel(0) {}
    
    void visit(IntLiteral& node) override {
        std::cout << indent() << "IntLiteral: " << node.value << std::endl;
    }
    
    void visit(Identifier& node) override {
        std::cout << indent() << "Identifier: " << node.name << std::endl;
    }
    
    void visit(BinaryExpr& node) override {
        std::cout << indent() << "BinaryExpr: " << node.op << std::endl;
        indentLevel++;
        if (node.left) node.left->accept(*this);
        if (node.right) node.right->accept(*this);
        indentLevel--;
    }
    
    void visit(UnaryExpr& node) override {
        std::cout << indent() << "UnaryExpr: " << node.op << std::endl;
        indentLevel++;
        if (node.operand) node.operand->accept(*this);
        indentLevel--;
    }
    
    void visit(FunctionCall& node) override {
        std::cout << indent() << "FunctionCall" << std::endl;
        indentLevel++;
        if (node.functionName) node.functionName->accept(*this);
        for (auto& arg : node.arguments) {
            if (arg) arg->accept(*this);
        }
        indentLevel--;
    }
    
    void visit(ExprStmt& node) override {
        std::cout << indent() << "ExprStmt" << std::endl;
        indentLevel++;
        if (node.expression) node.expression->accept(*this);
        indentLevel--;
    }
    
    void visit(VarDecl& node) override {
        std::cout << indent() << "VarDecl: " << node.typeName 
                  << " " << node.varName;
        if (node.initializer) {
            std::cout << " = ";
            indentLevel++;
            node.initializer->accept(*this);
            indentLevel--;
        }
        std::cout << std::endl;
    }
    
    void visit(AssignStmt& node) override {
        std::cout << indent() << "AssignStmt" << std::endl;
        indentLevel++;
        if (node.left) node.left->accept(*this);
        if (node.right) node.right->accept(*this);
        indentLevel--;
    }
    
    void visit(IfStmt& node) override {
        std::cout << indent() << "IfStmt" << std::endl;
        indentLevel++;
        std::cout << indent() << "Condition:" << std::endl;
        indentLevel++;
        if (node.condition) node.condition->accept(*this);
        indentLevel--;
        std::cout << indent() << "Then:" << std::endl;
        indentLevel++;
        if (node.thenBranch) node.thenBranch->accept(*this);
        indentLevel--;
        if (node.elseBranch) {
            std::cout << indent() << "Else:" << std::endl;
            indentLevel++;
            node.elseBranch->accept(*this);
            indentLevel--;
        }
        indentLevel--;
    }
    
    void visit(WhileStmt& node) override {
        std::cout << indent() << "WhileStmt" << std::endl;
        indentLevel++;
        std::cout << indent() << "Condition:" << std::endl;
        indentLevel++;
        if (node.condition) node.condition->accept(*this);
        indentLevel--;
        std::cout << indent() << "Body:" << std::endl;
        indentLevel++;
        if (node.body) node.body->accept(*this);
        indentLevel--;
        indentLevel--;
    }
    
    void visit(BlockStmt& node) override {
        std::cout << indent() << "BlockStmt" << std::endl;
        indentLevel++;
        for (auto& stmt : node.statements) {
            if (stmt) stmt->accept(*this);
        }
        indentLevel--;
    }
    
    void visit(ReturnStmt& node) override {
        std::cout << indent() << "ReturnStmt";
        if (node.expression) {
            std::cout << std::endl;
            indentLevel++;
            node.expression->accept(*this);
            indentLevel--;
        } else {
            std::cout << std::endl;
        }
    }
    
    void visit(Program& node) override {
        std::cout << "Program" << std::endl;
        indentLevel++;
        for (auto& stmt : node.statements) {
            if (stmt) stmt->accept(*this);
        }
        indentLevel--;
    }
};

#endif
\end{lstlisting}