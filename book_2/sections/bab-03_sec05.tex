\section{Implementasi Lexer dalam C++}

Berikut adalah implementasi lengkap lexer sederhana untuk subset bahasa C:

\subsection{Kelas Lexer}

Gambar \ref{fig:lexer-architecture} menunjukkan arsitektur kelas Lexer dan komponen-komponennya.

\begin{figure}[!htbp]
    \centering
    \adjustbox{max width=0.9\textwidth,center}{%
    \begin{tikzpicture}[
        class/.style={rectangle, draw=blue!50, fill=blue!10, text width=3cm, minimum height=1cm, font=\footnotesize, align=center, rounded corners},
        method/.style={rectangle, draw=green!50, fill=green!10, text width=2.5cm, minimum height=0.5cm, font=\tiny, align=center},
        data/.style={rectangle, draw=orange!50, fill=orange!10, text width=2.5cm, minimum height=0.5cm, font=\tiny, align=center},
        arrow/.style={->, >=stealth, thick},
        node distance=0.4cm and 0.3cm
    ]
    
    % Main class
    \node[class] (lexer) {Lexer Class};
    
    % Private members
    \node[data, below left=0.5cm and 0.5cm of lexer] (d1) {input\\position\\line, column};
    \node[data, below right=0.5cm and 0.5cm of lexer] (d2) {keywords\\set};
    
    % Private methods
    \node[method, below=1.5cm of d1] (m1) {peek()\\get()};
    \node[method, right=of m1] (m2) {skipWhitespace()};
    \node[method, right=of m2] (m3) {scanIdentifier()};
    \node[method, below=of m1] (m4) {scanNumber()};
    \node[method, right=of m4] (m5) {scanString()};
    \node[method, right=of m5] (m6) {scanOperator()};
    
    % Public methods
    \node[method, above=1.5cm of lexer, draw=red!50, fill=red!10] (p1) {nextToken()};
    \node[method, right=of p1, draw=red!50, fill=red!10] (p2) {tokenize()};
    
    % Arrows
    \draw[arrow] (lexer) -- (d1);
    \draw[arrow] (lexer) -- (d2);
    \draw[arrow] (lexer) -- (m1);
    \draw[arrow] (lexer) -- (m2);
    \draw[arrow] (lexer) -- (m3);
    \draw[arrow] (lexer) -- (m4);
    \draw[arrow] (lexer) -- (m5);
    \draw[arrow] (lexer) -- (m6);
    \draw[arrow] (p1) -- (lexer);
    \draw[arrow] (p2) -- (lexer);
    
    \end{tikzpicture}%
    }
    \caption{Arsitektur kelas Lexer}
    \label{fig:lexer-architecture}
\end{figure}

\begin{lstlisting}[language=C++, caption=Header File: lexer.h]
#ifndef LEXER_H
#define LEXER_H

#include <string>
#include <unordered_set>
#include <vector>

enum class TokenType {
    IDENTIFIER,
    KEYWORD_INT, KEYWORD_FLOAT, KEYWORD_IF, KEYWORD_ELSE,
    KEYWORD_WHILE, KEYWORD_FOR, KEYWORD_RETURN,
    INTEGER_LITERAL, FLOAT_LITERAL,
    STRING_LITERAL, CHAR_LITERAL,
    OP_PLUS, OP_MINUS, OP_MULTIPLY, OP_DIVIDE,
    OP_ASSIGN, OP_EQUAL, OP_NOT_EQUAL,
    OP_LESS, OP_LESS_EQUAL, OP_GREATER, OP_GREATER_EQUAL,
    OP_AND, OP_OR, OP_NOT,
    SEMICOLON, COMMA, DOT,
    LPAREN, RPAREN, LBRACE, RBRACE,
    LBRACKET, RBRACKET,
    END_OF_FILE, INVALID
};

struct Token {
    TokenType type;
    std::string lexeme;
    int line;
    int column;
    
    Token(TokenType t, const std::string& lex, int l, int c)
        : type(t), lexeme(lex), line(l), column(c) {}
};

class Lexer {
private:
    std::string input;
    size_t position;
    int line;
    int column;
    std::unordered_set<std::string> keywords;
    
    char peek() const;
    char get();
    void skipWhitespace();
    void skipLineComment();
    void skipBlockComment();
    Token scanIdentifier();
    Token scanNumber();
    Token scanString();
    Token scanChar();
    Token scanOperator();
    TokenType getKeywordType(const std::string& lexeme) const;
    
public:
    Lexer(const std::string& source);
    Token nextToken();
    std::vector<Token> tokenize();
};

#endif
\end{lstlisting}

\subsection{Implementasi Lexer}

\begin{lstlisting}[language=C++, caption=Implementasi: lexer.cpp (Bagian 1)]
#include "lexer.h"
#include <cctype>
#include <stdexcept>

Lexer::Lexer(const std::string& source) 
    : input(source), position(0), line(1), column(1) {
    // Initialize keywords
    keywords = {"int", "float", "if", "else", 
                "while", "for", "return"};
}

char Lexer::peek() const {
    if (position >= input.length()) {
        return '\0';
    }
    return input[position];
}

char Lexer::get() {
    if (position >= input.length()) {
        return '\0';
    }
    char c = input[position++];
    if (c == '\n') {
        line++;
        column = 1;
    } else {
        column++;
    }
    return c;
}
\end{lstlisting}

\subsection{Handling Whitespace dan Komentar}

\begin{lstlisting}[language=C++, caption=Implementasi: lexer.cpp (Bagian 2 - Whitespace dan Comments)]
void Lexer::skipWhitespace() {
    while (position < input.length()) {
        char c = peek();
        if (std::isspace(c)) {
            get();
        } else if (c == '/' && position + 1 < input.length() 
                   && input[position + 1] == '/') {
            skipLineComment();
        } else if (c == '/' && position + 1 < input.length() 
                   && input[position + 1] == '*') {
            skipBlockComment();
        } else {
            break;
        }
    }
}

void Lexer::skipLineComment() {
    // Skip "//"
    get(); get();
    // Skip until newline or EOF
    while (peek() != '\n' && peek() != '\0') {
        get();
    }
}

void Lexer::skipBlockComment() {
    // Skip "/*"
    get(); get();
    while (position < input.length()) {
        if (peek() == '*' && position + 1 < input.length() 
            && input[position + 1] == '/') {
            get(); get(); // Skip "*/"
            return;
        }
        get();
    }
    // Error: unclosed comment
    throw std::runtime_error("Unclosed block comment at line " 
                            + std::to_string(line));
}
\end{lstlisting}

\subsection{Scanning Identifier dan Keyword}

\begin{lstlisting}[language=C++, caption=Implementasi: lexer.cpp (Bagian 3 - Identifier)]
Token Lexer::scanIdentifier() {
    int startLine = line;
    int startCol = column;
    std::string lexeme;
    
    // First character must be letter or underscore
    if (std::isalpha(peek()) || peek() == '_') {
        lexeme += get();
    }
    
    // Subsequent characters can be alphanumeric or underscore
    while (std::isalnum(peek()) || peek() == '_') {
        lexeme += get();
    }
    
    // Check if it's a keyword
    TokenType type = getKeywordType(lexeme);
    if (type != TokenType::IDENTIFIER) {
        return Token(type, lexeme, startLine, startCol);
    }
    
    return Token(TokenType::IDENTIFIER, lexeme, startLine, startCol);
}

TokenType Lexer::getKeywordType(const std::string& lexeme) const {
    if (lexeme == "int") return TokenType::KEYWORD_INT;
    if (lexeme == "float") return TokenType::KEYWORD_FLOAT;
    if (lexeme == "if") return TokenType::KEYWORD_IF;
    if (lexeme == "else") return TokenType::KEYWORD_ELSE;
    if (lexeme == "while") return TokenType::KEYWORD_WHILE;
    if (lexeme == "for") return TokenType::KEYWORD_FOR;
    if (lexeme == "return") return TokenType::KEYWORD_RETURN;
    return TokenType::IDENTIFIER;
}
\end{lstlisting}

\subsection{Scanning Number Literals}

\begin{lstlisting}[language=C++, caption=Implementasi: lexer.cpp (Bagian 4 - Numbers)]
Token Lexer::scanNumber() {
    int startLine = line;
    int startCol = column;
    std::string lexeme;
    bool isFloat = false;
    
    // Read integer part
    while (std::isdigit(peek())) {
        lexeme += get();
    }
    
    // Check for decimal point
    if (peek() == '.') {
        lexeme += get();
        isFloat = true;
        
        // Read fractional part
        while (std::isdigit(peek())) {
            lexeme += get();
        }
    }
    
    // Check for exponent (optional, for future enhancement)
    if (peek() == 'e' || peek() == 'E') {
        lexeme += get();
        if (peek() == '+' || peek() == '-') {
            lexeme += get();
        }
        while (std::isdigit(peek())) {
            lexeme += get();
        }
        isFloat = true;
    }
    
    TokenType type = isFloat ? TokenType::FLOAT_LITERAL 
                              : TokenType::INTEGER_LITERAL;
    return Token(type, lexeme, startLine, startCol);
}
\end{lstlisting}

\subsection{Scanning String dan Character Literals}

Gambar \ref{fig:string-escape} menunjukkan contoh handling escape sequences dalam string literal.

\begin{figure}[!htbp]
    \centering
    \adjustbox{max width=0.85\textwidth,center}{%
    \begin{tikzpicture}[
        char/.style={rectangle, draw=blue!50, fill=blue!10, minimum width=0.5cm, minimum height=0.5cm, font=\footnotesize\ttfamily, align=center},
        esc/.style={rectangle, draw=red!50, fill=red!10, minimum width=0.5cm, minimum height=0.5cm, font=\footnotesize\ttfamily, align=center},
        result/.style={rectangle, draw=green!50, fill=green!10, minimum width=2cm, minimum height=0.6cm, font=\tiny, align=center},
        arrow/.style={->, >=stealth, thick},
        node distance=0.15cm and 0.1cm
    ]
    
    % Example: "hello\nworld"
    \node[font=\tiny\bfseries] (label1) {Input: \texttt{"hello\textbackslash nworld"}};
    \node[char, below=0.2cm of label1] (c1) {"};
    \node[char, right=of c1] (c2) {h};
    \node[char, right=of c2] (c3) {e};
    \node[char, right=of c3] (c4) {l};
    \node[char, right=of c4] (c5) {l};
    \node[char, right=of c5] (c6) {o};
    \node[esc, right=of c6] (c7) {\textbackslash};
    \node[esc, right=of c7] (c8) {n};
    \node[char, right=of c8] (c9) {w};
    \node[char, right=of c9] (c10) {o};
    \node[char, right=of c10] (c11) {r};
    \node[char, right=of c11] (c12) {l};
    \node[char, right=of c12] (c13) {d};
    \node[char, right=of c13] (c14) {"};
    
    \node[result, below=0.4cm of c7] (r1) {Escape\\Sequence};
    \draw[arrow, red] (c7) -- (r1);
    \draw[arrow, red] (c8) -- (r1);
    
    \node[result, below=0.6cm of r1, font=\tiny] {Result: STRING\_LITERAL\\"hello\textbackslash nworld"\\(newline character)};
    
    \end{tikzpicture}%
    }
    \caption{Handling escape sequences dalam string literal}
    \label{fig:string-escape}
\end{figure}

\begin{lstlisting}[language=C++, caption=Implementasi: lexer.cpp (Bagian 5 - Strings)]
Token Lexer::scanString() {
    int startLine = line;
    int startCol = column;
    std::string lexeme;
    
    // Consume opening quote
    get(); // Skip opening "
    
    while (peek() != '"' && peek() != '\0') {
        if (peek() == '\\') {
            // Handle escape sequences
            get(); // Skip backslash
            char escaped = get();
            switch (escaped) {
                case 'n': lexeme += '\n'; break;
                case 't': lexeme += '\t'; break;
                case 'r': lexeme += '\r'; break;
                case '\\': lexeme += '\\'; break;
                case '"': lexeme += '"'; break;
                default: lexeme += '\\'; lexeme += escaped; break;
            }
        } else {
            lexeme += get();
        }
    }
    
    if (peek() == '\0') {
        // Unclosed string
        return Token(TokenType::INVALID, lexeme, startLine, startCol);
    }
    
    get(); // Consume closing "
    return Token(TokenType::STRING_LITERAL, lexeme, startLine, startCol);
}

Token Lexer::scanChar() {
    int startLine = line;
    int startCol = column;
    std::string lexeme;
    
    get(); // Skip opening '
    
    if (peek() == '\\') {
        // Escape sequence
        get(); // Skip backslash
        lexeme += get();
    } else {
        lexeme += get();
    }
    
    if (peek() != '\'') {
        return Token(TokenType::INVALID, lexeme, startLine, startCol);
    }
    
    get(); // Consume closing '
    return Token(TokenType::CHAR_LITERAL, lexeme, startLine, startCol);
}
\end{lstlisting}

\subsection{Scanning Operators}

\begin{lstlisting}[language=C++, caption=Implementasi: lexer.cpp (Bagian 6 - Operators)]
Token Lexer::scanOperator() {
    int startLine = line;
    int startCol = column;
    char first = get();
    std::string lexeme(1, first);
    
    // Check for multi-character operators
    char next = peek();
    
    switch (first) {
        case '=':
            if (next == '=') {
                lexeme += get();
                return Token(TokenType::OP_EQUAL, lexeme, startLine, startCol);
            }
            return Token(TokenType::OP_ASSIGN, lexeme, startLine, startCol);
            
        case '!':
            if (next == '=') {
                lexeme += get();
                return Token(TokenType::OP_NOT_EQUAL, lexeme, startLine, startCol);
            }
            return Token(TokenType::OP_NOT, lexeme, startLine, startCol);
            
        case '<':
            if (next == '=') {
                lexeme += get();
                return Token(TokenType::OP_LESS_EQUAL, lexeme, startLine, startCol);
            }
            return Token(TokenType::OP_LESS, lexeme, startLine, startCol);
            
        case '>':
            if (next == '=') {
                lexeme += get();
                return Token(TokenType::OP_GREATER_EQUAL, lexeme, startLine, startCol);
            }
            return Token(TokenType::OP_GREATER, lexeme, startLine, startCol);
            
        case '&':
            if (next == '&') {
                lexeme += get();
                return Token(TokenType::OP_AND, lexeme, startLine, startCol);
            }
            return Token(TokenType::INVALID, lexeme, startLine, startCol);
            
        case '|':
            if (next == '|') {
                lexeme += get();
                return Token(TokenType::OP_OR, lexeme, startLine, startCol);
            }
            return Token(TokenType::INVALID, lexeme, startLine, startCol);
            
        case '+':
            return Token(TokenType::OP_PLUS, lexeme, startLine, startCol);
        case '-':
            return Token(TokenType::OP_MINUS, lexeme, startLine, startCol);
        case '*':
            return Token(TokenType::OP_MULTIPLY, lexeme, startLine, startCol);
        case '/':
            return Token(TokenType::OP_DIVIDE, lexeme, startLine, startCol);
            
        default:
            return Token(TokenType::INVALID, lexeme, startLine, startCol);
    }
}
\end{lstlisting}

\subsection{Main Tokenization Function}

\begin{lstlisting}[language=C++, caption=Implementasi: lexer.cpp (Bagian 7 - Main Function)]
Token Lexer::nextToken() {
    skipWhitespace();
    
    if (position >= input.length()) {
        return Token(TokenType::END_OF_FILE, "", line, column);
    }
    
    char c = peek();
    
    // Identifier or keyword
    if (std::isalpha(c) || c == '_') {
        return scanIdentifier();
    }
    
    // Number
    if (std::isdigit(c)) {
        return scanNumber();
    }
    
    // String literal
    if (c == '"') {
        return scanString();
    }
    
    // Character literal
    if (c == '\'') {
        return scanChar();
    }
    
    // Operators and punctuation
    if (c == '+' || c == '-' || c == '*' || c == '/' ||
        c == '=' || c == '!' || c == '<' || c == '>' ||
        c == '&' || c == '|') {
        return scanOperator();
    }
    
    // Punctuation
    if (c == ';') {
        get();
        return Token(TokenType::SEMICOLON, ";", line, column - 1);
    }
    if (c == ',') {
        get();
        return Token(TokenType::COMMA, ",", line, column - 1);
    }
    if (c == '.') {
        get();
        return Token(TokenType::DOT, ".", line, column - 1);
    }
    if (c == '(') {
        get();
        return Token(TokenType::LPAREN, "(", line, column - 1);
    }
    if (c == ')') {
        get();
        return Token(TokenType::RPAREN, ")", line, column - 1);
    }
    if (c == '{') {
        get();
        return Token(TokenType::LBRACE, "{", line, column - 1);
    }
    if (c == '}') {
        get();
        return Token(TokenType::RBRACE, "}", line, column - 1);
    }
    if (c == '[') {
        get();
        return Token(TokenType::LBRACKET, "[", line, column - 1);
    }
    if (c == ']') {
        get();
        return Token(TokenType::RBRACKET, "]", line, column - 1);
    }
    
    // Unknown character
    get();
    return Token(TokenType::INVALID, std::string(1, c), line, column - 1);
}

std::vector<Token> Lexer::tokenize() {
    std::vector<Token> tokens;
    Token token = nextToken();
    while (token.type != TokenType::END_OF_FILE) {
        tokens.push_back(token);
        token = nextToken();
    }
    tokens.push_back(token); // Add EOF token
    return tokens;
}
\end{lstlisting}

Gambar \ref{fig:identifier-scanning} menunjukkan proses scanning untuk identifier dan keyword.

\begin{figure}[!htbp]
    \centering
    \adjustbox{max width=\textwidth,center}{%
    \begin{tikzpicture}[
        char/.style={rectangle, draw=blue!50, fill=blue!10, minimum width=0.65cm, minimum height=0.65cm, font=\footnotesize\ttfamily, align=center},
        state/.style={rectangle, draw=green!50, fill=green!10, minimum width=1.6cm, minimum height=0.6cm, font=\scriptsize, align=center},
        arrow/.style={->, >=stealth, thick}
    ]
    
    % parameter jarak horizontal
    \def\hx{1.8cm}
    \def\vy{1.8cm}
    \def\gap{4.5cm}
    
    % =======================
    % Example 1: keyword/identifier
    % =======================
    \node[char] (c1a) {w};
    \node[char, xshift=\hx] (c1b) at (c1a.east) {h};
    \node[char, xshift=\hx] (c1c) at (c1b.east) {i};
    \node[char, xshift=\hx] (c1d) at (c1c.east) {l};
    \node[char, xshift=\hx] (c1e) at (c1d.east) {e};
    \node[char, xshift=\hx] (c1f) at (c1e.east) {(};
    
    \node[state, yshift=-\vy] (s1a) at (c1a.south) {START};
    \node[state, yshift=-\vy] (s1b) at (c1b.south) {IN\_ID};
    \node[state, yshift=-\vy] (s1c) at (c1c.south) {IN\_ID};
    \node[state, yshift=-\vy] (s1d) at (c1d.south) {IN\_ID};
    \node[state, yshift=-\vy] (s1e) at (c1e.south) {IN\_ID};
    \node[state, yshift=-\vy] (s1f) at (c1f.south) {DONE};
    
    \foreach \x/\y in {c1a/s1a,c1b/s1b,c1c/s1c,c1d/s1d,c1e/s1e,c1f/s1f}
        \draw[arrow] (\x) -- (\y);
    
    \draw[arrow, dashed] (s1a) -- (s1b);
    \draw[arrow, dashed] (s1b) -- (s1c);
    \draw[arrow, dashed] (s1c) -- (s1d);
    \draw[arrow, dashed] (s1d) -- (s1e);
    \draw[arrow, dashed] (s1e) -- (s1f);
    
    \node[below=1.0cm of s1d, font=\scriptsize] {Result: \textbf{KEYWORD\_WHILE}};
    
    % =======================
    % Example 2: number literal
    % =======================
    \node[char, yshift=-\gap] (c2a) at (c1a.south) {4};
    \node[char, xshift=\hx] (c2b) at (c2a.east) {2};
    \node[char, xshift=\hx] (c2c) at (c2b.east) {.};
    \node[char, xshift=\hx] (c2d) at (c2c.east) {5};
    \node[char, xshift=\hx] (c2e) at (c2d.east) {;};
    
    \node[state, yshift=-\vy] (s2a) at (c2a.south) {START};
    \node[state, yshift=-\vy] (s2b) at (c2b.south) {IN\_NUM};
    \node[state, yshift=-\vy] (s2c) at (c2c.south) {IN\_FLOAT};
    \node[state, yshift=-\vy] (s2d) at (c2d.south) {IN\_FLOAT};
    \node[state, yshift=-\vy] (s2e) at (c2e.south) {DONE};
    
    \foreach \x/\y in {c2a/s2a,c2b/s2b,c2c/s2c,c2d/s2d,c2e/s2e}
        \draw[arrow] (\x) -- (\y);
    
    \draw[arrow, dashed] (s2a) -- (s2b);
    \draw[arrow, dashed] (s2b) -- (s2c);
    \draw[arrow, dashed] (s2c) -- (s2d);
    \draw[arrow, dashed] (s2d) -- (s2e);
    
    \node[below=1.0cm of s2c, font=\scriptsize] {Result: \textbf{FLOAT\_LITERAL 42.5}};
    
    \end{tikzpicture}%
    }
    \caption{Proses scanning keyword/identifier dan literal numerik pada lexer}
    \label{fig:identifier-scanning}
    \end{figure}
    
    
    

Gambar \ref{fig:operator-scanning} menunjukkan proses scanning untuk operator multi-character.

\begin{figure}[!htbp]
    \centering
    \adjustbox{max width=0.75\textwidth,center}{%
    \begin{tikzpicture}[
        char/.style={rectangle, draw=blue!50, fill=blue!10, minimum width=0.6cm, minimum height=0.6cm, font=\footnotesize\ttfamily, align=center},
        state/.style={rectangle, draw=orange!60, fill=orange!10, minimum width=1.8cm, minimum height=0.55cm, font=\scriptsize, align=center, rounded corners},
        arrow/.style={->, >=stealth, thick}
    ]
    
    % parameter jarak
    \def\hx{2.8cm}
    \def\vy{1.4cm}
    \def\gap{3.2cm}
    
    % =======================
    % Example 1: operator ==
    % =======================
    \node[char] (c1) {=};
    \node[char, xshift=\hx] (c2) at (c1.east) {=};
    \node[char, xshift=\hx] (c3) at (c2.east) {;};
    
    \node[state, yshift=-\vy] (s1) at (c1.south) {START\\lookahead '='};
    \node[state, yshift=-\vy] (s2) at (c2.south) {IN\_OP\\consume '='};
    \node[state, yshift=-\vy] (s3) at (c3.south) {DONE};
    
    \draw[arrow] (c1) -- (s1);
    \draw[arrow] (c2) -- (s2);
    \draw[arrow] (c3) -- (s3);
    
    \draw[arrow, dashed] (s1) -- node[above, font=\scriptsize] {match} (s2);
    \draw[arrow, dashed] (s2) -- (s3);
    
    \node[below=0.5cm of s2, font=\scriptsize] {Result: \textbf{OP\_EQUAL} (\texttt{==})};
    
    % =======================
    % Example 2: operator =
    % =======================
    \node[char, yshift=-\gap] (c4) at (c1.south) {=};
    \node[char, xshift=\hx] (c5) at (c4.east) {;};
    
    \node[state, yshift=-\vy] (s4) at (c4.south) {START\\lookahead ';'};
    \node[state, yshift=-\vy] (s5) at (c5.south) {DONE};
    
    \draw[arrow] (c4) -- (s4);
    \draw[arrow] (c5) -- (s5);
    
    \draw[arrow, dashed] (s4) -- node[above, font=\scriptsize] {no match} (s5);
    
    \node[below=0.5cm of s4, font=\scriptsize] {Result: \textbf{OP\_ASSIGN} (\texttt{=})};
    
    \end{tikzpicture}%
    }
    \caption{Proses scanning operator: perbandingan \texttt{==} dan \texttt{=}}
    \label{fig:operator-scanning}
    \end{figure}