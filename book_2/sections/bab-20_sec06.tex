\section{Extensions dan Perbaikan}

Compiler sederhana yang telah kita buat sudah berfungsi dengan baik untuk program minimal. Namun, ada banyak perbaikan dan extensions yang dapat ditambahkan untuk membuat compiler lebih robust dan powerful.

\subsection{Menambahkan Support untuk Ekspresi Sederhana}

Saat ini compiler hanya mendukung print statement dengan string literal. Kita dapat memperluasnya untuk mendukung ekspresi sederhana.

\subsubsection{Modifikasi Grammar}

Grammar yang diperluas:
\begin{verbatim}
program     → stmt
stmt        → print_stmt
print_stmt  → PRINT LPAREN expr RPAREN SEMICOLON
expr        → STRING | INTEGER | IDENTIFIER
\end{verbatim}

\subsubsection{Modifikasi AST}

Tambahkan node untuk ekspresi:
\begin{lstlisting}[language=C, caption={AST yang diperluas}]
typedef struct ASTNode {
    enum {
        AST_PRINT_STMT,
        AST_STRING_EXPR,
        AST_INTEGER_EXPR,
        AST_IDENTIFIER_EXPR
    } type;
    
    union {
        struct {
            ASTNode* expr;  // Expression yang akan di-print
        } print_stmt;
        
        struct {
            char* value;
        } string_expr;
        
        struct {
            int value;
        } integer_expr;
        
        struct {
            char* name;
        } identifier_expr;
    } data;
} ASTNode;
\end{lstlisting}

\subsubsection{Modifikasi Parser}

Tambahkan fungsi parsing untuk ekspresi:
\begin{lstlisting}[language=C, caption={Parser untuk ekspresi}]
ASTNode* parseExpr(void) {
    if (currentToken.type == TOKEN_STRING) {
        ASTNode* node = (ASTNode*)malloc(sizeof(ASTNode));
        node->type = AST_STRING_EXPR;
        node->data.string_expr.value = 
            (char*)malloc(strlen(currentToken.value) + 1);
        strcpy(node->data.string_expr.value, currentToken.value);
        advance();
        return node;
    }
    
    if (currentToken.type == TOKEN_INTEGER) {
        ASTNode* node = (ASTNode*)malloc(sizeof(ASTNode));
        node->type = AST_INTEGER_EXPR;
        node->data.integer_expr.value = atoi(currentToken.value);
        advance();
        return node;
    }
    
    // Error
    fprintf(stderr, "Expected expression\n");
    exit(1);
}

ASTNode* parsePrintStmt(void) {
    ASTNode* node = (ASTNode*)malloc(sizeof(ASTNode));
    node->type = AST_PRINT_STMT;
    
    expect(TOKEN_PRINT);
    expect(TOKEN_LPAREN);
    
    node->data.print_stmt.expr = parseExpr();
    
    expect(TOKEN_RPAREN);
    expect(TOKEN_SEMICOLON);
    
    return node;
}
\end{lstlisting}

\subsubsection{Modifikasi Code Generator}

Generate code untuk berbagai jenis ekspresi:
\begin{lstlisting}[language=C, caption={Code generator untuk ekspresi}]
void generateExpr(ASTNode* expr, FILE* output) {
    switch (expr->type) {
        case AST_STRING_EXPR:
            emit(output, "    lea rdx, [msg]\n");
            emit(output, "    mov r8, msg_len\n");
            break;
        case AST_INTEGER_EXPR:
            // Convert integer to string (simplified)
            emit(output, "    lea rdx, [int_str]\n");
            emit(output, "    mov r8, int_str_len\n");
            break;
        default:
            fprintf(stderr, "Unsupported expression type\n");
            exit(1);
    }
}

void generateCode(ASTNode* ast, FILE* output) {
    // ... setup code ...
    
    generateExpr(ast->data.print_stmt.expr, output);
    
    // ... rest of code ...
}
\end{lstlisting}

\subsection{Error Handling yang Lebih Baik}

Saat ini, compiler langsung exit ketika menemukan error. Kita dapat memperbaikinya dengan:

\subsubsection{Error Recovery}

\begin{lstlisting}[language=C, caption={Error recovery dalam parser}]
static int errorCount = 0;
static int maxErrors = 10;

static void reportError(const char* message) {
    fprintf(stderr, "Error at line %d, column %d: %s\n",
            currentToken.line, currentToken.column, message);
    errorCount++;
    
    if (errorCount >= maxErrors) {
        fprintf(stderr, "Too many errors, stopping compilation\n");
        exit(1);
    }
}

static void synchronize(void) {
    // Skip tokens until we find a statement boundary
    while (currentToken.type != TOKEN_EOF) {
        if (currentToken.type == TOKEN_SEMICOLON) {
            advance();
            return;
        }
        advance();
    }
}
\end{lstlisting}

\subsubsection{Error Messages yang Informatif}

Tambahkan informasi lebih detail dalam error messages:
\begin{lstlisting}[language=C, caption={Error messages yang lebih baik}]
static void expect(TokenType expected) {
    if (currentToken.type != expected) {
        fprintf(stderr, "Error at line %d, column %d: ", 
                currentToken.line, currentToken.column);
        fprintf(stderr, "Expected ");
        printTokenType(expected);
        fprintf(stderr, ", but got ");
        printTokenType(currentToken.type);
        fprintf(stderr, "\n");
        
        // Try to recover
        synchronize();
    } else {
        advance();
    }
}
\end{lstlisting}

\subsection{Optimasi Dasar}

Beberapa optimasi sederhana yang dapat ditambahkan:

\subsubsection{Constant Folding}

Jika ekspresi adalah konstanta, evaluasi pada compile time:
\begin{lstlisting}[language=C, caption={Constant folding}]
int evaluateConstant(ASTNode* node) {
    switch (node->type) {
        case AST_INTEGER_EXPR:
            return node->data.integer_expr.value;
        case AST_ADD_EXPR:
            return evaluateConstant(node->data.add_expr.left) +
                   evaluateConstant(node->data.add_expr.right);
        // ... other cases ...
        default:
            return -1; // Not a constant
    }
}
\end{lstlisting}

\subsubsection{Dead Code Elimination}

Hapus kode yang tidak pernah dieksekusi (jika menambahkan control flow).

\subsubsection{Register Allocation}

Gunakan register dengan lebih efisien dalam code generation.

\subsection{Menambahkan Fitur Baru}

\subsubsection{Multiple Statements}

Support untuk multiple print statements:
\begin{verbatim}
print("Hello");
print("World");
\end{verbatim}

\subsubsection{Variables}

Support untuk variabel sederhana:
\begin{verbatim}
int x = 42;
print(x);
\end{verbatim}

\subsubsection{Arithmetic Expressions}

Support untuk operasi aritmatika:
\begin{verbatim}
print(10 + 20);
print(5 * 3);
\end{verbatim}

\subsubsection{Comments}

Support untuk komentar:
\begin{verbatim}
// This is a comment
print("Hello"); // Another comment
\end{verbatim}

\subsection{Testing Framework}

Buat testing framework untuk memudahkan pengujian:

\begin{lstlisting}[language=C, caption={test_framework.c}]
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    const char* name;
    const char* source;
    int shouldFail;
} TestCase;

void runTest(TestCase* test) {
    printf("Running test: %s\n", test->name);
    
    // Compile
    // Run
    // Check output
    
    printf("  PASSED\n");
}

int main() {
    TestCase tests[] = {
        {"Basic print", "print(\"hello\");", 0},
        {"Missing semicolon", "print(\"hello\")", 1},
        // ... more tests ...
    };
    
    int numTests = sizeof(tests) / sizeof(tests[0]);
    int passed = 0;
    
    for (int i = 0; i < numTests; i++) {
        runTest(&tests[i]);
        passed++;
    }
    
    printf("\n%d/%d tests passed\n", passed, numTests);
    return 0;
}
\end{lstlisting}

\subsection{Documentation}

Tambahkan dokumentasi yang lengkap:
\begin{itemize}
    \item README.md dengan instruksi build dan usage
    \item Comments dalam kode yang menjelaskan setiap fungsi
    \item Contoh-contoh penggunaan
    \item Troubleshooting guide
\end{itemize}

\subsection{Saran untuk Pengembangan Lebih Lanjut}

\begin{enumerate}
    \item \textbf{Type System}: Tambahkan type checking untuk memastikan type safety
    \item \textbf{Symbol Table}: Implementasikan symbol table untuk variabel dan fungsi
    \item \textbf{Control Flow}: Tambahkan support untuk if/else, loops
    \item \textbf{Functions}: Support untuk definisi dan pemanggilan fungsi
    \item \textbf{Arrays}: Support untuk array dan indexing
    \item \textbf{Structs}: Support untuk struktur data
    \item \textbf{Standard Library}: Implementasikan standard library functions
    \item \textbf{Optimization Passes}: Tambahkan lebih banyak optimasi
    \item \textbf{Debugging Support}: Tambahkan informasi debugging dalam output
    \item \textbf{Cross-platform}: Support untuk Linux dan macOS selain Windows
\end{enumerate}

\subsection{Kesimpulan}

Compiler sederhana yang telah kita buat adalah fondasi yang baik untuk memahami proses kompilasi. Dengan extensions dan perbaikan yang telah dijelaskan, compiler ini dapat berkembang menjadi compiler yang lebih powerful dan robust.

Penting untuk diingat bahwa:
\begin{itemize}
    \item Compiler development adalah proses iteratif
    \item Mulai dari yang sederhana, kemudian tambahkan fitur secara bertahap
    \item Testing sangat penting untuk memastikan compiler bekerja dengan benar
    \item Dokumentasi membantu dalam maintenance dan pengembangan lebih lanjut
\end{itemize}

Dengan memahami dasar-dasar yang telah dipelajari dalam tutorial ini, Anda dapat mengembangkan compiler yang lebih kompleks sesuai kebutuhan.
