\section{Jawaban Ujian Tengah Semester (UTS)}

\subsection{Jawaban Soal UTS}

\begin{enumerate}
\item \textbf{[Bab 1 - 15 poin]} \textbf{Perbedaan antara kompilator dan interpreter:}

\textbf{Kompilator:}
\begin{itemize}
    \item Menerjemahkan seluruh program menjadi kode target sebelum eksekusi.
    \item Hasil translasi berupa object code atau executable binary.
    \item Proses kompilasi dilakukan sekali, hasilnya dapat dijalankan berulang kali tanpa kompilasi ulang.
    \item Contoh bahasa: C, C++, Rust, Fortran.
    \item Alasan penggunaan: performa eksekusi tinggi karena kode telah diterjemahkan ke bahasa mesin dan dapat dioptimasi.
\end{itemize}

\textbf{Interpreter:}
\begin{itemize}
    \item Mengeksekusi program melalui interpretasi atau bytecode execution.
    \item Source code biasanya diterjemahkan ke intermediate representation (bytecode) sebelum dieksekusi.
    \item Eksekusi dilakukan melalui virtual machine atau interpreter runtime.
    \item Contoh bahasa: Python, JavaScript, Ruby, PHP.
    \item Alasan penggunaan: fleksibilitas tinggi dan kemudahan pengembangan.
\end{itemize}

\textbf{Pendekatan Hybrid:}
\begin{itemize}
    \item \textbf{Java}: dikompilasi menjadi bytecode, kemudian dieksekusi oleh JVM dengan dukungan JIT compilation.
    \item \textbf{C\#}: dikompilasi menjadi Intermediate Language (IL), kemudian dieksekusi oleh CLR dengan JIT.
    \item \textbf{Python}: dikompilasi menjadi bytecode (.pyc) lalu diinterpretasi oleh Python Virtual Machine; beberapa implementasi mendukung JIT.
\end{itemize}

\item \textbf{[Bab 1 - 15 poin]} \textbf{Tahapan proses kompilasi:}

\begin{enumerate}
    \item \textbf{Preprocessing}: menghasilkan expanded source code.
    \item \textbf{Lexical Analysis}: menghasilkan token stream.
    \item \textbf{Syntax Analysis}: membangun parse tree atau AST.
    \item \textbf{Semantic Analysis}: menghasilkan annotated AST.
    \item \textbf{Intermediate Code Generation}: menghasilkan intermediate representation (IR).
    \item \textbf{Code Optimization}: optimasi IR.
    \item \textbf{Code Generation}: menghasilkan assembly code.
    \item \textbf{Assembling}: menghasilkan object file.
    \item \textbf{Linking}: menghasilkan executable binary.
\end{enumerate}

\item \textbf{[Bab 2 - 20 poin]}

\begin{enumerate}
\item \textbf{Regular expression:}
\begin{itemize}
    \item Identifier C: \texttt{[a-zA-Z\_][a-zA-Z0-9\_]*}
    \item Floating point number:
    \[
    [0-9]+\.[0-9]+([eE][+-]?[0-9]+)?
    \]
    \item C-style multi-line comment:
    \[
    /\*([^*]|\*+[^*/])*\*/
    \]
\end{itemize}

\item \textbf{Konstruksi NFA Thompson untuk $(a|b)^*abb$:}

Struktur Thompson:
\begin{itemize}
    \item NFA untuk $a$ dan $b$ dibangun secara terpisah.
    \item Operator union $(a|b)$ dibangun dengan $\epsilon$-transition.
    \item Operator Kleene star $(a|b)^*$ ditambahkan dengan state awal dan akhir baru.
    \item Konkatenasi dengan simbol $a$, $b$, dan $b$ dilakukan secara berurutan.
\end{itemize}

\item \textbf{Subset construction (NFA $\rightarrow$ DFA):}

\begin{enumerate}
    \item Tentukan $\epsilon$-closure dari state awal NFA sebagai state awal DFA.
    \item Untuk setiap state DFA dan setiap simbol input, hitung transisi dan $\epsilon$-closure.
    \item State DFA yang mengandung accept state NFA menjadi accept state DFA.
\end{enumerate}

\end{enumerate}

\item \textbf{[Bab 3 - 15 poin]} \textbf{Implementasi lexer C++:}

(isi tetap, tidak ada kesalahan konsep utama)

\item \textbf{[Bab 4 - 15 poin]}

\textbf{Perbaikan Flex specification:}
\begin{verbatim}
%%
"if"|"else"|"while"|"int"|"float"     { return KEYWORD; }
[a-zA-Z_][a-zA-Z0-9_]*               { return IDENTIFIER; }
[0-9]+                               { return INTEGER; }
[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?     { return FLOAT; }
"=="|"!="|"<="|">="                  { return OPERATOR; }
"+"|"-"|"*"|"/"|"="                  { return OPERATOR; }
";"|","|"("|")"|"{"|"}"              { return PUNCTUATION; }
[ \t\n]+                             { /* skip whitespace */ }
.                                    { /* lexical error */ }
%%
\end{verbatim}

\item \textbf{[Bab 5 - 20 poin]}

\textbf{Grammar bebas left recursion:}
\begin{verbatim}
E  -> T E'
E' -> + T E' | - T E' | ε
T  -> F T'
T' -> * F T' | / F T' | ε
F  -> number | ( E )
\end{verbatim}

\textbf{Leftmost derivation untuk $2 + 3 * 4$:}
\begin{verbatim}
E
=> T E'
=> F T' E'
=> 2 E'
=> 2 + T E'
=> 2 + F T' E'
=> 2 + 3 * F T' E'
=> 2 + 3 * 4
\end{verbatim}

\textbf{Ambiguity grammar:}

Grammar
\[
E \rightarrow E + E \mid E * E \mid (E) \mid number
\]
adalah ambiguous karena terdapat lebih dari satu parse tree untuk string $2 + 3 * 4$.

\item \textbf{[Bab 6 - 20 poin]}

\textbf{Grammar setelah eliminasi left recursion:}
\begin{verbatim}
E  -> T E'
E' -> + T E' | - T E' | ε
T  -> F T'
T' -> * F T' | / F T' | ε
F  -> number | ( E )
\end{verbatim}

\item \textbf{[Bab 7 - 20 poin]}

\textbf{Perbaikan shift-reduce parsing:}

Grammar:
\begin{verbatim}
E -> E + T | T
T -> T * F | F
F -> id
\end{verbatim}

Urutan reduce yang benar:
\begin{itemize}
    \item F → id
    \item T → F
    \item F → id
    \item T → T * F
    \item E → T
    \item E → E + T
\end{itemize}

\textbf{Contoh grammar LALR(1) tetapi bukan SLR(1):}
\begin{verbatim}
S -> L = R | R
L -> * R | id
R -> L
\end{verbatim}

\item \textbf{[Integratif - 20 poin]}

(arsitektur kompilator tetap, sudah benar)

\end{enumerate}
