\section{Soal Ujian Akhir Semester (UAS)}

\subsection{Petunjuk}
\begin{itemize}
    \item Waktu ujian: 150 menit
    \item Materi: Bab 8 sampai Bab 15
    \item Jawablah semua soal dengan jelas dan lengkap
    \item Gunakan diagram, pseudocode, atau ilustrasi jika diperlukan
    \item Soal bersifat integratif, menghubungkan konsep dari berbagai bab
\end{itemize}

\subsection{Soal UAS}

\begin{enumerate}
    \item \textbf{[Bab 8 - 20 poin]} 
    \begin{enumerate}
        \item Buatlah grammar specification untuk Bison/Yacc yang dapat mem-parse ekspresi aritmatika dengan operator \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, dan parentheses. Grammar harus menghormati precedence dan associativity yang benar. Sertakan semantic actions untuk membangun AST.
        
        \item Jelaskan bagaimana Bison menangani shift-reduce conflicts dan reduce-reduce conflicts. Berikan contoh grammar yang menyebabkan masing-masing conflict dan jelaskan cara mengatasinya.
        
        \item Implementasikan kalkulator sederhana menggunakan Flex dan Bison yang dapat mengevaluasi ekspresi aritmatika. Sertakan error handling untuk syntax errors.
    \end{enumerate}
    
    \item \textbf{[Bab 9 - 20 poin]}
    \begin{enumerate}
        \item Rancanglah struktur data AST untuk bahasa sederhana yang mendukung:
        \begin{itemize}
            \item Variable declarations: \texttt{int x;}
            \item Assignments: \texttt{x = 5;}
            \item Arithmetic expressions: \texttt{a + b * c}
            \item If-else statements: \texttt{if (x > 0) \{ ... \} else \{ ... \}}
            \item While loops: \texttt{while (x < 10) \{ ... \}}
        \end{itemize}
        Gunakan class hierarchy dalam C++ atau struct dengan variant types.
        
        \item Implementasikan fungsi untuk melakukan post-order traversal pada AST. Jelaskan mengapa post-order traversal penting untuk code generation.
        
        \item Buatlah fungsi visualizer sederhana yang dapat mencetak AST dalam format tree (dapat menggunakan indentasi atau format lainnya). Berikan contoh output untuk ekspresi \texttt{(a + b) * c - d}.
    \end{enumerate}
    
    \item \textbf{[Bab 10 - 20 poin]}
    \begin{enumerate}
        \item Rancanglah implementasi symbol table yang efisien untuk bahasa dengan nested scopes. Struktur data harus mendukung:
        \begin{itemize}
            \item Insert: Menambahkan symbol baru ke scope saat ini
            \item Lookup: Mencari symbol mulai dari scope saat ini ke outer scopes
            \item Enter scope: Membuka scope baru
            \item Exit scope: Menutup scope saat ini dan menghapus semua symbol di scope tersebut
        \end{itemize}
        Jelaskan pilihan struktur data yang digunakan (hash table, linked list, dll.) dan kompleksitas operasinya.
        
        \item Implementasikan name resolution untuk program berikut. Tunjukkan bagaimana symbol table digunakan untuk resolve setiap penggunaan identifier:
        \begin{verbatim}
        int x = 1;
        {
            int y = 2;
            {
                int x = 3;
                y = x + y;  // Which x and y?
            }
            x = y;  // Which x and y?
        }
        \end{verbatim}
        
        \item Jelaskan perbedaan antara static scoping dan dynamic scoping. Berikan contoh program yang menghasilkan output berbeda untuk kedua pendekatan.
    \end{enumerate}
    
    \item \textbf{[Bab 11 - 20 poin]}
    \begin{enumerate}
        \item Implementasikan type checker sederhana yang dapat memeriksa:
        \begin{itemize}
            \item Type compatibility untuk operasi aritmatika (int dengan int, float dengan float, dll.)
            \item Type checking untuk assignment (tipe harus compatible)
            \item Type checking untuk function calls (jumlah dan tipe parameter harus sesuai)
        \end{itemize}
        Sertakan error reporting yang jelas untuk type mismatches.
        
        \item Jelaskan konsep type inference dan berikan contoh implementasi sederhana untuk type inference dalam ekspresi aritmatika. Bandingkan dengan explicit type checking.
        
        \item Buatlah algoritma untuk melakukan semantic analysis yang mencakup:
        \begin{itemize}
            \item Check bahwa variabel dideklarasi sebelum digunakan
            \item Check bahwa variabel tidak dideklarasi dua kali dalam scope yang sama
            \item Check bahwa return statement ada untuk fungsi yang mengembalikan nilai
        \end{itemize}
    \end{enumerate}
    
    \item \textbf{[Bab 12 - 25 poin]}
    \begin{enumerate}
        \item Implementasikan generator three-address code (TAC) dari AST. Generator harus dapat menghasilkan TAC untuk:
        \begin{itemize}
            \item Arithmetic expressions: \texttt{a + b * c}
            \item Assignment statements: \texttt{x = a + b;}
            \item If-else statements dengan conditional jumps
            \item While loops dengan loop labels dan jumps
        \end{itemize}
        
        \item Konversi ekspresi berikut menjadi three-address code:
        \begin{verbatim}
        x = (a + b) * (c - d) / e;
        \end{verbatim}
        Tunjukkan semua temporary variables yang digunakan.
        
        \item Implementasikan representasi quadruples untuk three-address code. Buatlah fungsi untuk:
        \begin{itemize}
            \item Menambahkan quadruple baru
            \item Mencetak semua quadruples
            \item Mencari quadruple berdasarkan label atau line number
        \end{itemize}
        
        \item Jelaskan perbedaan antara three-address code, quadruples, dan triples. Kapan sebaiknya menggunakan masing-masing representasi?
    \end{enumerate}
    
    \item \textbf{[Bab 13 - 20 poin]}
    \begin{enumerate}
        \item Jelaskan konsep activation record (stack frame) dalam runtime environment. Gambarkan struktur activation record untuk fungsi berikut:
        \begin{verbatim}
        int factorial(int n) {
            if (n <= 1) return 1;
            return n * factorial(n - 1);
        }
        \end{verbatim}
        Sertakan lokasi untuk parameters, return value, return address, dan local variables.
        
        \item Jelaskan bagaimana runtime stack digunakan untuk memanggil fungsi rekursif. Trace eksekusi untuk \texttt{factorial(3)} dan tunjukkan bagaimana stack berubah untuk setiap recursive call.
        
        \item Bandingkan antara stack-based memory management dan heap-based memory management. Kapan masing-masing digunakan? Jelaskan juga garbage collection sebagai alternatif untuk manual memory management.
    \end{enumerate}
    
    \item \textbf{[Bab 14 - 25 poin]}
    \begin{enumerate}
        \item Implementasikan code generator sederhana yang mengkonversi three-address code menjadi assembly-like code untuk arsitektur sederhana dengan 4 register. Generator harus melakukan:
        \begin{itemize}
            \item Register allocation (dapat menggunakan simple strategy seperti first-available register)
            \item Instruction selection (memilih instruksi assembly yang sesuai)
            \item Spill handling (ketika tidak ada register tersedia)
        \end{itemize}
        
        \item Konversi three-address code berikut menjadi assembly code (asumsikan arsitektur dengan instruksi: \texttt{LOAD}, \texttt{STORE}, \texttt{ADD}, \texttt{SUB}, \texttt{MUL}, \texttt{DIV}):
        \begin{verbatim}
        t1 = b * c
        t2 = a + t1
        x = t2
        \end{verbatim}
        Tunjukkan register allocation yang digunakan.
        
        \item Jelaskan algoritma graph coloring untuk register allocation. Mengapa algoritma ini lebih baik daripada simple strategies? Berikan contoh kasus di mana graph coloring menghasilkan kode yang lebih efisien.
        
        \item Bandingkan antara one-pass code generation dan multi-pass code generation. Kapan masing-masing pendekatan lebih cocok digunakan?
    \end{enumerate}
    
    \item \textbf{[Bab 15 - 20 poin]}
    \begin{enumerate}
        \item Implementasikan optimasi dasar berikut pada three-address code:
        \begin{itemize}
            \item Constant folding: \texttt{t1 = 2 + 3} menjadi \texttt{t1 = 5}
            \item Dead code elimination: Menghapus assignment yang tidak digunakan
            \item Common subexpression elimination: Mengidentifikasi dan menghilangkan ekspresi yang dihitung berulang kali
        \end{itemize}
        
        \item Jelaskan konsep data flow analysis. Buatlah contoh analisis untuk:
        \begin{itemize}
            \item Reaching definitions: Menemukan definisi variabel yang dapat mencapai suatu titik dalam program
            \item Live variables: Menemukan variabel yang masih digunakan setelah suatu titik
        \end{itemize}
        
        \item Optimasi kode berikut dengan menerapkan constant folding, dead code elimination, dan common subexpression elimination:
        \begin{verbatim}
        t1 = 2 + 3
        t2 = t1 * 4
        t3 = a + b
        t4 = a + b
        t5 = t3 * t4
        x = t2
        y = t5
        z = t1  // t1 tidak digunakan setelah ini
        \end{verbatim}
        Tunjukkan kode sebelum dan sesudah optimasi.
    \end{enumerate}
    
    \item \textbf{[Integratif - 30 poin]} Rancanglah dan implementasikan kompilator sederhana yang lengkap untuk bahasa mini dengan fitur berikut:
    \begin{itemize}
        \item Variable declarations: \texttt{int x;}
        \item Assignments: \texttt{x = 5;}
        \item Arithmetic expressions dengan operator \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}
        \item If-else statements: \texttt{if (x > 0) \{ ... \} else \{ ... \}}
        \item While loops: \texttt{while (x < 10) \{ x = x + 1; \}}
        \item Print statements: \texttt{print(x);}
    \end{itemize}
    
    Kompilator harus terdiri dari:
    \begin{enumerate}
        \item Lexer (dapat menggunakan Flex atau hand-written)
        \item Parser yang membangun AST (dapat menggunakan Bison atau hand-written)
        \item Symbol table untuk name resolution
        \item Type checker untuk semantic analysis
        \item Intermediate code generator yang menghasilkan three-address code
        \item Code generator yang menghasilkan target code (dapat berupa pseudo-assembly atau interpretasi langsung)
    \end{enumerate}
    
    Buatlah diagram arsitektur lengkap yang menunjukkan bagaimana semua komponen berinteraksi. Sertakan contoh input program dan output dari setiap fase kompilasi. Jelaskan juga pilihan desain yang dibuat dan trade-offs yang dipertimbangkan.
    
    \item \textbf{[Integratif - 20 poin]} Analisis dan evaluasi kompilator modern (pilih salah satu: GCC, Clang, atau kompilator lain). Identifikasi dan jelaskan:
    \begin{enumerate}
        \item Arsitektur kompilator: front-end, middle-end, dan back-end
        \item Format intermediate representation yang digunakan dan mengapa format tersebut dipilih
        \item Teknik optimasi yang diimplementasikan dan bagaimana optimasi tersebut bekerja
        \item Strategi register allocation yang digunakan
        \item Teknik code generation untuk target architecture tertentu (misalnya x86-64 atau ARM)
    \end{enumerate}
    
    Bandingkan dengan kompilator sederhana yang dirancang di soal nomor 9. Jelaskan perbedaan kompleksitas dan kemampuan antara kompilator production dan kompilator sederhana.
\end{enumerate}

\vspace{1cm}
\textbf{Total: 220 poin}
