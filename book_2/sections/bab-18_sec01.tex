\section{Soal}

\subsection{Quiz Bab 1: Pengenalan Kompilator dan Fase-Fase Kompilasi}

\begin{enumerate}
    \item Apa perbedaan utama antara kompilator dan interpreter?
    \begin{enumerate}[label=\alph*.)]
        \item Kompilator mengeksekusi baris per baris; interpreter menerjemahkan seluruh program sekaligus
        \item Kompilator menerjemahkan seluruh program sekaligus sebelum dieksekusi; interpreter menerjemahkan dan mengeksekusi baris demi baris
        \item Kompilator menghasilkan bytecode; interpreter menghasilkan machine code
        \item Tidak ada perbedaan yang signifikan
    \end{enumerate}
    
    \item Fase kompilasi manakah yang bertanggung jawab menghapus whitespace dan komentar?
    \begin{enumerate}[label=\alph*.)]
        \item Syntax analysis
        \item Semantic analysis
        \item Lexical analysis
        \item Code generation
    \end{enumerate}
    
    \item Manakah yang termasuk bahasa yang menggunakan pendekatan interpreter?
    \begin{enumerate}[label=\alph*.)]
        \item C dan C++
        \item Python dan JavaScript
        \item Rust dan Go
        \item Pascal dan Fortran
    \end{enumerate}
    
    \item Fase manakah yang mengonversi ekspresi \texttt{a + b * c} menjadi three-address code?
    \begin{enumerate}[label=\alph*.)]
        \item Lexical analysis
        \item Syntax analysis
        \item Semantic analysis
        \item Intermediate code generation
    \end{enumerate}
    
    \item Program yang menerjemahkan assembly code ke machine code disebut\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Kompilator
        \item Interpreter
        \item Assembler
        \item Linker
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 2: Regular Expression dan Finite Automata}

\begin{enumerate}
    \item Algoritma Thompson digunakan untuk\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Mengkonversi NFA ke DFA
        \item Mengkonversi regular expression ke NFA
        \item Minimisasi DFA
        \item Mensimulasikan DFA
    \end{enumerate}
    
    \item Mengapa DFA lebih efisien untuk simulasi dibanding NFA?
    \begin{enumerate}[label=\alph*.)]
        \item DFA lebih mudah dikonstruksi
        \item DFA tidak memiliki $\epsilon$-transition; setiap state tepat satu transition per input symbol
        \item NFA tidak dapat mengenali regular language
        \item DFA menggunakan lebih sedikit memori
    \end{enumerate}
    
    \item Operasi Kleene star (\texttt{*}) dalam regular expression menyatakan\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Satu atau lebih pengulangan
        \item Nol atau lebih pengulangan
        \item Tepat satu kemunculan
        \item Pilihan antara dua pattern
    \end{enumerate}
    
    \item Subset construction digunakan untuk\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Mengkonversi regular expression ke NFA
        \item Mengkonversi NFA ke DFA
        \item Minimisasi DFA
        \item Membangun lexical analyzer
    \end{enumerate}
    
    \item Pattern \texttt{[0-9]+} dalam regular expression cocok untuk\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Identifier
        \item Integer literal
        \item String literal
        \item Keyword
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 3: Implementasi Lexer (Hand-Written)}

\begin{enumerate}
    \item Keuntungan hand-written lexer dibanding lexer generator adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Lebih cepat dalam development
        \item Kontrol penuh dan pemahaman mendalam terhadap proses tokenization
        \item Kode yang dihasilkan lebih pendek
        \item Tidak perlu menangani edge case
    \end{enumerate}
    
    \item Proses utama yang dilakukan lexer adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Parsing struktur program
        \item Tokenization atau pengenalan token dari source code
        \item Type checking
        \item Code generation
    \end{enumerate}
    
    \item Komentar multi-line dalam C menggunakan\ldots
    \begin{enumerate}[label=\alph*.)]
        \item \texttt{//}
        \item \texttt{\#}
        \item \texttt{/* */}
        \item \texttt{--}
    \end{enumerate}
    
    \item Escape sequence \texttt{\textbackslash n} menyatakan\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Karakter backslash
        \item Karakter newline
        \item Karakter tab
        \item Karakter null
    \end{enumerate}
    
    \item Output dari lexer adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Parse tree
        \item Stream of tokens
        \item Symbol table
        \item Machine code
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 4: Lexer Generator (Flex/re2c)}

\begin{enumerate}
    \item File specification Flex memiliki ekstensi\ldots
    \begin{enumerate}[label=\alph*.)]
        \item \texttt{.y}
        \item \texttt{.l}
        \item \texttt{.c}
        \item \texttt{.flex}
    \end{enumerate}
    
    \item Bagian Rules dalam file Flex berisi\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Definisi makro dan C code
        \item Pasangan pattern--action (regular expression dan kode C)
        \item Fungsi \texttt{main()} dan \texttt{yywrap()}
        \item Deklarasi token
    \end{enumerate}
    
    \item Ketika beberapa pattern cocok dengan input, Flex memilih\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Pattern yang pertama didefinisikan
        \item Longest match
        \item Shortest match
        \item Pattern yang terakhir didefinisikan
    \end{enumerate}
    
    \item Tool re2c adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Parser generator
        \item Lexer generator untuk C/C++
        \item Optimizer
        \item Linker
    \end{enumerate}
    
    \item Keuntungan lexer generator dibanding hand-written lexer adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Kontrol lebih penuh atas implementasi
        \item Produktivitas lebih tinggi dan specification lebih mudah di-maintain
        \item Lebih cepat saat runtime
        \item Tidak memerlukan dependency eksternal
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 5: Context-Free Grammar dan Parsing}

\begin{enumerate}
    \item CFG \(G = (V, \Sigma, R, S)\): \(S\) menyatakan\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Himpunan terminal
        \item Himpunan nonterminal
        \item Start symbol
        \item Himpunan production
    \end{enumerate}
    
    \item Grammar disebut ambiguous jika\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Memiliki left recursion
        \item Memiliki lebih dari satu production untuk satu nonterminal
        \item Ada string yang dapat di-parse dengan lebih dari satu parse tree
        \item Memiliki $\epsilon$-production
    \end{enumerate}
    
    \item Eliminasi left recursion diperlukan agar grammar\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Dapat di-parse dengan bottom-up parser
        \item Dapat di-parse dengan recursive descent (top-down) parser
        \item Menjadi unambiguous
        \item Mendukung semua fitur bahasa
    \end{enumerate}
    
    \item Notasi BNF adalah singkatan dari\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Binary Normal Form
        \item Backus-Naur Form
        \item Boolean Notation Format
        \item Base Notation Form
    \end{enumerate}
    
    \item Fase kompilasi yang menggunakan CFG adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Lexical analysis
        \item Syntax analysis
        \item Semantic analysis
        \item Code optimization
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 6: Top-Down Parsing dan Recursive Descent}

\begin{enumerate}
    \item Top-down parsing membangun parse tree\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Dari leaves ke root
        \item Dari root (start symbol) ke leaves
        \item Secara paralel
        \item Dari tengah ke kedua ujung
    \end{enumerate}
    
    \item Recursive descent parser cocok untuk grammar\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Dengan left recursion
        \item LL(1) yang unambiguous
        \item LR(1) saja
        \item Yang ambiguous
    \end{enumerate}
    
    \item Dalam recursive descent, setiap nonterminal biasanya diimplementasikan sebagai\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Struct atau class
        \item Fungsi atau prosedur
        \item Macro
        \item Global variable
    \end{enumerate}
    
    \item Precedence operator dalam recursive descent untuk ekspresi aritmatika ditangani dengan\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Urutan aturan grammar (layering: expression $\to$ term $\to$ factor)
        \item Tabel lookup
        \item Register khusus
        \item Stack terpisah
    \end{enumerate}
    
    \item Top-down parsing menggunakan\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Rightmost derivation
        \item Leftmost derivation
        \item Bottom-up reduction
        \item Reverse derivation
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 7: Bottom-Up Parsing dan Parser Generator}

\begin{enumerate}
    \item Bottom-up parsing membangun parse tree\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Dari root ke leaves
        \item Dari leaves (input tokens) ke root (start symbol)
        \item Hanya untuk ekspresi
        \item Menggunakan recursive calls
    \end{enumerate}
    
    \item Operasi \textbf{reduce} dalam shift-reduce parsing berarti\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Memasukkan token ke stack
        \item Mengganti handle di stack dengan LHS production
        \item Mengeluarkan token dari stack
        \item Memindahkan pointer input
    \end{enumerate}
    
    \item LALR(1) parser merupakan pilihan populer karena\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Lebih powerful dari CLR(1)
        \item Tabel parsing lebih kecil daripada CLR(1) tapi tetap cukup powerful
        \item Tidak memerlukan lookahead
        \item Dapat menangani grammar ambiguous
    \end{enumerate}
    
    \item Bison adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Lexer generator
        \item Parser generator (implementasi GNU dari Yacc)
        \item Optimizer
        \item Assembler
    \end{enumerate}
    
    \item Handle dalam bottom-up parsing adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Simbol paling kiri yang akan di-expand
        \item Substring yang cocok dengan RHS production dan reduced menuju start symbol
        \item Lookahead token
        \item State awal parser
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 8: Parser Generator (Bison/Yacc) dan Praktikum}

\begin{enumerate}
    \item File grammar Bison biasanya berekstensi\ldots
    \begin{enumerate}[label=\alph*.)]
        \item \texttt{.l}
        \item \texttt{.y}
        \item \texttt{.lex}
        \item \texttt{.bnf}
    \end{enumerate}
    
    \item Semantic action dalam Bison berfungsi untuk\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Mendefinisikan token
        \item Membangun AST atau melakukan aksi saat production di-reduce
        \item Menangani error saja
        \item Mengatur precedence
    \end{enumerate}
    
    \item Integrasi Flex dan Bison: Flex menghasilkan\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Parser; Bison menghasilkan lexer
        \item Lexer; Bison menghasilkan parser
        \item Keduanya menghasilkan parser
        \item Keduanya menghasilkan lexer
    \end{enumerate}
    
    \item \%token dalam file Bison digunakan untuk\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Mendefinisikan nonterminal
        \item Mendeklarasikan token yang dikirim lexer
        \item Mendefinisikan semantic value
        \item Menentukan start symbol
    \end{enumerate}
    
    \item Bison default menggunakan\ldots
    \begin{enumerate}[label=\alph*.)]
        \item LR(0) parsing
        \item LALR(1) parsing
        \item SLR(1) parsing
        \item GLR parsing
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 9: Abstract Syntax Tree (AST)}

\begin{enumerate}
    \item Perbedaan utama AST dengan parse tree adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item AST lebih detail daripada parse tree
        \item AST menghilangkan detail sintaksis yang tidak relevan; lebih kompak
        \item Parse tree tidak memiliki root
        \item AST hanya untuk ekspresi
    \end{enumerate}
    
    \item Traversal \textbf{in-order} pada AST ekspresi \texttt{a + b} mengunjungi node dalam urutan\ldots
    \begin{enumerate}[label=\alph*.)]
        \item +, a, b
        \item a, +, b
        \item a, b, +
        \item +, b, a
    \end{enumerate}
    
    \item Visitor pattern biasanya digunakan untuk\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Mem-parse token
        \item Traverse dan memproses node AST (misalnya pretty-print, analisis)
        \item Generate lexer
        \item Allokasi register
    \end{enumerate}
    
    \item Constant folding pada AST mengubah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Variabel menjadi konstanta
        \item Ekspresi konstanta (mis. \texttt{3+5}) menjadi satu nilai (mis. \texttt{8})
        \item Semua node menjadi leaf
        \item AST menjadi parse tree
    \end{enumerate}
    
    \item AST digunakan sebagai input oleh\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Hanya lexical analyzer
        \item Semantic analysis dan code generation
        \item Hanya parser
        \item Hanya optimizer
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 10: Symbol Table dan Scope Management}

\begin{enumerate}
    \item Symbol table menyimpan informasi tentang\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Hanya keywords
        \item Identifier (variabel, fungsi, tipe) beserta atribut
        \item Hanya variabel global
        \item Hanya nama fungsi
    \end{enumerate}
    
    \item Nested scope biasanya diimplementasikan dengan\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Array linear
        \item Stack of hash tables (atau struktur serupa)
        \item Single global table
        \item Linked list tanpa hierarchy
    \end{enumerate}
    
    \item Shadowing terjadi ketika\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Variabel tidak dideklarasikan
        \item Identifier di inner scope menutupi identifier sama di outer scope
        \item Ada dua variabel dengan tipe berbeda
        \item Fungsi dipanggil dengan argumen salah
    \end{enumerate}
    
    \item Operasi \textbf{lookup} pada symbol table berarti\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Menambah entry baru
        \item Mencari identifier dan mengembalikan atributnya (jika ada)
        \item Menghapus scope
        \item Mendekomposisi tabel
    \end{enumerate}
    
    \item Symbol table digunakan oleh\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Hanya lexical analyzer
        \item Semantic analysis, type checker, dan code generator
        \item Hanya parser
        \item Hanya optimizer
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 11: Type Checking dan Semantic Analysis}

\begin{enumerate}
    \item Static type checking dilakukan\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Saat runtime
        \item Saat compile time
        \item Hanya untuk fungsi
        \item Hanya untuk variabel global
    \end{enumerate}
    
    \item Type promotion \texttt{int} $\to$ \texttt{float} berarti\ldots
    \begin{enumerate}[label=\alph*.)]
        \item float bisa di-assign ke int tanpa cast
        \item int bisa di-assign ke float (implicit conversion)
        \item int dan float tidak kompatibel
        \item Hanya explicit cast yang diperbolehkan
    \end{enumerate}
    
    \item Output semantic analysis biasanya berupa\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Token stream
        \item Annotated AST (dengan informasi tipe) dan daftar error semantik
        \item Machine code
        \item Parse tree mentah
    \end{enumerate}
    
    \item Contoh semantic error adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Token tidak valid
        \item Variabel tidak dideklarasikan, type mismatch, wrong number of arguments
        \item Kurung tidak seimbang
        \item Keyword salah eja
    \end{enumerate}
    
    \item Dynamic type checking biasanya digunakan oleh bahasa\ldots
    \begin{enumerate}[label=\alph*.)]
        \item C dan C++
        \item Python dan JavaScript (tanpa static typing)
        \item Rust
        \item Java
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 12: Intermediate Code Generation}

\begin{enumerate}
    \item Three-address code biasanya berbentuk\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Satu operasi per instruksi (mis. \texttt{t = a op b})
        \item Satu operand per instruksi
        \item Tree structure
        \item Bytecode stack-based
    \end{enumerate}
    
    \item IR (Intermediate Representation) bersifat machine-independent artinya\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Hanya untuk satu arsitektur
        \item Tidak tergantung arsitektur target; memungkinkan portabilitas
        \item Harus dioptimasi manual
        \item Tidak bisa diubah
    \end{enumerate}
    
    \item Common subexpression elimination adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Menghapus semua ekspresi
        \item Menggunakan hasil komputasi yang sama untuk ekspresi yang muncul berulang
        \item Mengganti variabel dengan konstanta
        \item Menghapus dead code
    \end{enumerate}
    
    \item Quadruples merepresentasikan instruksi dalam bentuk\ldots
    \begin{enumerate}[label=\alph*.)]
        \item (op, arg1, arg2, result)
        \item Hanya (op, result)
        \item Tree
        \item Daftar token
    \end{enumerate}
    
    \item Input generator TAC (three-address code) adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Token stream
        \item AST (biasanya hasil semantic analysis)
        \item Source code mentah
        \item Machine code
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 13: Runtime Environment dan Memory Management}

\begin{enumerate}
    \item Activation record (stack frame) digunakan untuk\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Menyimpan kode program
        \item Setiap pemanggilan fungsi: parameter, return address, variabel lokal
        \item Hanya variabel global
        \item Hanya konstanta
    \end{enumerate}
    
    \item Stack dalam memory layout biasanya tumbuh\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Ke atas (low $\to$ high address)
        \item Ke bawah (high $\to$ low address)
        \item Secara acak
        \item Hanya untuk heap
    \end{enumerate}
    
    \item Variabel global dan static biasanya dialokasikan di\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Stack
        \item Heap
        \item Static/global data region
        \item Register saja
    \end{enumerate}
    
    \item Garbage collection umumnya mengelola\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Stack frame
        \item Objek di heap yang tidak lagi direferensi
        \item Variabel lokal
        \item Kode program
    \end{enumerate}
    
    \item Calling convention mengatur\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Hanya urutan parameter
        \item Cara mem-pass parameter, return value, siapa membersihkan stack
        \item Hanya return value
        \item Hanya alokasi heap
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 14: Code Generation}

\begin{enumerate}
    \item Instruction selection adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Memilih instruksi mesin untuk setiap operasi IR
        \item Memilih register saja
        \item Memilih optimasi
        \item Memilih target OS
    \end{enumerate}
    
    \item Register allocation bertujuan\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Mengurangi jumlah instruksi
        \item Memetakan variabel/temporary ke register (atau memory jika perlu)
        \item Hanya menggunakan stack
        \item Menghapus label
    \end{enumerate}
    
    \item RISC-V adalah contoh\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Lexer generator
        \item Instruction set architecture (ISA) / arsitektur target
        \item Format IR
        \item Optimizer
    \end{enumerate}
    
    \item Input code generator biasanya\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Token stream
        \item IR (mis. TAC), symbol table, spesifikasi target
        \item Hanya source code
        \item Hanya AST tanpa IR
    \end{enumerate}
    
    \item Output code generator dapat berupa\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Hanya binary
        \item Assembly code atau machine code
        \item Hanya AST
        \item Hanya symbol table
    \end{enumerate}
\end{enumerate}

\subsection{Quiz Bab 15: Optimasi Kompilator Dasar}

\begin{enumerate}
    \item Optimasi kompilator tidak boleh\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Mengubah semantik program
        \item Mengurangi ukuran kode
        \item Meningkatkan kecepatan eksekusi
        \item Melakukan constant folding
    \end{enumerate}
    
    \item Constant folding mengubah \texttt{x = 3 + 5} menjadi\ldots
    \begin{enumerate}[label=\alph*.)]
        \item \texttt{x = 3 + 5}
        \item \texttt{x = 8}
        \item Menghapus seluruh baris
        \item \texttt{x = 35}
    \end{enumerate}
    
    \item Dead code elimination menghapus\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Semua konstanta
        \item Kode yang tidak pernah dieksekusi atau hasilnya tidak dipakai
        \item Semua komentar
        \item Semua label
    \end{enumerate}
    
    \item Basic block adalah\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Seluruh program
        \item Urutan instruksi dengan satu entry, satu exit, tidak ada branch di tengah
        \item Hanya satu instruksi
        \item Hanya loop
    \end{enumerate}
    
    \item Constant propagation mengganti\ldots
    \begin{enumerate}[label=\alph*.)]
        \item Semua variabel dengan konstanta
        \item Penggunaan variabel yang nilainya diketahui konstan dengan nilai tersebut
        \item Semua operator
        \item Semua label
    \end{enumerate}
\end{enumerate}