\section{Implementasi Parser}

Parser bertugas menganalisis token stream dan membangun Abstract Syntax Tree (AST). Untuk compiler sederhana kita, kita akan menggunakan recursive descent parser.

\subsection{Grammar Sederhana}

Grammar untuk print statement:
\begin{verbatim}
program    → print_stmt
print_stmt  → PRINT LPAREN STRING RPAREN SEMICOLON
\end{verbatim}

Grammar ini sangat sederhana karena kita hanya mendukung satu jenis statement: print statement.

\subsection{Struktur AST}

AST untuk compiler sederhana kita hanya perlu menyimpan informasi tentang print statement:

\begin{lstlisting}[language=C, caption={Struktur AST dalam parser.h}]
#ifndef PARSER_H
#define PARSER_H

#include "lexer.h"

typedef struct ASTNode {
    enum {
        AST_PRINT_STMT
    } type;
    
    union {
        struct {
            char* string_value;  // String yang akan di-print
        } print_stmt;
    } data;
} ASTNode;

// Fungsi-fungsi parser
ASTNode* parse(void);
void freeAST(ASTNode* node);
void printAST(ASTNode* node);

#endif
\end{lstlisting}

\subsection{Implementasi Parser}

Berikut adalah implementasi parser recursive descent:

\begin{lstlisting}[language=C, caption={Implementasi parser.c}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "parser.h"
#include "lexer.h"

static Token currentToken;

static void advance(void) {
    currentToken = nextToken();
}

static void expect(TokenType expected) {
    if (currentToken.type != expected) {
        fprintf(stderr, "Parse error at line %d, column %d: ", 
                currentToken.line, currentToken.column);
        fprintf(stderr, "Expected token type %d, got %d\n", 
                expected, currentToken.type);
        exit(1);
    }
    advance();
}

ASTNode* parsePrintStmt(void) {
    ASTNode* node = (ASTNode*)malloc(sizeof(ASTNode));
    node->type = AST_PRINT_STMT;
    
    // Expect PRINT keyword
    expect(TOKEN_PRINT);
    
    // Expect LPAREN
    expect(TOKEN_LPAREN);
    
    // Expect STRING literal
    if (currentToken.type != TOKEN_STRING) {
        fprintf(stderr, "Parse error: Expected string literal\n");
        exit(1);
    }
    
    // Copy string value
    node->data.print_stmt.string_value = 
        (char*)malloc(strlen(currentToken.value) + 1);
    strcpy(node->data.print_stmt.string_value, currentToken.value);
    
    advance(); // Consume STRING token
    
    // Expect RPAREN
    expect(TOKEN_RPAREN);
    
    // Expect SEMICOLON
    expect(TOKEN_SEMICOLON);
    
    return node;
}

ASTNode* parse(void) {
    // Initialize lexer (should be done before calling parse)
    advance(); // Get first token
    
    // Parse print statement
    ASTNode* node = parsePrintStmt();
    
    // Expect EOF
    if (currentToken.type != TOKEN_EOF) {
        fprintf(stderr, "Parse error: Expected EOF\n");
        exit(1);
    }
    
    return node;
}

void freeAST(ASTNode* node) {
    if (node == NULL) return;
    
    switch (node->type) {
        case AST_PRINT_STMT:
            if (node->data.print_stmt.string_value != NULL) {
                free(node->data.print_stmt.string_value);
            }
            break;
    }
    
    free(node);
}

void printAST(ASTNode* node) {
    if (node == NULL) return;
    
    switch (node->type) {
        case AST_PRINT_STMT:
            printf("PrintStmt(\"%s\")\n", 
                   node->data.print_stmt.string_value);
            break;
    }
}
\end{lstlisting}

\subsection{Error Handling}

Parser melakukan error handling dengan:
\begin{itemize}
    \item Memeriksa token yang diharapkan dengan fungsi \texttt{expect()}
    \item Menampilkan pesan error yang jelas dengan informasi line dan column
    \item Menghentikan parsing jika terjadi error (untuk compiler sederhana)
\end{itemize}

\subsection{Contoh Penggunaan Parser}

Berikut adalah contoh penggunaan parser:

\begin{lstlisting}[language=C, caption={Contoh penggunaan parser}]
#include "parser.h"
#include "lexer.h"
#include <stdio.h>

int main() {
    const char* source = "print(\"hello world !!!\");";
    
    // Initialize lexer
    initLexer(source);
    
    // Parse
    ASTNode* ast = parse();
    
    // Print AST
    printf("AST:\n");
    printAST(ast);
    
    // Cleanup
    freeAST(ast);
    freeLexer();
    
    return 0;
}
\end{lstlisting}

Output:
\begin{verbatim}
AST:
PrintStmt("hello world !!!")
\end{verbatim}

\subsection{Visualisasi AST}

AST untuk program \texttt{print("hello world !!!");} dapat divisualisasikan sebagai:

\begin{figure}[!htbp]
    \centering
    \adjustbox{max width=0.6\textwidth,center}{%
    \begin{tikzpicture}[
        node/.style={rectangle, draw=blue!50, fill=blue!10, text width=3cm, text centered, minimum height=0.8cm, rounded corners, font=\footnotesize},
        leaf/.style={rectangle, draw=green!50, fill=green!10, text width=4cm, text centered, minimum height=0.6cm, rounded corners, font=\tiny},
        arrow/.style={->, >=stealth, thick}
    ]
    
    \node[node] (root) {PrintStmt};
    \node[leaf, below=0.5cm of root] (string) {"hello world !!!"};
    
    \draw[arrow] (root) -- (string);
    
    \end{tikzpicture}%
    }
    \caption{AST untuk print statement}
    \label{fig:ast-print}
\end{figure}

\subsection{Testing Parser}

Untuk menguji parser, buatlah file test:

\begin{lstlisting}[language=C, caption={test_parser.c}]
#include "parser.h"
#include "lexer.h"
#include <stdio.h>
#include <assert.h>
#include <string.h>

void testParser() {
    const char* source = "print(\"hello world !!!\");";
    
    initLexer(source);
    ASTNode* ast = parse();
    
    assert(ast != NULL);
    assert(ast->type == AST_PRINT_STMT);
    assert(strcmp(ast->data.print_stmt.string_value, 
                  "hello world !!!") == 0);
    
    printf("Parser test passed!\n");
    
    freeAST(ast);
    freeLexer();
}

int main() {
    testParser();
    return 0;
}
\end{lstlisting}

Parser sudah siap untuk tahap berikutnya: code generation.
