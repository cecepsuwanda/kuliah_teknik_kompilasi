% Bab 2: Regular Expression dan Finite Automata untuk Lexical Analysis
% File ini dapat dikompilasi terpisah atau sebagai bagian dari main.tex

\chapter[Regular Expression dan Finite Automata]{Regular Expression dan Finite Automata\\untuk Lexical Analysis}
\label{chap:regex-fa}

\section{Tujuan Pembelajaran}

Setelah mempelajari bab ini, mahasiswa diharapkan mampu:
\begin{enumerate}
    \item Memahami konsep regular expression dan regular language
    \item Menjelaskan perbedaan antara NFA (Nondeterministic Finite Automata) dan DFA (Deterministic Finite Automata)
    \item Mengkonversi regular expression ke NFA menggunakan algoritma Thompson
    \item Mengkonversi NFA ke DFA menggunakan subset construction
    \item Mengimplementasikan NFA dan DFA sederhana dalam C/C++
    \item Membuat recognizer untuk pattern token sederhana menggunakan finite automata
    \item Memahami hubungan antara regular expression, finite automata, dan lexical analysis
\end{enumerate}

\section{Pendahuluan}

Sebagai landasan untuk memahami lexical analysis, kita perlu mempelajari teori formal yang mendasarinya. Menurut sumber dari Aoyama Gakuin University:

\begin{quote}
``Lexical analysis breaks input text into lexemes which correspond to tokens. Usually implemented using regular languages → regex → NFA → DFA → (minimized) DFA for efficiency.''\cite{aoyama2024lexical}
\end{quote}

Alur ini menunjukkan bahwa lexical analysis dalam kompilator modern menggunakan teori formal language, khususnya regular languages, yang direpresentasikan sebagai regular expressions dan kemudian diimplementasikan sebagai finite automata untuk efisiensi.

\section{Regular Expression dan Regular Language}

\subsection{Definisi Regular Expression}

Regular expression (regex) adalah notasi formal untuk mendeskripsikan pola string dalam suatu bahasa. Regular expression menggunakan operasi-operasi dasar untuk membangun pattern yang lebih kompleks.

Operasi-operasi dasar dalam regular expression meliputi:

\begin{enumerate}
    \item \textbf{Literal}: Karakter tunggal, misalnya \texttt{a} mencocokkan string ``a''
    \item \textbf{Concatenation}: Penggabungan, misalnya \texttt{ab} mencocokkan string ``ab''
    \item \textbf{Union/Alternation}: Pilihan, misalnya \texttt{a|b} mencocokkan ``a'' atau ``b''
    \item \textbf{Kleene Star}: Nol atau lebih pengulangan, misalnya \texttt{a*} mencocokkan ``'', ``a'', ``aa'', ``aaa'', dll.
    \item \textbf{Kleene Plus}: Satu atau lebih pengulangan, misalnya \texttt{a+} mencocokkan ``a'', ``aa'', ``aaa'', dll.
    \item \textbf{Optional}: Nol atau satu, misalnya \texttt{a?} mencocokkan ``'' atau ``a''
    \item \textbf{Character Class}: Set karakter, misalnya \texttt{[0-9]} mencocokkan digit 0-9
\end{enumerate}

\subsection{Contoh Regular Expression untuk Token}

Dalam lexical analysis, setiap jenis token didefinisikan menggunakan regular expression. Berikut beberapa contoh:

\begin{itemize}
    \item \textbf{Identifier}: \texttt{[a-zA-Z\_][a-zA-Z0-9\_]*}
    \begin{itemize}
        \item Dimulai dengan huruf atau underscore
        \item Diikuti oleh nol atau lebih huruf, digit, atau underscore
    \end{itemize}
    
    \item \textbf{Integer Literal}: \texttt{[0-9]+}
    \begin{itemize}
        \item Satu atau lebih digit
    \end{itemize}
    
    \item \textbf{Floating Point}: \texttt{[0-9]+\textbackslash.[0-9]+}
    \begin{itemize}
        \item Digit, titik desimal, digit
    \end{itemize}
    
    \item \textbf{String Literal}: \texttt{"([\textasciicircum"\\]|\textbackslash\textbackslash.)*"}
    \begin{itemize}
        \item Dimulai dan diakhiri dengan tanda kutip
        \item Berisi karakter apapun kecuali tanda kutip (atau escape sequence)
    \end{itemize}
    
    \item \textbf{Whitespace}: \texttt{[ \textbackslash t\textbackslash n]+}
    \begin{itemize}
        \item Satu atau lebih spasi, tab, atau newline
    \end{itemize}
    
    \item \textbf{Operator}: \texttt{+|-|*|/|=|==|!=}
    \begin{itemize}
        \item Operator aritmatika dan perbandingan
    \end{itemize}
\end{itemize}

\subsection{Regular Language}

Bahasa yang dapat dinyatakan dengan regular expression disebut \textbf{regular language}. Regular language memiliki sifat-sifat penting:

\begin{itemize}
    \item Dapat dikenali oleh finite automata (NFA atau DFA)
    \item Tertutup terhadap operasi union, concatenation, dan Kleene star
    \item Tidak dapat mengekspresikan struktur nested (seperti matching parentheses)
    \item Cukup untuk mendeskripsikan sebagian besar token dalam bahasa pemrograman
\end{itemize}

\section{Finite Automata}

Finite automata adalah model matematika yang digunakan untuk mengenali string dalam suatu bahasa. Terdapat dua jenis utama: NFA (Nondeterministic Finite Automata) dan DFA (Deterministic Finite Automata).

\subsection{Definisi Formal}

\textbf{Finite Automaton} didefinisikan sebagai tuple $(Q, \Sigma, \delta, q_0, F)$ dimana:
\begin{itemize}
    \item $Q$: Himpunan state (keadaan) yang terbatas
    \item $\Sigma$: Alphabet (himpunan simbol input)
    \item $\delta$: Fungsi transisi (transition function)
    \item $q_0$: Start state (state awal)
    \item $F$: Himpunan accept states (final states)
\end{itemize}

\subsection{NFA (Nondeterministic Finite Automata)}

NFA memiliki karakteristik:
\begin{itemize}
    \item Untuk suatu state dan input symbol, dapat memiliki \textbf{nol, satu, atau lebih} transisi
    \item Dapat memiliki \textbf{$\epsilon$-transitions} (epsilon transitions) yang tidak mengonsumsi input
    \item Lebih mudah dikonstruksi dari regular expression
    \item Simulasi memerlukan backtracking atau multiple states tracking
\end{itemize}

Contoh NFA untuk pattern \texttt{a|b}:

\begin{verbatim}
        eps
    +-------+
    |   q0  |
    +---+----+
        |
    +----+---+
    |       |
    a       b
    |       |
    v       v
  [q1]    [q2]
\end{verbatim}

State q0 adalah start state, q1 dan q2 adalah accept states. Dari q0, dengan input 'a' dapat menuju q1, dengan input 'b' dapat menuju q2.

\subsection{DFA (Deterministic Finite Automata)}

DFA memiliki karakteristik:
\begin{itemize}
    \item Untuk setiap state dan input symbol, terdapat \textbf{tepat satu} transisi
    \item Tidak memiliki $\epsilon$-transitions
    \item Lebih efisien untuk simulasi (deterministic)
    \item Setiap NFA dapat dikonversi menjadi DFA yang ekuivalen
\end{itemize}

Contoh DFA untuk pattern \texttt{a|b}:

\begin{verbatim}
        a
    +-------+
    |   q0  |---+
    +---+----+   |
        |       | b
        |       |
        v       v
      [q1]    [q2]
\end{verbatim}

DFA ini deterministik: dari q0, input 'a' selalu menuju q1, input 'b' selalu menuju q2.

\subsection{Perbedaan NFA dan DFA}

Perbedaan utama antara NFA dan DFA:

\begin{table}[H]
\centering
\begin{tabular}{|l|p{5.5cm}|p{5.5cm}|}
\hline
\textbf{Aspek} & \textbf{NFA} & \textbf{DFA} \\
\hline
Transisi per state & Bisa 0, 1, atau lebih & Tepat 1 \\
\hline
$\epsilon$-transitions & Diizinkan & Tidak diizinkan \\
\hline
Efisiensi simulasi & Perlu backtracking & Linear time \\
\hline
Jumlah states & Biasanya lebih sedikit & Bisa lebih banyak \\
\hline
Konstruksi dari regex & Lebih mudah & Lebih kompleks \\
\hline
\end{tabular}
\caption{Perbandingan NFA dan DFA}
\label{tab:nfa-dfa}
\end{table}

\section{Konversi Regular Expression ke NFA: Algoritma Thompson}

Algoritma Thompson adalah metode sistematis untuk mengkonversi regular expression menjadi $\epsilon$-NFA. Algoritma ini menggunakan pendekatan rekursif dengan template untuk setiap operasi regex.

\subsection{Template Dasar}

\subsubsection{Literal (Karakter Tunggal)}

Untuk regex \texttt{a}, NFA-nya adalah:

\begin{verbatim}
    +---+  a   +---+
    |q0 |---→|q1 |
    +---+     +---+
\end{verbatim}

\subsubsection{Concatenation (RS)}

Untuk regex \texttt{RS}, NFA-nya dibangun dengan menghubungkan NFA untuk R dan S:

\begin{verbatim}
    [NFA untuk R] -$\epsilon$→ [NFA untuk S]
\end{verbatim}

\subsubsection{Union (R|S)}

Untuk regex \texttt{R|S}, NFA-nya menggunakan $\epsilon$-transitions untuk branching:

\begin{verbatim}
        +---+
        |q0 |
        +-+--+
      +----+---+
      |       |
      $\epsilon$       $\epsilon$
      |       |
      v       v
  [NFA R] [NFA S]
      |       |
      $\epsilon$       $\epsilon$
      |       |
      +---+----+
          v
        [q_f]
\end{verbatim}

\subsubsection{Kleene Star (R*)}

Untuk regex \texttt{R*}, NFA-nya memiliki loop dengan $\epsilon$-transitions:

\begin{verbatim}
    +---+
    |q0 |
    +-+--+
      |
      $\epsilon$
      |
      v
  +-------+
  |       |
  |  NFA  |
  |   R   |
  |       |
  +---+----+
      |
      $\epsilon$
      |
      v
    [q_f]←--+
      |     |
      +-$\epsilon$---+
\end{verbatim}

\subsection{Contoh: Konversi \texttt{(a|b)*abb}}

Mari kita konstruksi NFA untuk regex \texttt{(a|b)*abb} menggunakan algoritma Thompson:

\begin{enumerate}
    \item \textbf{Literal 'a' dan 'b'}: Buat NFA untuk masing-masing
    \item \textbf{Union (a|b)}: Gabungkan dengan $\epsilon$-transitions
    \item \textbf{Kleene Star ((a|b)*)}: Tambahkan loop dengan $\epsilon$-transitions
    \item \textbf{Concatenation dengan 'a'}: Tambahkan NFA untuk 'a'
    \item \textbf{Concatenation dengan 'b'}: Tambahkan NFA untuk 'b' (dua kali)
\end{enumerate}

Hasil akhirnya adalah NFA yang dapat mengenali string seperti ``abb'', ``aabb'', ``babb'', ``ababb'', dll.

\section{Konversi NFA ke DFA: Subset Construction}

Karena NFA tidak deterministik dan simulasi NFA bisa tidak efisien, kita perlu mengkonversi NFA menjadi DFA yang ekuivalen menggunakan algoritma \textbf{subset construction}.

\subsection{Konsep \texorpdfstring{$\epsilon$}{epsilon}-Closure}

Sebelum subset construction, kita perlu memahami konsep \textbf{$\epsilon$-closure}:

\begin{itemize}
    \item \textbf{$\epsilon$-closure} dari suatu state adalah himpunan semua state yang dapat dicapai dari state tersebut melalui $\epsilon$-transitions saja
    \item \textbf{$\epsilon$-closure} dari suatu set states adalah union dari $\epsilon$-closure setiap state dalam set tersebut
\end{itemize}

\subsection{Algoritma Subset Construction}

Algoritma subset construction bekerja sebagai berikut:

\begin{enumerate}
    \item \textbf{Start State DFA}: $\epsilon$-closure dari start state NFA
    \item \textbf{Untuk setiap state DFA dan setiap input symbol}:
    \begin{enumerate}
        \item Hitung semua NFA states yang dapat dicapai dengan input symbol tersebut
        \item Ambil $\epsilon$-closure dari set states tersebut
        \item Jika hasilnya belum ada sebagai state DFA, buat state baru
        \item Tambahkan transisi dari state DFA saat ini ke state hasil
    \end{enumerate}
    \item \textbf{Accept States DFA}: Setiap state DFA yang mengandung accept state NFA
\end{enumerate}

\subsection{Contoh: Konversi NFA \texttt{(a|b)*abb} ke DFA}

Mari kita ikuti langkah-langkah subset construction:

\begin{enumerate}
    \item \textbf{Start State DFA}: 
    \begin{itemize}
        \item Mulai dari start state NFA, ambil $\epsilon$-closure
        \item Misalkan hasilnya adalah set $\{q_0, q_1, q_2\}$ → ini menjadi state DFA $A$
    \end{itemize}
    
    \item \textbf{Transisi dari State A dengan input 'a'}:
    \begin{itemize}
        \item Dari semua NFA states dalam A, cari yang dapat menerima 'a'
        \item Ambil $\epsilon$-closure dari hasilnya → misalkan $\{q_3, q_4\}$ → state DFA $B$
    \end{itemize}
    
    \item \textbf{Transisi dari State A dengan input 'b'}:
    \begin{itemize}
        \item Dari semua NFA states dalam A, cari yang dapat menerima 'b'
        \item Ambil $\epsilon$-closure dari hasilnya → misalkan $\{q_5\}$ → state DFA $C$
    \end{itemize}
    
    \item \textbf{Lanjutkan untuk state B dan C} dengan cara yang sama
    \item \textbf{Accept States}: State DFA yang mengandung accept state NFA
\end{enumerate}

Hasilnya adalah DFA yang ekuivalen dengan NFA asli, tetapi deterministik dan lebih efisien untuk simulasi.

\section{Implementasi NFA dan DFA dalam C/C++}

Untuk memahami konsep secara praktis, kita akan melihat struktur data dan algoritma dasar untuk mengimplementasikan NFA dan DFA.

\subsection{Struktur Data NFA}

\begin{lstlisting}[language=C++, caption={Struktur Data untuk NFA}]
#include <vector>
#include <set>
#include <map>

struct NFATransition {
    int from_state;
    char symbol;  // '\0' untuk epsilon transition
    int to_state;
};

class NFA {
private:
    int num_states;
    int start_state;
    std::set<int> accept_states;
    std::vector<NFATransition> transitions;
    
public:
    // Konstruktor
    NFA(int states, int start);
    
    // Menambahkan transisi
    void addTransition(int from, char symbol, int to);
    
    // Menghitung epsilon closure
    std::set<int> epsilonClosure(const std::set<int>& states);
    
    // Simulasi NFA
    bool simulate(const std::string& input);
};
\end{lstlisting}

\subsection{Struktur Data DFA}

\begin{lstlisting}[language=C++, caption={Struktur Data untuk DFA}]
class DFA {
private:
    int num_states;
    int start_state;
    std::set<int> accept_states;
    std::map<std::pair<int, char>, int> transition_table;
    
public:
    // Konstruktor
    DFA(int states, int start);
    
    // Menambahkan transisi (deterministic)
    void addTransition(int from, char symbol, int to);
    
    // Simulasi DFA (lebih sederhana dari NFA)
    bool simulate(const std::string& input);
};
\end{lstlisting}

\subsection{Implementasi Simulasi DFA}

Simulasi DFA lebih sederhana karena deterministik:

\begin{lstlisting}[language=C++, caption={Simulasi DFA}]
bool DFA::simulate(const std::string& input) {
    int current_state = start_state;
    
    for (char c : input) {
        auto key = std::make_pair(current_state, c);
        if (transition_table.find(key) == transition_table.end()) {
            return false;  // Tidak ada transisi
        }
        current_state = transition_table[key];
    }
    
    return accept_states.find(current_state) != accept_states.end();
}
\end{lstlisting}

\subsection{Implementasi Subset Construction}

Berikut adalah pseudocode untuk subset construction:

\begin{lstlisting}[language=C++, caption={Subset Construction Algorithm}]
DFA NFA::toDFA() {
    DFA dfa(0, 0);
    std::map<std::set<int>, int> state_mapping;
    std::queue<std::set<int>> work_queue;
    
    // Start state DFA = epsilon closure dari start state NFA
    std::set<int> start_set = epsilonClosure({start_state});
    int dfa_start = dfa.addState();
    state_mapping[start_set] = dfa_start;
    work_queue.push(start_set);
    
    while (!work_queue.empty()) {
        std::set<int> nfa_states = work_queue.front();
        work_queue.pop();
        int dfa_state = state_mapping[nfa_states];
        
        // Untuk setiap input symbol
        for (char symbol : alphabet) {
            if (symbol == '\0') continue;  // Skip epsilon
            
            // Hitung move dengan symbol
            std::set<int> next_nfa_states;
            for (int state : nfa_states) {
                // Cari semua transisi dengan symbol ini
                for (auto& trans : transitions) {
                    if (trans.from_state == state && 
                        trans.symbol == symbol) {
                        next_nfa_states.insert(trans.to_state);
                    }
                }
            }
            
            // Ambil epsilon closure
            std::set<int> closure = epsilonClosure(next_nfa_states);
            
            if (!closure.empty()) {
                int next_dfa_state;
                if (state_mapping.find(closure) == state_mapping.end()) {
                    // State baru
                    next_dfa_state = dfa.addState();
                    state_mapping[closure] = next_dfa_state;
                    work_queue.push(closure);
                } else {
                    next_dfa_state = state_mapping[closure];
                }
                
                dfa.addTransition(dfa_state, symbol, next_dfa_state);
            }
        }
    }
    
    // Set accept states
    for (auto& pair : state_mapping) {
        for (int nfa_accept : accept_states) {
            if (pair.first.find(nfa_accept) != pair.first.end()) {
                dfa.setAcceptState(pair.second);
                break;
            }
        }
    }
    
    return dfa;
}
\end{lstlisting}

\section{Aplikasi dalam Lexical Analysis}

\subsection{Token Recognition dengan DFA}

Dalam lexical analysis, kita menggunakan DFA untuk mengenali token. Prosesnya:

\begin{enumerate}
    \item \textbf{Definisi Token}: Setiap jenis token didefinisikan dengan regular expression
    \item \textbf{Kombinasi Regex}: Semua regex untuk token digabungkan dengan union
    \item \textbf{Konversi ke DFA}: Regex gabungan dikonversi menjadi satu DFA
    \item \textbf{Scanning}: Input dibaca karakter demi karakter, DFA dijalankan
    \item \textbf{Longest Match}: Ambil token terpanjang yang cocok
    \item \textbf{Token Classification}: Tentukan jenis token berdasarkan accept state yang dicapai
\end{enumerate}

\subsection{Contoh: Recognizer untuk Identifier dan Number}

Mari kita buat recognizer sederhana untuk identifier dan number:

\begin{lstlisting}[language=C++, caption={Token Recognizer menggunakan DFA}]
enum TokenType {
    IDENTIFIER,
    NUMBER,
    UNKNOWN
};

class TokenRecognizer {
private:
    DFA identifier_dfa;  // DFA untuk [a-zA-Z_][a-zA-Z0-9_]*
    DFA number_dfa;      // DFA untuk [0-9]+
    
public:
    TokenRecognizer() {
        // Konstruksi DFA untuk identifier dan number
        // (dari regex menggunakan Thompson + subset construction)
    }
    
    TokenType recognize(const std::string& lexeme) {
        if (identifier_dfa.simulate(lexeme)) {
            return IDENTIFIER;
        } else if (number_dfa.simulate(lexeme)) {
            return NUMBER;
        } else {
            return UNKNOWN;
        }
    }
};
\end{lstlisting}

\subsection{Handling Multiple Tokens}

Ketika kita memiliki multiple token types, kita perlu:

\begin{enumerate}
    \item Membuat NFA terpisah untuk setiap token type
    \item Menggabungkan semua NFA dengan union, tetapi \textbf{label setiap accept state} dengan token type-nya
    \item Konversi ke DFA (setiap DFA state mungkin mengandung multiple NFA accept states dengan label berbeda)
    \item Saat scanning, jika mencapai accept state dengan multiple labels, gunakan \textbf{priority} atau \textbf{longest match}
\end{enumerate}

\section{Optimasi: DFA Minimization}

Setelah subset construction, DFA yang dihasilkan mungkin memiliki states yang redundan. Kita dapat meminimalkan DFA menggunakan algoritma seperti \textbf{Hopcroft's algorithm} atau \textbf{Moore's algorithm}.

\subsection{Konsep State Equivalence}

Dua states dalam DFA dikatakan \textbf{equivalent} jika:
\begin{itemize}
    \item Keduanya accept states ATAU keduanya bukan accept states
    \item Untuk setiap input symbol, transisi dari kedua states menuju ke states yang equivalent
\end{itemize}

\subsection{Algoritma Minimization}

Algoritma minimisasi bekerja dengan:
\begin{enumerate}
    \item Partisi states menjadi dua grup: accept states dan non-accept states
    \item Untuk setiap partisi, periksa apakah states dalam partisi tersebut equivalent
    \item Jika tidak equivalent, pisahkan menjadi partisi baru
    \item Ulangi sampai tidak ada partisi yang dapat dipisah lagi
    \item Merge states dalam partisi yang sama
\end{enumerate}

DFA yang sudah diminimalkan memiliki jumlah states minimum yang masih ekuivalen dengan DFA asli.

\section{Kesimpulan}

Dalam bab ini, kita telah mempelajari:

\begin{enumerate}
    \item Regular expression adalah notasi formal untuk mendeskripsikan pola token
    \item Finite automata (NFA dan DFA) adalah model matematika untuk mengenali regular language
    \item Algoritma Thompson mengkonversi regular expression menjadi $\epsilon$-NFA
    \item Subset construction mengkonversi NFA menjadi DFA yang ekuivalen
    \item DFA lebih efisien untuk simulasi dan digunakan dalam lexical analysis
    \item Implementasi praktis memerlukan struktur data yang tepat dan algoritma yang efisien
\end{enumerate}

Pemahaman tentang regular expression dan finite automata ini menjadi dasar penting untuk implementasi lexical analyzer yang akan dipelajari dalam bab-bab selanjutnya.

\section{Latihan}

\begin{enumerate}
    \item Buatlah regular expression untuk:
    \begin{itemize}
        \item Email address sederhana (format: \texttt{user@domain.com})
        \item Phone number (format: \texttt{+62-812-3456-7890})
        \item C-style comment (\texttt{/* ... */})
    \end{itemize}
    
    \item Konstruksi NFA untuk regular expression berikut menggunakan algoritma Thompson:
    \begin{itemize}
        \item \texttt{a*b+}
        \item \texttt{(a|b)*ab}
        \item \texttt{[0-9]+(\textbackslash.[0-9]+)?}
    \end{itemize}
    
    \item Konversi NFA dari soal nomor 2 menjadi DFA menggunakan subset construction. Gambarkan state diagram untuk DFA yang dihasilkan.
    
    \item Implementasikan kelas \texttt{NFA} dan \texttt{DFA} dalam C++ dengan fungsi:
    \begin{itemize}
        \item Konstruksi NFA dari regular expression (sederhana)
        \item Konversi NFA ke DFA
        \item Simulasi DFA untuk string input
    \end{itemize}
    
    \item Buat program recognizer yang dapat mengenali token-token berikut:
    \begin{itemize}
        \item Identifier: \texttt{[a-zA-Z\_][a-zA-Z0-9\_]*}
        \item Integer: \texttt{[0-9]+}
        \item Float: \texttt{[0-9]+\textbackslash.[0-9]+}
        \item Operator: \texttt{+|-|*|/|=|==|!=}
    \end{itemize}
    
    \item Jelaskan mengapa DFA lebih efisien untuk simulasi dibanding NFA. Berikan contoh kompleksitas waktu untuk keduanya.
    
    \item Implementasikan algoritma minimisasi DFA (dapat menggunakan versi sederhana). Uji dengan DFA yang dihasilkan dari soal nomor 3.
\end{enumerate}

\section{Referensi dan Bahan Bacaan Lanjutan}

Untuk memperdalam pemahaman tentang regular expression dan finite automata, mahasiswa disarankan membaca:

\begin{itemize}
    \item \textbf{Dragon Book}: Aho, Lam, Sethi, \& Ullman (2006). \textit{Compilers: Principles, Techniques, and Tools} \cite{aho2006compilers} - Bab 3: Lexical Analysis
    
    \item \textbf{Engineering a Compiler}: Cooper \& Torczon (2011) \cite{cooper2011engineering} - Bab 2: Scanners
    
    \item \textbf{Aoyama Gakuin University}: Lecture notes tentang lexical analysis dan finite automata \cite{aoyama2024lexical}
    
    \item \textbf{OpenGenus}: Tutorial tentang membangun lexer \cite{opengenus2024lexer}
    
    \item \textbf{GeeksforGeeks}: Artikel tentang regular expression to NFA dan NFA to DFA conversion
\end{itemize}
