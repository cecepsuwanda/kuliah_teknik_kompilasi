% Bab 15: Optimasi Kompilator Dasar
% File ini dapat dikompilasi terpisah atau sebagai bagian dari main.tex

\chapter{Optimasi Kompilator Dasar}
\label{chap:optimization}

\section{Tujuan Pembelajaran}

Setelah mempelajari bab ini, mahasiswa diharapkan mampu:
\begin{enumerate}
    \item Memahami konsep optimasi kompilator dan tujuannya
    \item Menjelaskan dan mengidentifikasi basic blocks dalam intermediate code
    \item Mengimplementasikan optimasi lokal: constant folding dan constant propagation
    \item Mengimplementasikan dead code elimination
    \item Memahami dasar-dasar data-flow analysis untuk optimasi global
    \item Mengevaluasi efektivitas optimasi dengan membandingkan before/after
    \item Membedakan machine-independent dan machine-specific optimizations
\end{enumerate}

\section{Pengenalan Optimasi Kompilator}

Optimasi kompilator adalah proses transformasi kode intermediate untuk meningkatkan kualitas kode yang dihasilkan tanpa mengubah semantik program. Menurut sumber dari Scribd OBE CSE Document:

\begin{quote}
``Perform machine-independent optimizations (basic block optimizations, data-flow analysis). Local and global optimization; data-flow analysis.''\cite{aho2006compilers}
\end{quote}

Tujuan optimasi kompilator meliputi:
\begin{itemize}
    \item \textbf{Meningkatkan Performa}: Mengurangi waktu eksekusi program
    \item \textbf{Mengurangi Ukuran Kode}: Menghasilkan executable yang lebih kecil
    \item \textbf{Mengurangi Konsumsi Memory}: Mengoptimasi penggunaan memory
    \item \textbf{Meningkatkan Efisiensi Energy}: Mengurangi konsumsi daya (penting untuk embedded systems)
\end{itemize}

Namun, optimasi harus dilakukan dengan hati-hati karena:
\begin{itemize}
    \item Optimasi yang terlalu agresif dapat meningkatkan waktu kompilasi
    \item Beberapa optimasi dapat membuat kode lebih sulit di-debug
    \item Optimasi yang salah dapat mengubah semantik program (bug)
\end{itemize}

\subsection{Prinsip Optimasi}

Menurut Dragon Book\cite{aho2006compilers}, optimasi harus mematuhi prinsip-prinsip berikut:

\begin{enumerate}
    \item \textbf{Correctness}: Optimasi tidak boleh mengubah semantik program
    \item \textbf{Benefit}: Optimasi harus memberikan manfaat yang signifikan
    \item \textbf{Speed}: Proses optimasi tidak boleh terlalu lambat
    \item \textbf{Simplicity}: Optimasi harus mudah diimplementasikan dan di-maintain
\end{enumerate}

\subsection{Level Optimasi}

Optimasi dapat dikategorikan berdasarkan scope-nya:

\begin{itemize}
    \item \textbf{Local Optimization}: Optimasi dalam satu basic block
    \begin{itemize}
        \item Constant folding
        \item Constant propagation
        \item Algebraic simplification
        \item Strength reduction
    \end{itemize}
    
    \item \textbf{Global Optimization}: Optimasi lintas basic blocks
    \begin{itemize}
        \item Common subexpression elimination
        \item Loop optimization
        \item Dead code elimination (global)
        \item Constant propagation (global)
    \end{itemize}
    
    \item \textbf{Interprocedural Optimization}: Optimasi lintas fungsi/prosedur
    \begin{itemize}
        \item Inlining
        \item Interprocedural constant propagation
        \item Whole-program optimization
    \end{itemize}
\end{itemize}

\section{Basic Blocks}

Basic block adalah fondasi untuk banyak optimasi kompilator. Menurut University of Michigan\footnote{\url{https://web.eecs.umich.edu/~weimerw/2015-4610/ca1/ca1.html}}, basic block didefinisikan sebagai:

\begin{quote}
``A basic block is a straight-line sequence of code with no jumps in except at the entry, and no jumps out except at the exit. Once execution enters it, all instructions execute sequentially.''
\end{quote}

\subsection{Karakteristik Basic Block}

Sebuah basic block memiliki karakteristik berikut:

\begin{enumerate}
    \item \textbf{Single Entry Point}: Hanya ada satu titik masuk (entry point)
    \item \textbf{Single Exit Point}: Hanya ada satu titik keluar (exit point)
    \item \textbf{Sequential Execution}: Semua instruksi dieksekusi secara berurutan tanpa branching
    \item \textbf{No Internal Control Flow}: Tidak ada jump, branch, atau call di tengah-tengah block
\end{enumerate}

\subsection{Identifikasi Basic Blocks}

Algoritma untuk mengidentifikasi basic blocks dalam intermediate code:

\begin{enumerate}
    \item \textbf{Leader Identification}: Tentukan leader (instruksi pertama dalam basic block)
    \begin{itemize}
        \item Instruksi pertama dalam program adalah leader
        \item Instruksi yang merupakan target dari jump/branch adalah leader
        \item Instruksi setelah jump/branch/call adalah leader
    \end{itemize}
    
    \item \textbf{Block Construction}: Untuk setiap leader, buat basic block yang berisi:
    \begin{itemize}
        \item Leader instruction
        \item Semua instruksi berikutnya hingga menemukan leader berikutnya atau instruksi control flow
    \end{itemize}
\end{enumerate}

\subsection{Contoh Identifikasi Basic Block}

Perhatikan contoh three-address code berikut:

\begin{verbatim}
L1: t1 = a + b
    t2 = c * d
    t3 = t1 + t2
    if t3 > 0 goto L2
    t4 = t1 - t2
    goto L3
L2: t5 = t1 * t2
L3: t6 = t5 + 1
    return t6
\end{verbatim}

Basic blocks yang diidentifikasi:

\textbf{Block 1 (L1):}
\begin{verbatim}
    t1 = a + b
    t2 = c * d
    t3 = t1 + t2
    if t3 > 0 goto L2
\end{verbatim}

\textbf{Block 2 (L2):}
\begin{verbatim}
    t5 = t1 * t2
\end{verbatim}

\textbf{Block 3 (setelah goto L3):}
\begin{verbatim}
    t4 = t1 - t2
    goto L3
\end{verbatim}

\textbf{Block 4 (L3):}
\begin{verbatim}
    t6 = t5 + 1
    return t6
\end{verbatim}

\subsection{Control Flow Graph (CFG)}

Control Flow Graph adalah representasi grafis dari alur kontrol program. Menurut Wikipedia\footnote{\url{https://en.wikipedia.org/wiki/Control-flow_graph}}:

\begin{quote}
``A control-flow graph (CFG) is a representation of a function where each node is a basic block, and edges represent possible flow of control from one block to another.''
\end{quote}

CFG membantu dalam:
\begin{itemize}
    \item Memahami struktur program
    \item Melakukan data-flow analysis
    \item Mengidentifikasi loop dan struktur kontrol lainnya
    \item Mengoptimasi lintas basic blocks
\end{itemize}

\section{Constant Folding}

Constant folding adalah optimasi yang mengganti ekspresi yang hanya melibatkan konstanta dengan hasil komputasinya pada waktu kompilasi. Menurut GeeksforGeeks\footnote{\url{https://www.geeksforgeeks.org/compiler-design/constant-folding/}}:

\begin{quote}
``Constant folding replaces expressions involving only constants (literals) with their computed result at compile time, rather than at runtime. Example: turning `5 + 7 * 2` into `19` in the generated code.''
\end{quote}

\subsection{Contoh Constant Folding}

\textbf{Before optimization:}
\begin{verbatim}
t1 = 5 + 7
t2 = t1 * 2
t3 = 10 / 2
x = t2 + t3
\end{verbatim}

\textbf{After constant folding:}
\begin{verbatim}
t1 = 12        // 5 + 7 = 12
t2 = 24        // 12 * 2 = 24
t3 = 5         // 10 / 2 = 5
x = 29         // 24 + 5 = 29
\end{verbatim}

Atau bahkan lebih optimal:
\begin{verbatim}
x = 29         // Semua konstanta di-fold menjadi satu nilai
\end{verbatim}

\subsection{Implementasi Constant Folding}

Algoritma constant folding untuk three-address code:

\begin{enumerate}
    \item Untuk setiap instruksi dalam basic block:
    \begin{itemize}
        \item Jika kedua operan adalah konstanta, evaluasi ekspresi
        \item Ganti instruksi dengan assignment konstanta hasil
    \end{itemize}
    
    \item Ulangi hingga tidak ada lagi perubahan (iterasi mungkin diperlukan jika ada dependensi)
\end{enumerate}

\subsection{Contoh Implementasi dalam C++}

Berikut adalah contoh sederhana implementasi constant folding:

\begin{lstlisting}[language=C++, caption=Contoh implementasi constant folding]
struct Instruction {
    string op;      // operator: +, -, *, /, =
    string result;  // variabel hasil
    string arg1;    // operand pertama
    string arg2;    // operand kedua (optional)
};

bool isConstant(const string& var, 
                const map<string, int>& constants) {
    return constants.find(var) != constants.end();
}

int evaluateConstant(int val1, int val2, const string& op) {
    if (op == "+") return val1 + val2;
    if (op == "-") return val1 - val2;
    if (op == "*") return val1 * val2;
    if (op == "/") return val2 != 0 ? val1 / val2 : 0;
    return 0;
}

void constantFolding(vector<Instruction>& instructions) {
    map<string, int> constants;
    
    for (auto& inst : instructions) {
        if (inst.op == "=" && isNumeric(inst.arg1)) {
            // Assignment konstanta langsung
            constants[inst.result] = stoi(inst.arg1);
        } else if (inst.op != "=") {
            // Operasi biner
            if (isConstant(inst.arg1, constants) && 
                isConstant(inst.arg2, constants)) {
                int val1 = constants[inst.arg1];
                int val2 = constants[inst.arg2];
                int result = evaluateConstant(val1, val2, inst.op);
                constants[inst.result] = result;
                // Ganti instruksi dengan assignment konstanta
                inst.op = "=";
                inst.arg1 = to_string(result);
                inst.arg2 = "";
            }
        }
    }
}
\end{lstlisting}

\section{Constant Propagation}

Constant propagation adalah optimasi yang mengganti penggunaan variabel yang diketahui bernilai konstan dengan nilai konstanta tersebut. Menurut GeeksforGeeks\footnote{\url{https://www.geeksforgeeks.org/machine-independent-code-optimization-in-compiler-design/}}:

\begin{quote}
``Constant propagation replaces variables known to be constant with their constant values, then combined with constant folding to simplify more complex expressions.''
\end{quote}

\subsection{Contoh Constant Propagation}

\textbf{Before optimization:}
\begin{verbatim}
x = 10
y = 20
t1 = x + 5      // x adalah konstanta 10
t2 = y * 2      // y adalah konstanta 20
z = t1 + t2
\end{verbatim}

\textbf{After constant propagation:}
\begin{verbatim}
x = 10
y = 20
t1 = 10 + 5     // x diganti dengan 10
t2 = 20 * 2     // y diganti dengan 20
z = t1 + t2
\end{verbatim}

\textbf{After constant folding (kombinasi):}
\begin{verbatim}
x = 10
y = 20
t1 = 15         // 10 + 5 = 15
t2 = 40         // 20 * 2 = 40
z = 55          // 15 + 40 = 55
\end{verbatim}

\subsection{Local vs Global Constant Propagation}

\textbf{Local Constant Propagation:}
\begin{itemize}
    \item Hanya dalam satu basic block
    \item Lebih sederhana, tidak memerlukan data-flow analysis
    \item Dapat dilakukan bersamaan dengan constant folding
\end{itemize}

\textbf{Global Constant Propagation:}
\begin{itemize}
    \item Lintas basic blocks
    \item Memerlukan data-flow analysis (reaching definitions)
    \item Lebih kompleks tetapi lebih powerful
    \item Harus mempertimbangkan multiple paths dalam CFG
\end{itemize}

\subsection{Implementasi Local Constant Propagation}

Algoritma untuk local constant propagation:

\begin{enumerate}
    \item Scan basic block dari atas ke bawah
    \item Maintain map variabel â†’ nilai konstanta
    \item Untuk setiap instruksi:
    \begin{itemize}
        \item Jika assignment konstanta: update map
        \item Jika penggunaan variabel: ganti dengan konstanta jika tersedia
        \item Jika assignment dari variabel non-konstanta: hapus dari map (variabel tidak lagi konstanta)
    \end{itemize}
\end{enumerate}

\section{Dead Code Elimination}

Dead code elimination adalah optimasi yang menghapus kode yang tidak memiliki efek pada perilaku program yang dapat diamati. Menurut GeeksforGeeks\footnote{\url{https://www.geeksforgeeks.org/dead-code-elimination/}}:

\begin{quote}
``Dead code elimination removes code that has no effect on the program's observable behavior. Two main kinds: unreachable code (code that can never be executed) and assignment to variables never used (where a variable's value is computed but never read before being overwritten).''
\end{quote}

\subsection{Jenis Dead Code}

\textbf{1. Unreachable Code}
Kode yang tidak pernah dapat dieksekusi karena tidak ada path yang mencapainya.

Contoh:
\begin{verbatim}
x = 10
return x
y = 20      // Dead code - tidak pernah dieksekusi
z = y + 5   // Dead code
\end{verbatim}

\textbf{2. Dead Assignments}
Assignment ke variabel yang nilainya tidak pernah digunakan sebelum di-overwrite.

Contoh:
\begin{verbatim}
x = 10
x = 20      // Assignment pertama adalah dead code
y = x       // Hanya nilai kedua yang digunakan
\end{verbatim}

\subsection{Unreachable Code Elimination}

Algoritma untuk menghapus unreachable code:

\begin{enumerate}
    \item Bangun Control Flow Graph (CFG)
    \item Lakukan traversal dari entry block (misalnya DFS atau BFS)
    \item Mark semua basic block yang dapat dicapai
    \item Hapus semua basic block yang tidak ter-mark
\end{enumerate}

\subsection{Dead Assignment Elimination}

Algoritma untuk menghapus dead assignments (menggunakan live-variable analysis):

\begin{enumerate}
    \item Lakukan live-variable analysis untuk menentukan variabel mana yang "live" di setiap titik
    \item Variabel dikatakan "live" jika nilainya mungkin digunakan di masa depan
    \item Untuk setiap assignment \texttt{x = ...}:
    \begin{itemize}
        \item Jika \texttt{x} tidak live setelah assignment, assignment tersebut adalah dead code
        \item Hapus assignment tersebut
    \end{itemize}
\end{enumerate}

\subsection{Contoh Dead Code Elimination}

\textbf{Before optimization:}
\begin{verbatim}
x = 10
y = 20
t1 = x + y
t2 = t1 * 2
x = t2
t3 = 5 + 3      // Dead: t3 tidak pernah digunakan
t4 = t3 - 2    // Dead: t4 tidak pernah digunakan
return x
\end{verbatim}

\textbf{After dead code elimination:}
\begin{verbatim}
x = 10
y = 20
t1 = x + y
t2 = t1 * 2
x = t2
return x
\end{verbatim}

\subsection{Implementasi Dead Code Elimination}

Berikut adalah contoh implementasi sederhana untuk dead assignment elimination:

\begin{lstlisting}[language=C++, caption=Contoh implementasi dead code elimination]
set<string> computeLiveVariables(const vector<Instruction>& insts) {
    set<string> live;
    
    // Scan dari bawah ke atas
    for (int i = insts.size() - 1; i >= 0; i--) {
        const auto& inst = insts[i];
        
        // Variabel yang digunakan adalah live
        if (!inst.arg1.empty() && !isConstant(inst.arg1)) {
            live.insert(inst.arg1);
        }
        if (!inst.arg2.empty() && !isConstant(inst.arg2)) {
            live.insert(inst.arg2);
        }
        
        // Variabel yang di-assign tidak lagi live setelah assignment
        // (kecuali jika digunakan di sisi kanan)
        if (live.find(inst.result) != live.end()) {
            live.erase(inst.result);
        }
    }
    
    return live;
}

vector<Instruction> eliminateDeadCode(
    const vector<Instruction>& instructions) {
    
    set<string> live = computeLiveVariables(instructions);
    vector<Instruction> optimized;
    
    for (const auto& inst : instructions) {
        // Skip jika assignment ke variabel yang tidak live
        if (inst.op == "=" && live.find(inst.result) == live.end()) {
            continue; // Dead assignment
        }
        
        optimized.push_back(inst);
        
        // Update live set
        if (!inst.arg1.empty()) live.insert(inst.arg1);
        if (!inst.arg2.empty()) live.insert(inst.arg2);
        live.erase(inst.result);
    }
    
    return optimized;
}
\end{lstlisting}

\section{Data-Flow Analysis Dasar}

Data-flow analysis adalah teknik untuk menghitung informasi tentang kemungkinan perilaku program. Menurut GeeksforGeeks\footnote{\url{https://www.geeksforgeeks.org/data-flow-analysis-compiler/}}:

\begin{quote}
``Data-flow analysis is a technique to compute information about possible program behaviors (how definitions, uses of variables, expressions, etc. propagate through the code). Usually done on a CFG.''
\end{quote}

Data-flow analysis adalah fondasi untuk optimasi global yang lebih advanced.

\subsection{Konsep Dasar Data-Flow Analysis}

Data-flow analysis bekerja dengan:

\begin{enumerate}
    \item \textbf{Domain}: Himpunan informasi yang ingin dihitung
    \begin{itemize}
        \item Live variables: set variabel yang live
        \item Reaching definitions: set definisi yang mencapai suatu titik
        \item Available expressions: set ekspresi yang sudah dihitung
    \end{itemize}
    
    \item \textbf{Transfer Function}: Bagaimana informasi berubah setelah eksekusi instruksi
    
    \item \textbf{Meet/Join Operation}: Bagaimana menggabungkan informasi dari multiple paths
    
    \item \textbf{Fixpoint Iteration}: Iterasi hingga mencapai fixpoint (tidak ada perubahan)
\end{enumerate}

\subsection{Live Variable Analysis}

Live variable analysis menentukan variabel mana yang "live" (nilainya mungkin digunakan) di setiap titik program.

\textbf{Definisi:}
\begin{itemize}
    \item Variabel \texttt{v} dikatakan \textbf{live} di titik \texttt{p} jika ada path dari \texttt{p} ke penggunaan \texttt{v} tanpa assignment ke \texttt{v} di antara keduanya
    \item Variabel \texttt{v} dikatakan \textbf{dead} jika tidak live
\end{itemize}

\textbf{Algoritma (Backward Analysis):}
\begin{enumerate}
    \item Inisialisasi: \texttt{LIVE[exit] = \{\}}
    \item Untuk setiap basic block \texttt{B} (dari exit ke entry):
    \begin{itemize}
        \item \texttt{LIVE[B] = UNION(LIVE[successors])}
        \item \texttt{LIVE[B] = LIVE[B] - DEF[B] + USE[B]}
        \item \texttt{DEF[B]}: variabel yang didefinisikan di B
        \item \texttt{USE[B]}: variabel yang digunakan di B
    \end{itemize}
    \item Ulangi hingga fixpoint
\end{enumerate}

\subsection{Reaching Definitions}

Reaching definitions analysis menentukan definisi variabel mana yang "mencapai" suatu titik program.

\textbf{Definisi:}
Definisi \texttt{d} dikatakan \textbf{reach} titik \texttt{p} jika ada path dari \texttt{d} ke \texttt{p} tanpa definisi lain untuk variabel yang sama.

\textbf{Kegunaan:}
\begin{itemize}
    \item Constant propagation (global)
    \item Deteksi penggunaan variabel sebelum inisialisasi
    \item Optimasi lainnya
\end{itemize}

\subsection{Available Expressions}

Available expressions analysis menentukan ekspresi mana yang sudah dihitung dan masih valid (operand-nya belum berubah).

\textbf{Kegunaan:}
\begin{itemize}
    \item Common subexpression elimination
    \item Optimasi lainnya
\end{itemize}

\section{Kombinasi Optimasi}

Dalam praktik, optimasi biasanya dilakukan dalam beberapa pass dan saling berinteraksi:

\subsection{Order of Optimization}

Urutan optimasi yang umum:

\begin{enumerate}
    \item \textbf{Constant Folding \& Propagation}: Simplifikasi ekspresi konstanta
    \item \textbf{Dead Code Elimination}: Hapus kode yang tidak digunakan
    \item \textbf{Common Subexpression Elimination}: Hapus komputasi duplikat
    \item \textbf{Loop Optimizations}: Optimasi khusus untuk loop
    \item \textbf{Register Allocation}: Alokasi register yang efisien
\end{enumerate}

\subsection{Iterative Optimization}

Optimizer biasanya menjalankan beberapa pass hingga tidak ada lagi perubahan:

\begin{verbatim}
do {
    changed = false
    changed |= constantFolding()
    changed |= constantPropagation()
    changed |= deadCodeElimination()
    // ... optimasi lainnya
} while (changed)
\end{verbatim}

\section{Evaluasi Efektivitas Optimasi}

Setelah mengimplementasikan optimasi, penting untuk mengevaluasi efektivitasnya.

\subsection{Metrics untuk Evaluasi}

\textbf{1. Code Size}
\begin{itemize}
    \item Ukuran executable sebelum dan sesudah optimasi
    \item Jumlah instruksi dalam intermediate code
    \item Ukuran object files
\end{itemize}

\textbf{2. Execution Time}
\begin{itemize}
    \item Waktu eksekusi program dengan benchmark
    \item Profiling untuk mengidentifikasi bottleneck
    \item Perbandingan before/after
\end{itemize}

\textbf{3. Memory Usage}
\begin{itemize}
    \item Peak memory consumption
    \item Stack usage
    \item Heap allocation patterns
\end{itemize}

\textbf{4. Compilation Time}
\begin{itemize}
    \item Waktu yang dibutuhkan untuk kompilasi
    \item Trade-off antara waktu kompilasi dan kualitas optimasi
\end{itemize}

\subsection{Benchmarking}

Langkah-langkah untuk benchmarking:

\begin{enumerate}
    \item \textbf{Prepare Test Cases}: Siapkan berbagai test case (small, medium, large programs)
    \item \textbf{Baseline Measurement}: Ukur metrik sebelum optimasi
    \item \textbf{Optimized Measurement}: Ukur metrik setelah optimasi
    \item \textbf{Compare Results}: Bandingkan dan hitung improvement percentage
    \item \textbf{Verify Correctness}: Pastikan program masih menghasilkan output yang benar
\end{enumerate}

\subsection{Contoh Evaluasi}

Berikut adalah contoh format laporan evaluasi:

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Metric} & \textbf{Before} & \textbf{After} & \textbf{Improvement} \\
\hline
Code Size (bytes) & 1024 & 768 & 25\% reduction \\
\hline
Execution Time (ms) & 100 & 75 & 25\% faster \\
\hline
Instruction Count & 150 & 110 & 26.7\% reduction \\
\hline
Compilation Time (s) & 2.5 & 3.1 & 24\% slower \\
\hline
\end{tabular}
\caption{Contoh hasil evaluasi optimasi}
\label{tab:optimization-results}
\end{table}

\section{Implementasi Praktis}

Dalam bagian ini, kita akan melihat contoh implementasi optimizer sederhana yang menggabungkan beberapa optimasi dasar.

\subsection{Struktur Optimizer}

\begin{lstlisting}[language=C++, caption=Struktur dasar optimizer]
class Optimizer {
private:
    vector<BasicBlock> basicBlocks;
    ControlFlowGraph cfg;
    
public:
    // Identifikasi basic blocks
    void identifyBasicBlocks(const vector<Instruction>& insts);
    
    // Optimasi lokal dalam basic block
    void optimizeBasicBlock(BasicBlock& block);
    
    // Optimasi global lintas basic blocks
    void optimizeGlobal();
    
    // Kombinasi semua optimasi
    vector<Instruction> optimize(const vector<Instruction>& insts);
};

vector<Instruction> Optimizer::optimize(
    const vector<Instruction>& instructions) {
    
    // 1. Identifikasi basic blocks
    identifyBasicBlocks(instructions);
    
    // 2. Optimasi lokal untuk setiap basic block
    for (auto& block : basicBlocks) {
        optimizeBasicBlock(block);
    }
    
    // 3. Optimasi global
    optimizeGlobal();
    
    // 4. Reconstruct instructions dari basic blocks
    return reconstructInstructions();
}

void Optimizer::optimizeBasicBlock(BasicBlock& block) {
    bool changed = true;
    
    while (changed) {
        changed = false;
        
        // Constant folding
        changed |= constantFolding(block);
        
        // Constant propagation
        changed |= constantPropagation(block);
        
        // Dead code elimination
        changed |= deadCodeElimination(block);
    }
}
\end{lstlisting}

\section{Kesimpulan}

Dalam bab ini, kita telah mempelajari:

\begin{enumerate}
    \item Optimasi kompilator bertujuan meningkatkan kualitas kode tanpa mengubah semantik
    \item Basic blocks adalah unit fundamental untuk optimasi lokal
    \item Constant folding dan constant propagation adalah optimasi dasar yang efektif
    \item Dead code elimination menghapus kode yang tidak berguna
    \item Data-flow analysis adalah fondasi untuk optimasi global
    \item Evaluasi efektivitas optimasi penting untuk memastikan optimasi memberikan manfaat
\end{enumerate}

Optimasi kompilator adalah bidang yang luas dan kompleks. Bab ini memberikan dasar-dasar optimasi lokal. Untuk optimasi yang lebih advanced seperti loop optimization, interprocedural optimization, dan machine-specific optimization, diperlukan pemahaman yang lebih mendalam tentang data-flow analysis dan teknik optimasi lainnya.

\section{Latihan}

\begin{enumerate}
    \item Identifikasi basic blocks dari kode three-address berikut:
    \begin{verbatim}
    t1 = a + b
    t2 = c * d
    if t1 > t2 goto L1
    t3 = t1 - t2
    goto L2
    L1: t4 = t1 * t2
    L2: t5 = t3 + t4
    return t5
    \end{verbatim}
    
    \item Lakukan constant folding pada kode berikut:
    \begin{verbatim}
    t1 = 5 + 3
    t2 = t1 * 2
    t3 = 10 / 2
    x = t2 + t3
    \end{verbatim}
    
    \item Lakukan constant propagation dan folding pada kode berikut:
    \begin{verbatim}
    x = 10
    y = 20
    t1 = x + 5
    t2 = y * 2
    z = t1 + t2
    \end{verbatim}
    
    \item Identifikasi dan hapus dead code dari kode berikut:
    \begin{verbatim}
    x = 10
    y = 20
    t1 = x + y
    t2 = 5 + 3      // Dead
    t3 = t2 - 2     // Dead
    z = t1 * 2
    return z
    \end{verbatim}
    
    \item Implementasikan optimizer sederhana yang melakukan:
    \begin{itemize}
        \item Constant folding
        \item Constant propagation (local)
        \item Dead code elimination (basic)
    \end{itemize}
    Uji dengan beberapa contoh program dan evaluasi hasilnya.
    
    \item Jelaskan perbedaan antara:
    \begin{itemize}
        \item Local optimization vs global optimization
        \item Machine-independent vs machine-specific optimization
        \item Constant folding vs constant propagation
    \end{itemize}
    
    \item Buatlah benchmark untuk mengevaluasi efektivitas optimasi. Bandingkan:
    \begin{itemize}
        \item Ukuran kode sebelum dan sesudah optimasi
        \item Waktu eksekusi sebelum dan sesudah optimasi
        \item Waktu kompilasi sebelum dan sesudah optimasi
    \end{itemize}
\end{enumerate}

\section{Referensi dan Bahan Bacaan Lanjutan}

Untuk memperdalam pemahaman tentang optimasi kompilator, mahasiswa disarankan membaca:

\begin{itemize}
    \item \textbf{Dragon Book}: Aho, Lam, Sethi, \& Ullman (2006). \textit{Compilers: Principles, Techniques, and Tools} \cite{aho2006compilers} - Bab 9: Machine-Independent Optimizations
    
    \item \textbf{Engineering a Compiler}: Cooper \& Torczon (2011) \cite{cooper2011engineering} - Bab 8: Introduction to Optimization, Bab 9: Data-Flow Analysis
    
    \item \textbf{GeeksforGeeks}: Tutorial tentang berbagai optimasi kompilator
    \begin{itemize}
        \item Constant Folding: \url{https://www.geeksforgeeks.org/compiler-design/constant-folding/}
        \item Dead Code Elimination: \url{https://www.geeksforgeeks.org/dead-code-elimination/}
        \item Data-Flow Analysis: \url{https://www.geeksforgeeks.org/data-flow-analysis-compiler/}
    \end{itemize}
    
    \item \textbf{University of Michigan}: Course materials tentang compiler optimization \footnote{\url{https://web.eecs.umich.edu/~weimerw/2015-4610/ca1/ca1.html}}
    
    \item \textbf{LLVM Documentation}: Advanced optimization techniques \footnote{\url{https://llvm.org/docs/Passes.html}}
\end{itemize}
