% Bab 1: Pengenalan Kompilator dan Fase-Fase Kompilasi
% File ini dapat dikompilasi terpisah atau sebagai bagian dari main.tex

\chapter{Pengenalan Kompilator dan Fase-Fase Kompilasi}
\label{chap:pengenalan}

\section{Tujuan Pembelajaran}

Setelah mempelajari bab ini, mahasiswa diharapkan mampu:
\begin{enumerate}
    \item Menjelaskan definisi dan konsep dasar kompilator
    \item Memahami perbedaan antara kompilator, interpreter, dan translator lainnya
    \item Mengidentifikasi fase-fase utama dalam proses kompilasi
    \item Menjelaskan arsitektur kompilator secara keseluruhan
    \item Memahami alur kerja dari source code hingga executable code
\end{enumerate}

\section{Apa itu Kompilator?}

Menurut sumber terbuka dari UC San Diego, kompilator didefinisikan sebagai berikut:

\begin{quote}
``A compiler is a program that translates source code written in a programming language (the source language) into another language (the target language), often machine code or intermediate representation. Compilers typically perform several phases: lexical analysis, syntax analysis, semantic analysis, intermediate code generation, optimization, and code generation.''\cite{ucsd2024compiler}
\end{quote}

Dari definisi tersebut, dapat disimpulkan bahwa kompilator adalah program khusus yang melakukan translasi dari bahasa sumber (source language) ke bahasa target (target language). Bahasa sumber biasanya adalah bahasa pemrograman tingkat tinggi seperti C, C++, Java, atau Python, sedangkan bahasa target dapat berupa bahasa mesin (machine code), assembly, atau representasi intermediate seperti bytecode atau IR (Intermediate Representation).

Proses translasi ini tidak terjadi secara langsung, melainkan melalui beberapa fase yang akan dibahas secara detail dalam bagian selanjutnya. Setiap fase memiliki tugas spesifik untuk memastikan source code diterjemahkan dengan benar dan efisien.

\subsection{Kompilator vs Interpreter}

Terdapat perbedaan mendasar antara kompilator dan interpreter. Gambar \ref{fig:compiler-vs-interpreter} menunjukkan perbedaan alur kerja antara keduanya.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.9\textwidth,center}{%
    \begin{tikzpicture}[
        box/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.8cm, text centered, minimum height=0.8cm, rounded corners, font=\footnotesize, inner sep=4pt},
        arrow/.style={->, >=stealth, thick},
        title/.style={font=\bfseries\small},
        node distance=0.7cm and 3.5cm
    ]
    
    % ===== Compiler =====
    \node[title] (compiler-title) {KOMPILATOR};
    
    \node[box, below=of compiler-title] (source1) {Source Code};
    \node[box, below=of source1] (compile) {Compile};
    \node[box, below=of compile] (executable) {Executable};
    \node[box, below=of executable] (run1) {Run};
    
    \draw[arrow] (source1) -- (compile);
    \draw[arrow] (compile) -- (executable);
    \draw[arrow] (executable) -- (run1);
    
    \node[below=0.2cm of run1, font=\tiny, align=center, text width=3cm]
    (comp-note) {Sekali compile,\\berkali-kali run};
    
    \node[below=0.6cm of comp-note, font=\tiny, align=center, text width=3cm]
    (comp-ex) {Contoh:\\C, C++, Rust};
    
    % ===== Interpreter =====
    \node[title, right=of compiler-title] (interpreter-title) {INTERPRETER};
    
    \node[box, below=of interpreter-title] (source2) {Source Code};
    \node[box, below=of source2] (interpret) {Interpret};
    \node[box, below=of interpret] (run2) {Run};
    
    \draw[arrow] (source2) -- (interpret);
    \draw[arrow] (interpret) -- (run2);
    
    \node[below=0.2cm of run2, font=\tiny, align=center, text width=3cm]
    (int-note) {Interpret\\setiap kali run};
    
    \node[below=0.6cm of int-note, font=\tiny, align=center, text width=3cm]
    (int-ex) {Contoh:\\Python, JavaScript, Ruby};
    
    \end{tikzpicture}%
    }
    \caption{Perbandingan alur kerja Kompilator vs Interpreter}
    \label{fig:compiler-vs-interpreter}
    \end{figure}
    

Perbedaan utama:

\begin{itemize}
    \item \textbf{Kompilator}: Menerjemahkan seluruh program sekaligus sebelum dieksekusi. Hasil translasi disimpan dalam file terpisah yang kemudian dapat dieksekusi langsung oleh sistem operasi atau mesin virtual. Contoh: C, C++, Rust, Go.
    
    \item \textbf{Interpreter}: Menerjemahkan dan mengeksekusi program baris demi baris secara langsung tanpa menghasilkan file terpisah untuk eksekusi. Contoh: Python, JavaScript, Ruby.
    
    \item \textbf{Hybrid Approach}: Beberapa bahasa modern menggunakan pendekatan hybrid, seperti Java yang dikompilasi menjadi bytecode, kemudian diinterpretasi oleh JVM (Java Virtual Machine), atau menggunakan JIT (Just-In-Time compilation). Contoh: Java, C\#, Python (dengan bytecode).
\end{itemize}

\subsection{Jenis-jenis Translator}

Selain kompilator, terdapat berbagai jenis translator lainnya:

\begin{enumerate}
    \item \textbf{Assembler}: Menerjemahkan assembly code ke machine code
    \item \textbf{Linker}: Menyatukan beberapa file object code menjadi satu executable
    \item \textbf{Loader}: Memuat executable ke memory untuk dieksekusi
    \item \textbf{Preprocessor}: Memproses source code sebelum kompilasi (misalnya \texttt{\#include}, \texttt{\#define} dalam C/C{++})
    \item \textbf{Decompiler}: Kebalikan dari kompilator, menerjemahkan machine code kembali ke source code (lebih sulit dan tidak selalu akurat)
\end{enumerate}

\section{Alur Kerja Kompilator: Gambaran Umum}

Sebelum membahas detail arsitektur dan fase-fase kompilasi, mari kita lihat gambaran umum alur kerja kompilator dari source code hingga executable. Gambar \ref{fig:compiler-flow} menunjukkan alur kerja kompilator secara keseluruhan:

\begin{figure}[H]
\centering
\adjustbox{max width=0.92\textwidth,center}{%
\begin{tikzpicture}[
    process/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.5cm, text centered, minimum height=0.6cm, rounded corners, font=\footnotesize},
    output/.style={rectangle, draw=green!50, fill=green!10, text width=2cm, text centered, minimum height=0.5cm, rounded corners, font=\tiny},
    arrow/.style={->, >=stealth, thick}
]
    % Source code
    \node[process] (source) {\textbf{Source Code}\\\footnotesize(C/C++, Java, dll.)};
    
    % Preprocessing
    \node[process, below=0.7cm of source] (preproc) {\textbf{Preprocessing}\\\footnotesize(\#include, \#define)};
    
    % Lexical
    \node[process, below=0.65cm of preproc] (lexical) {\textbf{Lexical Analysis}};
    \node[output, right=1cm of lexical] (tokens) {Tokens};
    
    % Syntax
    \node[process, below=0.65cm of lexical] (syntax) {\textbf{Syntax Analysis}};
    \node[output, right=1cm of syntax] (ast) {Parse Tree\\AST};
    
    % Semantic
    \node[process, below=0.65cm of syntax] (semantic) {\textbf{Semantic Analysis}};
    \node[output, right=1cm of semantic] (annotated) {Annotated AST\\+ Symbol Table};
    
    % IR Generation
    \node[process, below=0.65cm of semantic] (irgen) {\textbf{IR Generation}};
    \node[output, right=1cm of irgen] (ir) {Intermediate\\Representation};
    
    % Optimization
    \node[process, below=0.65cm of irgen] (optimize) {\textbf{Optimization}};
    \node[output, right=1cm of optimize] (optir) {Optimized IR};
    
    % Code Generation
    \node[process, below=0.65cm of optimize] (codegen) {\textbf{Code Generation}};
    \node[output, right=1cm of codegen] (asm) {Assembly\\Machine Code};
    
    % Assembling
    \node[process, below=0.65cm of codegen] (assemble) {\textbf{Assembling}};
    \node[output, right=1cm of assemble] (obj) {Object Files};
    
    % Linking
    \node[process, below=0.65cm of assemble] (link) {\textbf{Linking}};
    \node[output, right=1cm of link] (exe) {\textbf{Executable}};
    
    % Arrows
    \draw[arrow] (source) -- (preproc);
    \draw[arrow] (preproc) -- (lexical);
    \draw[arrow] (lexical) -- (tokens);
    \draw[arrow] (lexical) -- (syntax);
    \draw[arrow] (syntax) -- (ast);
    \draw[arrow] (syntax) -- (semantic);
    \draw[arrow] (semantic) -- (annotated);
    \draw[arrow] (semantic) -- (irgen);
    \draw[arrow] (irgen) -- (ir);
    \draw[arrow] (irgen) -- (optimize);
    \draw[arrow] (optimize) -- (optir);
    \draw[arrow] (optimize) -- (codegen);
    \draw[arrow] (codegen) -- (asm);
    \draw[arrow] (codegen) -- (assemble);
    \draw[arrow] (assemble) -- (obj);
    \draw[arrow] (assemble) -- (link);
    \draw[arrow] (link) -- (exe);
\end{tikzpicture}%
}
\caption{Alur kerja kompilator dari source code ke executable}
\label{fig:compiler-flow}
\end{figure}

Dari gambar di atas, dapat dilihat bahwa proses kompilasi melibatkan beberapa tahap utama:
\begin{enumerate}
    \item \textbf{Preprocessing}: Memproses directive khusus sebelum kompilasi
    \item \textbf{Analisis} (Front-end): Lexical, Syntax, dan Semantic Analysis
    \item \textbf{Sintesis} (Back-end): IR Generation, Optimization, dan Code Generation
    \item \textbf{Assembling dan Linking}: Mengubah assembly menjadi executable
\end{enumerate}\par

\subsection{Preprocessing}

Sebelum kompilasi dimulai, preprocessor memproses directive khusus seperti:
\begin{itemize}
    \item \texttt{\#include}: Menyisipkan konten file header
    \item \texttt{\#define}: Makro definisi
    \item \texttt{\#ifdef}, \texttt{\#ifndef}: Conditional compilation
\end{itemize}

\subsection{Assembling dan Linking}

Setelah code generation, assembler mengubah assembly code menjadi object code (file .o atau .obj). Linker kemudian menyatukan:
\begin{itemize}
    \item Object files dari source code yang dikompilasi
    \item Library files (static atau dynamic libraries)
    \item Startup code
\end{itemize}

Menjadi satu executable file yang siap dieksekusi.

\section{Arsitektur Kompilator}

Kompilator modern umumnya dibagi menjadi dua bagian utama: \textbf{front-end} dan \textbf{back-end}. Gambar \ref{fig:compiler-architecture} menunjukkan struktur arsitektur kompilator secara keseluruhan.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.88\textwidth,center}{%
    \begin{tikzpicture}[
        box/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.2cm, text centered, minimum height=0.9cm, rounded corners, font=\footnotesize, inner sep=4pt},
        arrow/.style={->, >=stealth, thick},
        section/.style={rectangle, draw=black!50, fill=gray!20, text width=3.0cm, text centered, minimum height=1.0cm, rounded corners, font=\bfseries\small, inner sep=5pt},
        irbox/.style={rectangle, draw=purple!50, fill=purple!10, text width=2.4cm, text centered, minimum height=1.0cm, rounded corners, font=\footnotesize, inner sep=4pt},
        node distance=1.1cm and 1.8cm
    ]
    
    % Source
    \node[box] (source) {Source Code\\(C/C++, Java, dll.)};
    
    % Front-end label
    \node[section, right=of source] (frontend) {FRONT-END\\(Analisis)};
    
    % Front-end phases (vertical)
    \node[box, below=of frontend] (lexical) {Lexical Analysis};
    \node[box, below=of lexical] (syntax) {Syntax Analysis};
    \node[box, below=of syntax] (semantic) {Semantic Analysis};
    
    % IR
    \node[irbox, right=of syntax] (ir) {Intermediate\\Representation (IR)};
    
    % Back-end label
    \node[section, right=of ir] (backend) {BACK-END\\(Sintesis)};
    
    % Back-end phases (vertical)
    \node[box, below=of backend] (optimize) {Code Optimization};
    \node[box, below=of optimize] (codegen) {Code Generation};
    
    % Target
    \node[box, right=of backend] (target) {Target Code\\(Assembly / Machine)};
    
    % Arrows (alur utama)
    \draw[arrow] (source) -- (frontend);
    \draw[arrow] (frontend) -- (lexical);
    \draw[arrow] (lexical) -- (syntax);
    \draw[arrow] (syntax) -- (semantic);
    \draw[arrow] (semantic) -- (ir);
    \draw[arrow] (ir) -- (backend);
    \draw[arrow] (backend) -- (optimize);
    \draw[arrow] (optimize) -- (codegen);
    \draw[arrow] (codegen) -- (target);
    
    \end{tikzpicture}%
    }
    \caption{Arsitektur kompilator: Front-end (analisis) dan Back-end (sintesis)}
    \label{fig:compiler-architecture}
    \end{figure}
    

\subsection{Front-End (Analisis)}

Front-end bertanggung jawab untuk menganalisis source code dan membangun representasi internal. Menurut sumber terbuka:

\begin{quote}
``A typical compiler front end comprises several sequential phases: lexical analysis (scanning), syntax analysis (parsing), and semantic analysis. Lexical analysis breaks input text into lexemes which correspond to tokens, eliminating comments and whitespace. Syntax analysis checks grammar validity and builds a structural representation (parse tree or AST). Semantic analysis performs scope resolution, type checking, name resolution, and checks language-specific semantic rules.''\cite{diznr2024phases}
\end{quote}

Fase-fase dalam front-end meliputi:

\begin{enumerate}
    \item \textbf{Lexical Analysis (Tokenization)}: Memecah source code menjadi token-token (identifiers, keywords, operators, literals, dll.)
    \item \textbf{Syntax Analysis (Parsing)}: Menganalisis struktur grammar dan membangun parse tree atau Abstract Syntax Tree (AST)
    \item \textbf{Semantic Analysis}: Memeriksa aturan semantik bahasa, seperti type checking, scope resolution, dan name resolution
\end{enumerate}

\subsection{Back-End (Sintesis)}

Setelah front-end selesai menganalisis source code dan menghasilkan representasi intermediate, back-end bertanggung jawab untuk menghasilkan target code dari representasi tersebut. Fase-fase dalam back-end meliputi:

\begin{enumerate}
    \item \textbf{Intermediate Code Generation}: Mengubah AST menjadi intermediate representation (misalnya three-address code, quadruples, atau bytecode)
    \item \textbf{Code Optimization}: Mengoptimasi kode intermediate untuk meningkatkan efisiensi tanpa mengubah semantik
    \item \textbf{Code Generation}: Menghasilkan target code (assembly atau machine code) dari kode intermediate yang sudah dioptimasi
\end{enumerate}

\section{Fase-Fase Kompilasi Secara Detail}

Setelah memahami gambaran umum arsitektur kompilator, sekarang kita akan mempelajari setiap fase kompilasi secara lebih mendalam. Setiap fase memiliki peran spesifik dalam transformasi source code menjadi executable code. Mari kita pelajari setiap fase berdasarkan sumber dari UC San Diego\cite{ucsd2024compiler}:

\subsection{Fase 1: Lexical Analysis (Analisis Leksikal)}

Fase pertama dalam proses kompilasi adalah lexical analysis atau scanning. Fase ini merupakan langkah awal yang mengubah source code (berupa string karakter) menjadi stream token yang bermakna. Tujuan fase ini adalah:

\begin{itemize}
    \item Membaca source code karakter demi karakter
    \item Mengelompokkan karakter menjadi token-token bermakna
    \item Mengeliminasi whitespace, comments, dan karakter yang tidak relevan
    \item Melacak informasi posisi (baris, kolom) untuk error reporting
\end{itemize}

Contoh: Source code \texttt{int x = 42;} akan dipecah menjadi token-token:
\begin{itemize}
    \item \texttt{int} (keyword)
    \item \texttt{x} (identifier)
    \item \texttt{=} (operator assignment)
    \item \texttt{42} (integer literal)
    \item \texttt{;} (punctuation/semicolon)
\end{itemize}

Gambar \ref{fig:lexical-example} menunjukkan contoh proses tokenization untuk source code yang lebih kompleks.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.9\textwidth,center}{%
    \begin{tikzpicture}[
        codebox/.style={rectangle, draw=black, fill=gray!10, text width=6.2cm, minimum height=0.8cm, font=\ttfamily\footnotesize, inner sep=4pt},
        tokenbox/.style={rectangle, draw=blue!50, fill=blue!10, text width=1.7cm, text centered, minimum height=0.55cm, rounded corners, font=\footnotesize, inner sep=3pt},
        arrow/.style={->, >=stealth, thick, blue},
        label/.style={font=\small},
        node distance=0.8cm and 0.8cm
    ]
    
    % Source code
    \node[codebox] (source) {int x = 42; float y = 3.14;};
    \node[label, above=0.2cm of source] {\textbf{Source Code}};
    
    % Token row 1
    \node[tokenbox, below=1.2cm of source, xshift=-3.2cm] (t1) {int};
    \node[tokenbox, right=of t1] (t2) {x};
    \node[tokenbox, right=of t2] (t3) {=};
    \node[tokenbox, right=of t3] (t4) {42};
    
    % Token row 2
    \node[tokenbox, below=of t2, xshift=-0.85cm] (t5) {float};
    \node[tokenbox, right=of t5] (t6) {y};
    \node[tokenbox, right=of t6] (t7) {3.14};
    
    % Token type labels
    \node[font=\tiny, above=0.1cm of t1] {keyword};
    \node[font=\tiny, above=0.1cm of t2] {identifier};
    \node[font=\tiny, above=0.1cm of t3] {operator};
    \node[font=\tiny, above=0.1cm of t4] {literal};
    \node[font=\tiny, above=0.1cm of t5] {keyword};
    \node[font=\tiny, above=0.1cm of t6] {identifier};
    \node[font=\tiny, above=0.1cm of t7] {literal};
    
    % Arrows (distributed cleanly)
    \draw[arrow] (source.south) -- ($(source.south)!0.5!(t3.north)$);
    \draw[arrow] ($(source.south)!0.5!(t3.north)$) -- (t1.north);
    \draw[arrow] ($(source.south)!0.5!(t3.north)$) -- (t2.north);
    \draw[arrow] ($(source.south)!0.5!(t3.north)$) -- (t3.north);
    \draw[arrow] ($(source.south)!0.5!(t3.north)$) -- (t4.north);
    \draw[arrow] ($(source.south)!0.5!(t3.north)$) -- (t5.north);
    \draw[arrow] ($(source.south)!0.5!(t3.north)$) -- (t6.north);
    \draw[arrow] ($(source.south)!0.5!(t3.north)$) -- (t7.north);
    
    % Token stream label
    \node[label, below=0.5cm of t6] {\textbf{Token Stream}};
    
    \end{tikzpicture}%
    }
    \caption{Contoh proses lexical analysis: dari source code ke token stream}
    \label{fig:lexical-example}
    \end{figure}
    

Lexical analysis biasanya diimplementasikan menggunakan finite automata dan regular expressions. Tools seperti Flex, re2c, atau implementasi manual dapat digunakan.

\subsection{Fase 2: Syntax Analysis (Analisis Sintaksis)}

Setelah lexical analysis menghasilkan stream token, fase berikutnya adalah syntax analysis atau parsing. Fase ini mengambil stream token dari lexical analyzer dan memverifikasi bahwa token-token tersebut membentuk struktur yang valid menurut grammar bahasa tersebut.

Hasil dari parsing biasanya berupa:
\begin{itemize}
    \item \textbf{Parse Tree}: Representasi lengkap dari struktur grammar, termasuk semua non-terminal
    \item \textbf{Abstract Syntax Tree (AST)}: Representasi yang lebih abstrak, hanya menyertakan informasi yang relevan untuk fase selanjutnya
\end{itemize}

Contoh: token-token \texttt{int x = 42;} akan di-parse menjadi struktur berikut:

\begin{verbatim}
Declaration
|-- Type: int
|-- Identifier: x
`-- Initializer: 42
\end{verbatim}

Gambar \ref{fig:parsing-example} menunjukkan contoh parse tree untuk deklarasi variabel sederhana.

\begin{figure}[H]
\centering
\adjustbox{max width=0.75\textwidth,center}{%
\begin{forest}
for tree={
    grow'=south,
    draw,
    rounded corners,
    align=center,
    font=\footnotesize,
    edge={-stealth},
    parent anchor=south,
    child anchor=north,
    l sep=15mm,
    s sep=10mm
}
[Declaration
    [Type
        [int]
    ]
    [Identifier
        [x]
    ]
    [Initializer
        [42]
    ]
]
\end{forest}%
}
\caption{Contoh parse tree untuk deklarasi \texttt{int x = 42;}}
\label{fig:parsing-example}
\end{figure}


Parsing dapat dilakukan dengan berbagai metode:
\begin{itemize}
    \item Top-down parsing (recursive descent, LL parsers)
    \item Bottom-up parsing (LR, LALR, GLR parsers)
    \item Menggunakan parser generators seperti Bison, Yacc, atau ANTLR
\end{itemize}

\subsection{Fase 3: Semantic Analysis (Analisis Semantik)}

Setelah syntax analysis memastikan bahwa struktur program valid secara grammar, semantic analysis memastikan bahwa program juga memenuhi aturan semantik bahasa. Meskipun program sudah valid secara sintaks, belum tentu valid secara semantik. Tugas utama fase ini meliputi:

\begin{itemize}
    \item \textbf{Type Checking}: Memastikan tipe data yang digunakan sesuai dengan aturan bahasa
    \item \textbf{Scope Resolution}: Menyelesaikan referensi variabel dan fungsi ke deklarasi yang sesuai
    \item \textbf{Name Resolution}: Memastikan setiap identifier merujuk ke deklarasi yang valid
    \item \textbf{Contextual Checks}: Memeriksa aturan spesifik bahasa (misalnya: break hanya dalam loop, return type match, dll.)
\end{itemize}

Misalnya, semantic analyzer akan memeriksa:
\begin{itemize}
    \item Apakah variabel digunakan sebelum dideklarasi?
    \item Apakah operasi aritmatika dilakukan pada tipe yang kompatibel?
    \item Apakah fungsi dipanggil dengan jumlah dan tipe parameter yang benar?
\end{itemize}

\subsection{Fase 4: Intermediate Code Generation}

Setelah semantic analysis selesai dan memastikan program valid secara semantik, kompilator menghasilkan intermediate representation (IR). IR adalah representasi program yang berada di antara AST (yang masih dekat dengan source code) dan target code (yang dekat dengan machine code). IR adalah representasi program yang:
\begin{itemize}
    \item Lebih dekat ke machine code dibanding AST, tetapi tetap machine-independent
    \item Memudahkan optimasi karena lebih sederhana dari AST
    \item Memungkinkan portabilitas (IR yang sama dapat digunakan untuk berbagai target platform)
\end{itemize}

Bentuk IR yang umum digunakan:
\begin{itemize}
    \item \textbf{Three-Address Code (TAC)}: Setiap instruksi memiliki paling banyak tiga operand
    \item \textbf{Quadruples}: Format IR dengan operator, dua operan, dan satu hasil
    \item \textbf{Static Single Assignment (SSA)}: Setiap variabel hanya di-assign sekali, memudahkan optimasi
    \item \textbf{Bytecode}: Untuk bahasa yang diinterpretasi (seperti Java, Python)
\end{itemize}

Contoh TAC untuk \texttt{x = a + b * c}:
\begin{verbatim}
t1 = b * c
t2 = a + t1
x = t2
\end{verbatim}

Gambar \ref{fig:tac-example} menunjukkan visualisasi proses generasi TAC dari AST.

\begin{figure}[H]
\centering
\adjustbox{max width=0.88\textwidth,center}{%
\begin{tikzpicture}[
    node distance=0.85cm,
    astnode/.style={circle, draw=blue!50, fill=blue!10, minimum size=0.6cm, font=\footnotesize},
    tacnode/.style={rectangle, draw=green!50, fill=green!10, text width=1.8cm, text centered, minimum height=0.6cm, rounded corners, font=\footnotesize},
    arrow/.style={->, >=stealth, thick}
]
    % AST
    \node[astnode] (assign) at (0,0) {=};
    \node[astnode, above left=0.7cm of assign] (x) {x};
    \node[astnode, above right=0.7cm of assign] (plus) {+};
    \node[astnode, above left=0.55cm of plus] (a) {a};
    \node[astnode, above right=0.55cm of plus] (mult) {*};
    \node[astnode, above left=0.55cm of mult] (b) {b};
    \node[astnode, above right=0.55cm of mult] (c) {c};
    
    \draw[arrow] (assign) -- (x);
    \draw[arrow] (assign) -- (plus);
    \draw[arrow] (plus) -- (a);
    \draw[arrow] (plus) -- (mult);
    \draw[arrow] (mult) -- (b);
    \draw[arrow] (mult) -- (c);
    
    \node[above=0.2cm of x, font=\small] {\textbf{AST}};
    
    % Arrow to TAC
    \node[right=2.2cm of assign] (arrow) {\Large $\Rightarrow$};
    
    % TAC
    \node[tacnode, right=1.6cm of arrow] (tac1) at (4.5,1.1) {\texttt{t1 = b * c}};
    \node[tacnode, right=1.6cm of arrow] (tac2) at (4.5,0) {\texttt{t2 = a + t1}};
    \node[tacnode, right=1.6cm of arrow] (tac3) at (4.5,-1.1) {\texttt{x = t2}};
    
    \node[above=0.2cm of tac1, font=\small] {\textbf{Three-Address Code}};
    
    \draw[arrow] (arrow) -- (tac1.west);
    \draw[arrow] (arrow) -- (tac2.west);
    \draw[arrow] (arrow) -- (tac3.west);
\end{tikzpicture}%
}
\caption{Generasi Three-Address Code dari AST untuk ekspresi \texttt{x = a + b * c}}
\label{fig:tac-example}
\end{figure}

\subsection{Fase 5: Code Optimization}

Setelah IR dihasilkan, fase optimasi bertujuan untuk meningkatkan kualitas kode yang dihasilkan tanpa mengubah semantik program. Optimasi ini penting untuk menghasilkan kode yang lebih efisien dalam hal waktu eksekusi dan penggunaan memori. Optimasi dapat dilakukan pada berbagai level:

\begin{itemize}
    \item \textbf{Local Optimization}: Optimasi dalam basic block (satu entry, satu exit)
    \begin{itemize}
        \item Constant folding: \texttt{x = 3 + 5} â†’ \texttt{x = 8}
        \item Constant propagation: Mengganti variabel dengan nilai konstantanya
        \item Dead code elimination: Menghapus kode yang tidak pernah dieksekusi
    \end{itemize}
    
    \item \textbf{Global Optimization}: Optimasi lintas basic blocks
    \begin{itemize}
        \item Common subexpression elimination
        \item Loop optimization (loop unrolling, loop invariant code motion)
        \item Data flow analysis
    \end{itemize}
    
    \item \textbf{Machine-Specific Optimization}: Optimasi yang memanfaatkan fitur hardware tertentu
\end{itemize}

Menurut sumber dari UC San Diego, Northeastern University, dan sumber lainnya\cite{neu2024compiler}, optimasi harus menyeimbangkan antara:
\begin{itemize}
    \item Waktu kompilasi
    \item Kualitas kode yang dihasilkan
    \item Konsumsi memory compiler
\end{itemize}

\subsection{Fase 6: Code Generation}

Fase terakhir dalam proses kompilasi adalah menghasilkan target code dari IR yang telah dioptimasi. Fase ini mengubah representasi intermediate menjadi kode yang dapat dieksekusi oleh mesin target. Code generator bertanggung jawab untuk:

\begin{itemize}
    \item \textbf{Instruction Selection}: Memilih instruksi machine yang tepat untuk setiap operasi IR
    \item \textbf{Register Allocation}: Mengalokasikan register untuk variabel (register terbatas, variabel banyak)
    \item \textbf{Instruction Scheduling}: Mengatur urutan instruksi untuk memaksimalkan penggunaan pipeline processor
    \item \textbf{Address Assignment}: Mengalokasikan memory untuk variabel dan data structures
\end{itemize}

Contoh: TAC \texttt{x = a + b} dapat di-generate menjadi assembly:
\begin{verbatim}
LOAD R1, a
LOAD R2, b
ADD R3, R1, R2
STORE R3, x
\end{verbatim}


\section{Kompilator Modern: Multi-Pass vs Single-Pass}

Setelah memahami arsitektur dan fase-fase kompilasi, penting untuk mengetahui bahwa kompilator modern umumnya menggunakan pendekatan \textbf{multi-pass}, di mana setiap fase dijalankan dalam pass terpisah. Keuntungannya:
\begin{itemize}
    \item Memisahkan concern (tiap fase fokus pada tugas spesifik)
    \item Memudahkan maintenance dan debugging
    \item Memungkinkan optimasi yang lebih kompleks
\end{itemize}

Sebaliknya, kompilator \textbf{single-pass} mencoba menyelesaikan semua fase dalam satu pass. Pendekatan ini lebih cepat tetapi lebih sulit diimplementasikan dan terbatas dalam optimasi.

Gambar \ref{fig:multipass-vs-singlepass} menunjukkan perbedaan antara kedua pendekatan.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.85\textwidth,center}{%
    \begin{tikzpicture}[
        box/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.5cm, text centered, minimum height=0.7cm, rounded corners, font=\footnotesize, inner sep=4pt},
        bigbox/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.8cm, text centered, minimum height=3.6cm, rounded corners, font=\footnotesize, inner sep=6pt},
        arrow/.style={->, >=stealth, thick},
        title/.style={font=\bfseries\small},
        node distance=0.5cm and 3.5cm
    ]
    
    % ===== Multi-pass =====
    \node[title] (mp-title) {MULTI-PASS};
    
    \node[box, below=of mp-title] (mp1) {Pass 1: Lexical};
    \node[box, below=of mp1] (mp2) {Pass 2: Syntax};
    \node[box, below=of mp2] (mp3) {Pass 3: Semantic};
    \node[box, below=of mp3] (mp4) {Pass 4: IR Generation};
    \node[box, below=of mp4] (mp5) {Pass 5: Optimization};
    \node[box, below=of mp5] (mp6) {Pass 6: Code Generation};
    
    \draw[arrow] (mp1) -- (mp2);
    \draw[arrow] (mp2) -- (mp3);
    \draw[arrow] (mp3) -- (mp4);
    \draw[arrow] (mp4) -- (mp5);
    \draw[arrow] (mp5) -- (mp6);
    
    \node[below=0.3cm of mp6, font=\tiny, text width=2.8cm, align=center]
    (mp-note) {Lebih modular\\Lebih mudah dioptimasi};
    
    % ===== Single-pass =====
    \node[title, right=of mp-title] (sp-title) {SINGLE-PASS};
    
    \node[bigbox, below=of sp-title] (sp-all)
    {Semua fase\\dalam satu pass};
    
    \node[below=0.3cm of sp-all, font=\tiny, text width=2.8cm, align=center]
    (sp-note) {Lebih cepat\\Lebih sulit dikembangkan\\Optimasi terbatas};
    
    \end{tikzpicture}%
    }
    \caption{Perbandingan arsitektur Multi-Pass dan Single-Pass Compiler}
    \label{fig:multipass-vs-singlepass}
    \end{figure}
    

\section{Contoh Praktis: Alur Kompilasi Program C Sederhana}

Untuk memperkuat pemahaman tentang fase-fase kompilasi yang telah dipelajari, mari kita lihat contoh konkret bagaimana sebuah program C sederhana diproses melalui setiap fase kompilasi. Contoh ini akan menunjukkan aplikasi praktis dari konsep-konsep yang telah dibahas.

Mari kita lihat contoh konkret bagaimana sebuah program C sederhana diproses melalui fase-fase kompilasi:

\begin{lstlisting}[language=C, caption={Program C sederhana: hello.c}, label={lst:hello-c}]
#include <stdio.h>

int main() {
    int x = 10;
    int y = 20;
    int sum = x + y;
    printf("Sum = %d\n", sum);
    return 0;
}
\end{lstlisting}

\subsubsection{Setelah Preprocessing}

Preprocessor akan mengganti \texttt{\#include <stdio.h>} dengan isi file header tersebut (biasanya ratusan baris deklarasi fungsi).

\subsubsection{Setelah Lexical Analysis}

Source code dipecah menjadi token-token seperti yang ditunjukkan pada Tabel \ref{tab:tokens-example}.

\begin{longtable}{@{}p{4cm}p{6cm}@{}}
\caption{Token stream hasil lexical analysis untuk program hello.c}
\label{tab:tokens-example} \\
\toprule
\textbf{Token} & \textbf{Token Type} \\
\midrule
\endfirsthead
\multicolumn{2}{c}%
{{\bfseries \tablename\ \thetable{} -- lanjutan dari halaman sebelumnya}} \\
\toprule
\textbf{Token} & \textbf{Token Type} \\
\midrule
\endhead
\midrule \multicolumn{2}{r}{{Dilanjutkan pada halaman berikutnya}} \\
\endfoot
\bottomrule
\endlastfoot
\texttt{int} & KEYWORD \\
\texttt{main} & IDENTIFIER \\
\texttt{(} & PUNCTUATION (LPAREN) \\
\texttt{)} & PUNCTUATION (RPAREN) \\
\texttt{\{} & PUNCTUATION (LBRACE) \\
\texttt{int} & KEYWORD \\
\texttt{x} & IDENTIFIER \\
\texttt{=} & OPERATOR (ASSIGN) \\
\texttt{10} & INTEGER\_LITERAL \\
\texttt{;} & PUNCTUATION (SEMICOLON) \\
\texttt{int} & KEYWORD \\
\texttt{y} & IDENTIFIER \\
\texttt{=} & OPERATOR (ASSIGN) \\
\texttt{20} & INTEGER\_LITERAL \\
\texttt{;} & PUNCTUATION (SEMICOLON) \\
\texttt{int} & KEYWORD \\
\texttt{sum} & IDENTIFIER \\
\texttt{=} & OPERATOR (ASSIGN) \\
\texttt{x} & IDENTIFIER \\
\texttt{+} & OPERATOR (PLUS) \\
\texttt{y} & IDENTIFIER \\
\texttt{;} & PUNCTUATION (SEMICOLON) \\
\texttt{printf} & IDENTIFIER \\
\texttt{(} & PUNCTUATION (LPAREN) \\
\texttt{"Sum = \%d\textbackslash n"} & STRING\_LITERAL \\
\texttt{,} & PUNCTUATION (COMMA) \\
\texttt{sum} & IDENTIFIER \\
\texttt{)} & PUNCTUATION (RPAREN) \\
\texttt{;} & PUNCTUATION (SEMICOLON) \\
\texttt{return} & KEYWORD \\
\texttt{0} & INTEGER\_LITERAL \\
\texttt{;} & PUNCTUATION (SEMICOLON) \\
\texttt{\}} & PUNCTUATION (RBRACE) \\
\end{longtable}

\subsubsection{Setelah Syntax Analysis}

Parser membangun AST yang menunjukkan struktur program. Bagian AST untuk statement \texttt{int sum = x + y;} ditunjukkan pada Gambar \ref{fig:ast-sum-example}.

\begin{figure}[H]
\centering
\adjustbox{max width=0.8\textwidth,center}{%
\begin{forest}
for tree={
    grow'=0,
    child anchor=west,
    parent anchor=east,
    anchor=west,
    calign=first,
    s sep=8mm,
    l sep=12mm,
    edge path={
        \noexpand\path[\forestoption{edge}]
        (!u.south west) +(7.5pt,0) |- (.child anchor) \forestoption{edge label};
    },
    before typesetting nodes={
        if n=1
          {insert before={[,phantom]}}
          {}
    },
    fit=band,
    before computing xy={l=15pt},
    font=\footnotesize
}
[Declaration
    [Type [int]]
    [Variable [sum]]
    [Initializer
        [Expression
            [BinaryOp [+]
                [Identifier [x]]
                [Identifier [y]]
            ]
        ]
    ]
]
\end{forest}%
}
\caption{AST untuk deklarasi \texttt{int sum = x + y;}}
\label{fig:ast-sum-example}
\end{figure}

\subsubsection{Setelah Semantic Analysis}

Semantic analyzer memeriksa:
\begin{itemize}
    \item Variabel \texttt{x} dan \texttt{y} sudah dideklarasi sebelum digunakan
    \item Tipe data \texttt{int} kompatibel untuk operasi penjumlahan
    \item Fungsi \texttt{printf} dideklarasi di \texttt{stdio.h}
    \item Format string \texttt{"Sum = \%d\textbackslash n"} sesuai dengan parameter \texttt{sum} (tipe \texttt{int})
\end{itemize}

\subsubsection{Setelah Intermediate Code Generation}

TAC yang dihasilkan untuk bagian \texttt{sum = x + y;}:
\begin{verbatim}
t1 = x + y
sum = t1
\end{verbatim}

\subsubsection{Setelah Code Generation}

Assembly code yang dihasilkan (contoh untuk x86-64):
\begin{verbatim}
mov eax, DWORD PTR [rbp-4]    ; Load x
add eax, DWORD PTR [rbp-8]    ; Add y
mov DWORD PTR [rbp-12], eax   ; Store to sum
\end{verbatim}

\section{Contoh Kompilator Sederhana}

Sebagai referensi pembelajaran, terdapat beberapa kompilator sederhana yang dapat dipelajari untuk memahami implementasi praktis dari fase-fase kompilasi:

\begin{itemize}
    \item \textbf{TinyCC (TCC)}: Kompilator C kecil dan cepat yang menunjukkan implementasi praktis dari fase-fase kompilasi. TCC dapat digunakan sebagai referensi pembelajaran karena ukurannya yang relatif kecil namun lengkap.
    
    \item \textbf{AnjaneyaTripathi's C Compiler}\footnote{\url{https://github.com/AnjaneyaTripathi/c-compiler}}: Implementasi compiler sederhana menggunakan Flex dan Bison, yang sangat berguna untuk pembelajaran karena menunjukkan penggunaan tools generator (lexer dan parser generator).
    
    \item \textbf{Project Open Source Lainnya}: Banyak project open source yang tersedia di GitHub yang mengimplementasikan compiler sederhana untuk berbagai bahasa, yang dapat digunakan sebagai bahan pembelajaran.
\end{itemize}

\section{Kesimpulan}

Dalam bab ini, kita telah mempelajari konsep dasar kompilator dan fase-fase kompilasi. Ringkasan materi yang telah dibahas:

\begin{enumerate}
    \item \textbf{Definisi Kompilator}: Kompilator adalah program yang menerjemahkan source code ke target code melalui beberapa fase yang terstruktur.
    
    \item \textbf{Perbedaan dengan Translator Lainnya}: Kompilator berbeda dengan interpreter dan translator lainnya (assembler, linker, loader, preprocessor, decompiler) dalam cara dan tujuan translasinya.
    
    \item \textbf{Arsitektur Kompilator}: Kompilator modern terdiri dari dua bagian utama:
    \begin{itemize}
        \item \textbf{Front-end (Analisis)}: Lexical Analysis, Syntax Analysis, dan Semantic Analysis
        \item \textbf{Back-end (Sintesis)}: Intermediate Code Generation, Code Optimization, dan Code Generation
    \end{itemize}
    
    \item \textbf{Enam Fase Utama Kompilasi}: Setiap fase memiliki peran spesifik dalam transformasi source code menjadi executable:
    \begin{itemize}
        \item Lexical Analysis: Tokenization
        \item Syntax Analysis: Parsing dan pembangunan AST
        \item Semantic Analysis: Type checking dan scope resolution
        \item Intermediate Code Generation: Pembuatan IR
        \item Code Optimization: Optimasi kode
        \item Code Generation: Generasi target code
    \end{itemize}
    
    \item \textbf{Alur Kerja Lengkap}: Proses dari source code hingga executable melibatkan preprocessing, enam fase kompilasi utama, assembling, dan linking.
    
    \item \textbf{Pendekatan Modern}: Kompilator modern menggunakan pendekatan multi-pass yang lebih modular dan memungkinkan optimasi yang lebih kompleks dibanding single-pass.
\end{enumerate}

Pemahaman terhadap arsitektur dan fase-fase kompilasi ini menjadi dasar penting untuk mempelajari implementasi praktis setiap fase dalam bab-bab selanjutnya. Setiap fase akan dibahas secara lebih mendalam dengan contoh implementasi menggunakan bahasa pemrograman C/C++.

\section{Latihan}

\begin{enumerate}
    \item Jelaskan perbedaan antara kompilator dan interpreter. Berikan contoh bahasa pemrograman yang menggunakan masing-masing pendekatan.
    
    \item Buatlah diagram yang menunjukkan alur kerja kompilator dari source code C sampai menjadi executable. Sertakan semua fase yang telah dipelajari.
    
    \item Identifikasi fase kompilasi yang bertanggung jawab untuk:
    \begin{itemize}
        \item Menghapus whitespace dan comments
        \item Memeriksa apakah variabel dideklarasi sebelum digunakan
        \item Mengoptimasi kode dengan menghilangkan kode yang tidak pernah dieksekusi
        \item Mengkonversi ekspresi \texttt{a + b * c} menjadi three-address code
    \end{itemize}
    
    \item Jelaskan mengapa kompilator modern menggunakan pendekatan multi-pass. Apa keuntungannya dibanding single-pass?
    
    \item Carilah informasi tentang satu kompilator open source (misalnya GCC, Clang, atau TinyCC) dan identifikasi:
    \begin{itemize}
        \item Bahasa sumber dan target yang didukung
        \item Tools yang digunakan untuk lexical dan syntax analysis
        \item Format intermediate representation yang digunakan
    \end{itemize}
\end{enumerate}

\section{Referensi dan Bahan Bacaan Lanjutan}

Untuk memperdalam pemahaman tentang pengenalan kompilator, mahasiswa disarankan membaca:

\begin{itemize}
    \item \textbf{Dragon Book}: Aho, Lam, Sethi, \& Ullman (2006). \textit{Compilers: Principles, Techniques, and Tools} \cite{aho2006compilers} - Bab 1: Introduction
    
    \item \textbf{Engineering a Compiler}: Cooper \& Torczon (2011) \cite{cooper2011engineering} - Bab 1: Overview of Compilation
    
    \item \textbf{UC San Diego CSE 231}: Course materials tentang compiler construction \cite{ucsd2024compiler}
    
    \item \textbf{Northeastern University CS 4410}: Comprehensive compiler design course \cite{neu2024compiler}
    
    \item \textbf{Johns Hopkins University EN.601.428}: Course tentang compilers dan interpreters \cite{jhu2024compilers}
\end{itemize}
