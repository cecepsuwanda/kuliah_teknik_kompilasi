% Bab 12: Intermediate Code Generation
% File ini dapat dikompilasi terpisah atau sebagai bagian dari main.tex

\chapter{Intermediate Code Generation}
\label{chap:intermediate-code}

\section{Tujuan Pembelajaran}

Setelah mempelajari bab ini, mahasiswa diharapkan mampu:
\begin{enumerate}
    \item Memahami konsep intermediate code generation dan perannya dalam kompilator
    \item Menjelaskan berbagai format intermediate representation (IR)
    \item Mengimplementasikan generator three-address code (TAC) dari AST
    \item Menangani generasi kode untuk berbagai jenis statement (assignment, if, loop)
    \item Menerapkan optimasi dasar seperti common subexpression elimination
    \item Memahami representasi quadruples dan implementasinya
\end{enumerate}

\section{Pengenalan Intermediate Code Generation}

Setelah fase semantic analysis menghasilkan annotated AST dengan informasi tipe dan symbol table yang lengkap, kompilator perlu menghasilkan representasi intermediate yang lebih dekat ke machine code namun tetap machine-independent. Fase ini disebut \textbf{Intermediate Code Generation}.

Menurut sumber dari OpenGenus:

\begin{quote}
``Intermediate code generation transforms AST to IR (three-address code, bytecode, etc.). Design and generate intermediate code representations (e.g., three-address code, DAGs).''\cite{opengenus2024lexer}
\end{quote}

Intermediate representation (IR) memiliki karakteristik penting:
\begin{itemize}
    \item \textbf{Machine-Independent}: IR tidak bergantung pada arsitektur target tertentu, memungkinkan portabilitas
    \item \textbf{Simpler than AST}: Lebih sederhana dari AST, memudahkan optimasi dan code generation
    \item \textbf{Closer to Machine Code}: Lebih dekat ke machine code dibanding AST, memudahkan translasi ke target code
    \item \textbf{Optimization-Friendly}: Struktur yang memudahkan berbagai teknik optimasi
\end{itemize}

\subsection{Alasan Menggunakan Intermediate Code}

Penggunaan intermediate code memberikan beberapa keuntungan:

\begin{enumerate}
    \item \textbf{Portabilitas}: Satu IR dapat digunakan untuk berbagai target platform. Kompilator hanya perlu mengubah back-end untuk target baru (tanpa mengubah front-end).
    
    \item \textbf{Optimasi yang Lebih Baik}: IR yang lebih sederhana memudahkan analisis dan optimasi. Optimasi dapat dilakukan pada IR sebelum code generation.
    
    \item \textbf{Pemisahan Front-end dan Back-end}: Front-end menghasilkan IR, back-end mengkonsumsi IR. Perubahan pada satu sisi tidak mempengaruhi sisi lain.
    
    \item \textbf{Retargeting}: Untuk menambahkan dukungan target baru, cukup menambahkan code generator untuk IR tersebut.
\end{enumerate}

\section{Format Intermediate Representation}

Terdapat berbagai format IR yang umum digunakan dalam kompilator modern:

\subsection{Three-Address Code (TAC)}

Three-address code adalah format IR di mana setiap instruksi memiliki paling banyak tiga operand (dua sumber dan satu tujuan). Format ini sangat populer karena:

\begin{itemize}
    \item Sederhana dan mudah dipahami
    \item Mirip dengan assembly code
    \item Memudahkan optimasi
    \item Mudah di-generate dari AST
\end{itemize}

Contoh three-address code untuk ekspresi \texttt{x = a + b * c}:

\begin{verbatim}
t1 = b * c
t2 = a + t1
x = t2
\end{verbatim}

Setiap baris adalah satu instruksi dengan format: \texttt{result = operand1 operator operand2}

\subsection{Quadruples}

Quadruples adalah representasi struktural dari three-address code. Setiap instruksi direpresentasikan sebagai record dengan empat field:

\begin{itemize}
    \item \textbf{op}: Operator (+, -, *, /, =, jmp, jmpf, dll.)
    \item \textbf{arg1}: Operand pertama
    \item \textbf{arg2}: Operand kedua (kosong untuk unary operations)
    \item \textbf{result}: Hasil operasi (temporary atau variabel)
\end{itemize}

Contoh quadruple untuk \texttt{x = a + b * c}:

\begin{verbatim}
Quad 1: (op: *, arg1: b, arg2: c, result: t1)
Quad 2: (op: +, arg1: a, arg2: t1, result: t2)
Quad 3: (op: =, arg1: t2, arg2: _, result: x)
\end{verbatim}

Keuntungan quadruples:
\begin{itemize}
    \item Mudah untuk di-reorder (optimasi)
    \item Mudah untuk di-optimize (common subexpression elimination)
    \item Struktur data yang jelas untuk manipulasi
\end{itemize}

\subsection{Format IR Lainnya}

Selain TAC dan quadruples, terdapat format IR lainnya:

\begin{itemize}
    \item \textbf{Static Single Assignment (SSA)}: Setiap variabel hanya di-assign sekali, memudahkan optimasi data-flow
    \item \textbf{Bytecode}: Untuk bahasa yang diinterpretasi (Java bytecode, Python bytecode)
    \item \textbf{DAG (Directed Acyclic Graph)}: Representasi graf untuk ekspresi, memudahkan common subexpression elimination
    \item \textbf{LLVM IR}: Format IR modern yang digunakan oleh LLVM compiler infrastructure
\end{itemize}

\section{Implementasi TAC Generator dari AST}

Implementasi generator TAC dari AST dilakukan dengan melakukan traversal pada AST secara recursive. Untuk setiap node AST, generator menghasilkan instruksi TAC yang sesuai.

\subsection{Struktur Data untuk TAC}

Sebelum mengimplementasikan generator, kita perlu mendefinisikan struktur data untuk menyimpan TAC:

\begin{lstlisting}[language=C++, caption=Struktur data untuk Quadruple]
struct Quad {
    std::string op;      // Operator
    std::string arg1;    // Operand pertama
    std::string arg2;    // Operand kedua (kosong jika unary)
    std::string result;  // Hasil (temporary atau variabel)
    
    Quad(const std::string& op, const std::string& arg1, 
         const std::string& arg2, const std::string& result)
        : op(op), arg1(arg1), arg2(arg2), result(result) {}
};

class QuadList {
private:
    std::vector<Quad> quads;
    int tempCounter;
    int labelCounter;
    
public:
    QuadList() : tempCounter(0), labelCounter(0) {}
    
    void emit(const Quad& quad) {
        quads.push_back(quad);
    }
    
    std::string newTemp() {
        return "t" + std::to_string(tempCounter++);
    }
    
    std::string newLabel() {
        return "L" + std::to_string(labelCounter++);
    }
    
    void print() const {
        for (size_t i = 0; i < quads.size(); i++) {
            std::cout << i << ": (" << quads[i].op << ", "
                      << quads[i].arg1 << ", " << quads[i].arg2 
                      << ", " << quads[i].result << ")\n";
        }
    }
};
\end{lstlisting}

\subsection{Generator untuk Ekspresi}

Generator untuk ekspresi aritmatika bekerja secara recursive:

\begin{lstlisting}[language=C++, caption=Generator TAC untuk ekspresi]
class ASTNode {
public:
    virtual std::string genCode(QuadList& quads, SymbolTable& symtab) = 0;
};

class ASTConst : public ASTNode {
    int value;
public:
    std::string genCode(QuadList& quads, SymbolTable& symtab) override {
        std::string temp = quads.newTemp();
        quads.emit(Quad("load_const", std::to_string(value), "", temp));
        return temp;
    }
};

class ASTVar : public ASTNode {
    std::string name;
public:
    std::string genCode(QuadList& quads, SymbolTable& symtab) override {
        return name;  // Langsung return nama variabel
    }
};

class ASTBinaryOp : public ASTNode {
    std::string op;
    ASTNode* left;
    ASTNode* right;
public:
    std::string genCode(QuadList& quads, SymbolTable& symtab) override {
        // Generate code untuk left dan right subtree
        std::string leftTemp = left->genCode(quads, symtab);
        std::string rightTemp = right->genCode(quads, symtab);
        
        // Generate temporary untuk hasil
        std::string resultTemp = quads.newTemp();
        
        // Emit quadruple
        quads.emit(Quad(op, leftTemp, rightTemp, resultTemp));
        
        return resultTemp;
    }
};
\end{lstlisting}

\subsection{Generator untuk Assignment}

Assignment statement menghasilkan instruksi assignment:

\begin{lstlisting}[language=C++, caption=Generator TAC untuk assignment]
class ASTAssign : public ASTNode {
    std::string varName;
    ASTNode* expr;
public:
    std::string genCode(QuadList& quads, SymbolTable& symtab) override {
        // Generate code untuk ekspresi
        std::string exprTemp = expr->genCode(quads, symtab);
        
        // Emit assignment
        quads.emit(Quad("=", exprTemp, "", varName));
        
        return varName;
    }
};
\end{lstlisting}

\section{Handling Control Flow Statements}

Generasi kode untuk control flow statements (if, while, for) memerlukan label dan jump instructions.

\subsection{If-Then-Else Statement}

Untuk if statement, kita perlu:
\begin{itemize}
    \item Label untuk else branch (jika ada)
    \item Label untuk end of if statement
    \item Conditional jump berdasarkan kondisi
    \item Unconditional jump untuk skip else branch
\end{itemize}

\begin{lstlisting}[language=C++, caption=Generator TAC untuk if statement]
class ASTIf : public ASTNode {
    ASTNode* condition;
    ASTNode* thenBranch;
    ASTNode* elseBranch;  // bisa null
public:
    std::string genCode(QuadList& quads, SymbolTable& symtab) override {
        // Generate code untuk kondisi
        std::string condTemp = condition->genCode(quads, symtab);
        
        std::string elseLabel = quads.newLabel();
        std::string endLabel = quads.newLabel();
        
        // Jump to else jika kondisi false
        quads.emit(Quad("jmpf", condTemp, "", elseLabel));
        
        // Generate code untuk then branch
        thenBranch->genCode(quads, symtab);
        
        // Jump to end (skip else)
        quads.emit(Quad("jmp", "", "", endLabel));
        
        // Else label
        quads.emit(Quad("label", "", "", elseLabel));
        
        // Generate code untuk else branch (jika ada)
        if (elseBranch != nullptr) {
            elseBranch->genCode(quads, symtab);
        }
        
        // End label
        quads.emit(Quad("label", "", "", endLabel));
        
        return "";  // if statement tidak menghasilkan nilai
    }
};
\end{lstlisting}

Contoh output untuk \texttt{if (x > 0) y = 1; else y = 0;}:

\begin{verbatim}
t1 = x > 0
jmpf t1, L0
t2 = 1
y = t2
jmp L1
label L0
t3 = 0
y = t3
label L1
\end{verbatim}

\subsection{While Loop}

While loop memerlukan:
\begin{itemize}
    \item Label untuk start of loop
    \item Label untuk end of loop
    \item Conditional jump untuk exit loop
    \item Unconditional jump untuk kembali ke start
\end{itemize}

\begin{lstlisting}[language=C++, caption=Generator TAC untuk while loop]
class ASTWhile : public ASTNode {
    ASTNode* condition;
    ASTNode* body;
public:
    std::string genCode(QuadList& quads, SymbolTable& symtab) override {
        std::string startLabel = quads.newLabel();
        std::string endLabel = quads.newLabel();
        
        // Start label
        quads.emit(Quad("label", "", "", startLabel));
        
        // Generate code untuk kondisi
        std::string condTemp = condition->genCode(quads, symtab);
        
        // Jump to end jika kondisi false
        quads.emit(Quad("jmpf", condTemp, "", endLabel));
        
        // Generate code untuk body
        body->genCode(quads, symtab);
        
        // Jump back to start
        quads.emit(Quad("jmp", "", "", startLabel));
        
        // End label
        quads.emit(Quad("label", "", "", endLabel));
        
        return "";
    }
};
\end{lstlisting}

Contoh output untuk \texttt{while (i < 10) \{ i = i + 1; \}}:

\begin{verbatim}
label L0
t1 = i < 10
jmpf t1, L1
t2 = i + 1
i = t2
jmp L0
label L1
\end{verbatim}

\subsection{For Loop}

For loop dapat di-translate menjadi while loop atau di-generate langsung. Implementasi sebagai while loop:

\begin{verbatim}
for (init; condition; update) {
    body
}
\end{verbatim}

Menjadi:

\begin{verbatim}
init
label L0
jmpf condition, L1
body
update
jmp L0
label L1
\end{verbatim}

\section{Handling Function Calls}

Function calls memerlukan:
\begin{itemize}
    \item Evaluasi arguments
    \item Parameter passing (param instructions)
    \item Call instruction
    \item Return value handling
\end{itemize}

\begin{lstlisting}[language=C++, caption=Generator TAC untuk function call]
class ASTFunctionCall : public ASTNode {
    std::string funcName;
    std::vector<ASTNode*> arguments;
public:
    std::string genCode(QuadList& quads, SymbolTable& symtab) override {
        // Generate code untuk setiap argument
        for (auto arg : arguments) {
            std::string argTemp = arg->genCode(quads, symtab);
            quads.emit(Quad("param", argTemp, "", ""));
        }
        
        // Generate temporary untuk return value
        std::string resultTemp = quads.newTemp();
        
        // Emit call instruction
        quads.emit(Quad("call", funcName, 
                       std::to_string(arguments.size()), 
                       resultTemp));
        
        return resultTemp;
    }
};
\end{lstlisting}

\section{Optimasi Dasar: Common Subexpression Elimination}

Common subexpression elimination (CSE) adalah optimasi yang mengidentifikasi dan menghilangkan komputasi ekspresi yang sama yang dilakukan berulang kali.

\subsection{Konsep Common Subexpression Elimination}

Contoh ekspresi yang dapat dioptimasi:

\begin{verbatim}
x = a + b * c
y = a + b * c  // b * c dihitung dua kali
\end{verbatim}

Setelah optimasi:

\begin{verbatim}
t1 = b * c
x = a + t1
y = a + t1  // Menggunakan t1 yang sudah dihitung
\end{verbatim}

\subsection{Implementasi CSE Sederhana}

CSE dapat diimplementasikan dengan:
\begin{enumerate}
    \item Mencari ekspresi yang sama dalam basic block
    \item Mengganti ekspresi kedua dan seterusnya dengan temporary yang sudah dihitung
    \item Menghapus komputasi yang redundant
\end{enumerate}

Algoritma sederhana untuk CSE:

\begin{lstlisting}[language=C++, caption=Algoritma CSE sederhana]
void eliminateCommonSubexpressions(QuadList& quads) {
    // Map untuk menyimpan ekspresi yang sudah dihitung
    std::map<std::pair<std::string, std::pair<std::string, std::string>>, 
             std::string> exprMap;
    
    for (auto& quad : quads.quads) {
        // Skip non-computational operations
        if (quad.op == "=" || quad.op == "jmp" || 
            quad.op == "jmpf" || quad.op == "label") {
            continue;
        }
        
        // Buat key dari operator dan operands
        auto key = std::make_pair(quad.op, 
                                 std::make_pair(quad.arg1, quad.arg2));
        
        // Cek apakah ekspresi ini sudah dihitung sebelumnya
        if (exprMap.find(key) != exprMap.end()) {
            // Ganti result dengan temporary yang sudah ada
            std::string existingTemp = exprMap[key];
            // Update semua penggunaan result dengan existingTemp
            replaceUses(quads, quad.result, existingTemp);
            // Hapus quad ini (atau mark sebagai redundant)
            markAsRedundant(quad);
        } else {
            // Simpan ekspresi ini
            exprMap[key] = quad.result;
        }
    }
}
\end{lstlisting}

\subsection{Contoh Optimasi CSE}

Sebelum optimasi:

\begin{verbatim}
t1 = b * c
t2 = a + t1
x = t2
t3 = b * c    // Common subexpression!
t4 = a + t3   // Common subexpression!
y = t4
\end{verbatim}

Setelah optimasi:

\begin{verbatim}
t1 = b * c
t2 = a + t1
x = t2
y = t2        // Menggunakan t2 yang sudah dihitung
\end{verbatim}

\section{Integrasi dengan Fase Sebelumnya}

Intermediate code generation terintegrasi dengan fase-fase sebelumnya:

\subsection{Input dari Semantic Analysis}

Generator IR menerima:
\begin{itemize}
    \item \textbf{Annotated AST}: AST dengan informasi tipe pada setiap node
    \item \textbf{Symbol Table}: Informasi tentang variabel, fungsi, dan tipe
    \item \textbf{Type Information}: Informasi tipe untuk setiap ekspresi
\end{itemize}

\subsection{Output untuk Code Generation}

Generator IR menghasilkan:
\begin{itemize}
    \item \textbf{Quadruple List}: Daftar instruksi IR
    \item \textbf{Label Information}: Informasi tentang label yang digunakan
    \item \textbf{Temporary Variables}: Daftar temporary yang digunakan
\end{itemize}

\section{Contoh Lengkap: Ekspresi Kompleks}

Mari kita lihat contoh lengkap generasi TAC untuk ekspresi kompleks:

\subsection{Source Code}

\begin{verbatim}
int a, b, c, x, y;
x = a + b * c;
y = (a + b) * c;
if (x > y) {
    x = x + 1;
} else {
    y = y + 1;
}
\end{verbatim}

\subsection{Generated TAC}

\begin{verbatim}
// Assignment: x = a + b * c
t1 = b * c
t2 = a + t1
x = t2

// Assignment: y = (a + b) * c
t3 = a + b
t4 = t3 * c
y = t4

// If statement: if (x > y) ...
t5 = x > y
jmpf t5, L0
t6 = x + 1
x = t6
jmp L1
label L0
t7 = y + 1
y = t7
label L1
\end{verbatim}

\section{Kesimpulan}

Dalam bab ini, kita telah mempelajari:

\begin{enumerate}
    \item Intermediate code generation adalah fase yang mengubah AST menjadi IR yang lebih dekat ke machine code
    \item Three-address code (TAC) dan quadruples adalah format IR yang populer
    \item Generator TAC bekerja dengan recursive traversal pada AST
    \item Control flow statements memerlukan label dan jump instructions
    \item Common subexpression elimination adalah optimasi dasar yang penting
    \item IR memungkinkan portabilitas dan optimasi yang lebih baik
\end{enumerate}

Pemahaman tentang intermediate code generation menjadi dasar penting untuk fase code generation dan optimasi yang akan dipelajari dalam bab-bab selanjutnya.

\section{Latihan}

\begin{enumerate}
    \item Buatlah TAC untuk ekspresi berikut:
    \begin{itemize}
        \item \texttt{a = b + c * d - e}
        \item \texttt{x = (a + b) * (c - d)}
        \item \texttt{y = -a + b * -c}
    \end{itemize}
    
    \item Implementasikan generator TAC untuk:
    \begin{itemize}
        \item Unary operations (negation, logical NOT)
        \item Array access (\texttt{array[index]})
        \item Member access (\texttt{object.member})
    \end{itemize}
    
    \item Buatlah TAC untuk program berikut:
    \begin{verbatim}
    int i, sum;
    sum = 0;
    for (i = 1; i <= 10; i = i + 1) {
        sum = sum + i;
    }
    \end{verbatim}
    
    \item Implementasikan common subexpression elimination untuk basic block. Test dengan contoh:
    \begin{verbatim}
    x = a + b * c
    y = a + b * c
    z = (a + b) * c
    w = (a + b) * c
    \end{verbatim}
    
    \item Jelaskan perbedaan antara three-address code dan quadruples. Kapan quadruples lebih menguntungkan?
    
    \item Buatlah generator TAC untuk switch statement. Bagaimana cara menangani multiple cases?
    
    \item Implementasikan optimasi constant folding pada TAC generator. Contoh: \texttt{x = 3 + 5} langsung menjadi \texttt{x = 8}
    
    \item Bandingkan pendekatan top-down (generate sambil traverse) dan bottom-up (build IR structure dulu) untuk TAC generation. Apa keuntungan masing-masing?
\end{enumerate}

\section{Referensi dan Bahan Bacaan Lanjutan}

Untuk memperdalam pemahaman tentang intermediate code generation, mahasiswa disarankan membaca:

\begin{itemize}
    \item \textbf{Dragon Book}: Aho, Lam, Sethi, \& Ullman (2006). \textit{Compilers: Principles, Techniques, and Tools} \cite{aho2006compilers} - Bab 6: Intermediate-Code Generation
    
    \item \textbf{Engineering a Compiler}: Cooper \& Torczon (2011) \cite{cooper2011engineering} - Bab 6: The Procedure Abstraction dan Bab 7: Code Shape
    
    \item \textbf{SDSU CS 524}: Intermediate Code Generation \footnote{\url{https://stewart.sdsu.edu/cs524/spr08/lects/ch6_IntermediateCodeGen.html}}
    
    \item \textbf{GeeksforGeeks}: Three Address Code \footnote{\url{https://www.geeksforgeeks.org/three-address-code-compiler/}}
    
    \item \textbf{LinkÃ¶ping University}: Lab 6 - Intermediate Code Generation \footnote{\url{https://www.ida.liu.se/~TDDB44/laboratories/instructions/lab6.html}}
    
    \item \textbf{Shasank's Engineering Notes}: Module 7 - Intermediate Code Generation \footnote{\url{https://shasankp000.github.io/CSE-Engineering-Notes/Compiler_Design/Module-7----Intermediate-Code-Generation}}
    
    \item \textbf{Wikipedia - Intermediate Representation}: \footnote{\url{https://en.wikipedia.org/wiki/Intermediate_representation}}
    
    \item \textbf{LLVM Language Reference}: \footnote{\url{https://llvm.org/docs/LangRef.html}} - Untuk mempelajari format IR modern
\end{itemize}
