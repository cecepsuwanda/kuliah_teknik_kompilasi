% Bab 13: Runtime Environment dan Memory Management
% File ini dapat dikompilasi terpisah atau sebagai bagian dari main.tex

\chapter{Runtime Environment dan Memory Management}
\label{chap:runtime-environment}

\section{Tujuan Pembelajaran}

Setelah mempelajari bab ini, mahasiswa diharapkan mampu:
\begin{enumerate}
    \item Memahami konsep runtime environment dan perannya dalam eksekusi program
    \item Menjelaskan struktur activation record (stack frame) dan komponen-komponennya
    \item Mengimplementasikan simulator runtime stack untuk function calls
    \item Memahami memory layout: static, stack, dan heap
    \item Menjelaskan mekanisme heap management dan garbage collection
    \item Mengimplementasikan manajemen memory untuk runtime environment sederhana
\end{enumerate}

\section{Pengenalan Runtime Environment}

Runtime environment adalah konteks di mana program yang telah dikompilasi dieksekusi. Menurut sumber dari StudyLib:

\begin{quote}
``Runtime environment: stack, heap, activation records; garbage collection intro. Managing run-time structures (activation records, memory layout, symbol tables).''\cite{studylib2024obe}
\end{quote}

Runtime environment mencakup:
\begin{itemize}
    \item \textbf{Memory Organization}: Bagaimana memory diorganisir dan dialokasikan untuk berbagai jenis data
    \item \textbf{Calling Conventions}: Mekanisme pemanggilan fungsi, passing parameter, dan return values
    \item \textbf{Scope Management}: Bagaimana variabel diakses berdasarkan scope-nya (local, non-local, global)
    \item \textbf{Memory Management}: Alokasi dan dealokasi memory untuk variabel dan data structures
\end{itemize}

Runtime environment harus dirancang dengan hati-hati karena mempengaruhi:
\begin{itemize}
    \item Efisiensi eksekusi program
    \item Keamanan memory (memory safety)
    \item Kemampuan mendukung fitur bahasa (recursion, nested functions, closures, dll.)
    \item Portabilitas antar platform
\end{itemize}

\section{Memory Layout}

Program yang dieksekusi memiliki memory layout yang terorganisir menjadi beberapa region. Setiap region memiliki karakteristik dan tujuan penggunaan yang berbeda.

\subsection{Memory Regions}

Memory address space program biasanya dibagi menjadi beberapa region utama:

\begin{enumerate}
    \item \textbf{Code/Text Segment}: Berisi instruksi machine code yang dihasilkan compiler. Region ini biasanya read-only dan tidak dapat dimodifikasi saat runtime.
    
    \item \textbf{Static/Global Data}: Berisi variabel global dan static yang dialokasikan pada compile time. Region ini memiliki ukuran tetap dan alamat yang diketahui saat compile time.
    
    \item \textbf{Stack}: Region untuk activation records (stack frames) dari fungsi-fungsi yang sedang aktif. Stack tumbuh ke bawah (dari high address ke low address) dan dikelola secara otomatis.
    
    \item \textbf{Heap}: Region untuk dynamic memory allocation. Heap tumbuh ke atas (dari low address ke high address) dan dikelola secara manual atau melalui garbage collector.
\end{enumerate}

Gambar \ref{fig:memory-layout} menunjukkan layout memory yang khas:

\begin{figure}[H]
\centering
\begin{verbatim}
High Address
    +-----------------+
    |   Command Line  |
    |     Arguments   |
    +------------------+
    |      Stack      | <- Tumbuh ke bawah
    |   (grows down)  |
    |                 |
    |       ↓         |
    |                 |
    |       ↑         |
    |   (grows up)    |
    |      Heap       | <- Tumbuh ke atas
    +------------------+
    |  BSS (uninit)   |
    |  Data (init)    |
    +------------------+
    |  Text/Code      | <- Read-only
Low Address
\end{verbatim}
\caption{Memory layout khas untuk program yang dieksekusi}
\label{fig:memory-layout}
\end{figure}

\subsection{Static Memory Allocation}

Static memory allocation terjadi pada compile time. Variabel yang dialokasikan secara static memiliki:
\begin{itemize}
    \item Alamat yang tetap dan diketahui saat compile time
    \item Lifetime yang sama dengan program (dari awal hingga akhir eksekusi)
    \item Tidak memerlukan runtime overhead untuk alokasi/dealokasi
\end{itemize}

Contoh variabel static:
\begin{itemize}
    \item Variabel global: \texttt{int global\_var;}
    \item Variabel static lokal: \texttt{static int counter;}
    \item String literals dan konstanta
\end{itemize}

Keuntungan static allocation:
\begin{itemize}
    \item Sangat efisien (tidak ada overhead runtime)
    \item Deterministik (alamat diketahui saat compile time)
    \item Tidak ada risiko memory leak
\end{itemize}

Keterbatasan:
\begin{itemize}
    \item Tidak mendukung recursion dengan baik
    \item Ukuran harus diketahui saat compile time
    \item Tidak fleksibel untuk dynamic data structures
\end{itemize}

\subsection{Stack-Based Memory Allocation}

Stack digunakan untuk activation records dari fungsi-fungsi yang sedang aktif. Stack allocation memiliki karakteristik:
\begin{itemize}
    \item \textbf{Automatic}: Alokasi dan dealokasi terjadi otomatis saat fungsi dipanggil dan kembali
    \item \textbf{LIFO}: Last In First Out - fungsi terakhir dipanggil adalah yang pertama kembali
    \item \textbf{Fast}: Alokasi/dealokasi sangat cepat (hanya mengubah stack pointer)
    \item \textbf{Limited Lifetime}: Data di stack hanya hidup selama fungsi aktif
\end{itemize}

Stack sangat cocok untuk:
\begin{itemize}
    \item Local variables
    \item Function parameters
    \item Return addresses
    \item Temporary values
\end{itemize}

Contoh penggunaan stack:
\begin{lstlisting}[language=C++, caption={Contoh program yang menggunakan stack}]
int factorial(int n) {
    if (n <= 1) return 1;
    int temp = n * factorial(n - 1);  // Recursive call
    return temp;
}

int main() {
    int result = factorial(5);  // Stack frames untuk main dan factorial
    return 0;
}
\end{lstlisting}

\subsection{Heap-Based Memory Allocation}

Heap digunakan untuk dynamic memory allocation yang tidak dapat ditangani oleh stack. Heap allocation memiliki karakteristik:
\begin{itemize}
    \item \textbf{Manual Management}: Programmer harus secara eksplisit mengalokasikan dan membebaskan memory
    \item \textbf{Flexible Lifetime}: Object di heap dapat hidup lebih lama dari fungsi yang membuatnya
    \item \textbf{Variable Size}: Ukuran dapat ditentukan saat runtime
    \item \textbf{Slower}: Alokasi/dealokasi lebih lambat dibanding stack
\end{itemize}

Heap digunakan untuk:
\begin{itemize}
    \item Dynamic arrays dan data structures
    \item Objects yang harus hidup lebih lama dari fungsi pembuatnya
    \item Shared data structures
    \item Large objects yang tidak muat di stack
\end{itemize}

Contoh penggunaan heap:
\begin{lstlisting}[language=C++, caption={Contoh penggunaan heap}]
int* createArray(int size) {
    int* arr = new int[size];  // Alokasi di heap
    return arr;  // Pointer ke heap, valid setelah fungsi kembali
}

void useArray() {
    int* myArray = createArray(100);
    // Gunakan array...
    delete[] myArray;  // Dealokasi manual
}
\end{lstlisting}

\section{Activation Records (Stack Frames)}

Activation record (juga disebut stack frame) adalah struktur data yang digunakan untuk menyimpan informasi tentang eksekusi satu fungsi. Setiap kali fungsi dipanggil, activation record baru dibuat di stack.

\subsection{Komponen Activation Record}

Activation record biasanya berisi komponen-komponen berikut:

\begin{enumerate}
    \item \textbf{Return Address}: Alamat instruksi di caller yang harus dieksekusi setelah fungsi kembali
    
    \item \textbf{Control Link (Dynamic Link)}: Pointer ke activation record dari caller (fungsi yang memanggil)
    
    \item \textbf{Access Link (Static Link)}: Pointer ke activation record dari enclosing scope (untuk nested functions)
    
    \item \textbf{Saved Registers}: Nilai register yang harus disimpan dan dikembalikan setelah fungsi selesai
    
    \item \textbf{Parameters}: Nilai parameter yang diteruskan ke fungsi (actual parameters)
    
    \item \textbf{Local Variables}: Variabel lokal yang dideklarasikan dalam fungsi
    
    \item \textbf{Temporary Values}: Nilai sementara yang digunakan selama komputasi dalam fungsi
    
    \item \textbf{Return Value}: Nilai yang dikembalikan fungsi (jika ada)
\end{enumerate}

Gambar \ref{fig:activation-record} menunjukkan struktur activation record yang khas:

\begin{figure}[H]
\centering
\begin{verbatim}
High Address
    +---------------------+
    |  Return Address     |
    +----------------------+
    |  Control Link (FP)  | -> Activation record caller
    +----------------------+
    |  Access Link        | -> Enclosing scope (if nested)
    +----------------------+
    |  Saved Registers    |
    +----------------------+
    |  Parameters         |
    |    param1           |
    |    param2           |
    +----------------------+
    |  Local Variables    |
    |    local1           |
    |    local2           |
    +----------------------+
    |  Temporaries        |
    |    temp1            |
    |    temp2            |
    +----------------------+
    |  Return Value       |
Low Address
\end{verbatim}
\caption{Struktur activation record (stack frame)}
\label{fig:activation-record}
\end{figure}

\subsection{Calling Sequence}

Calling sequence adalah urutan instruksi yang dihasilkan compiler untuk memanggil fungsi. Terdapat dua bagian:

\subsubsection{Caller Sequence (Prologue)}

Instruksi yang dijalankan oleh caller sebelum memanggil fungsi:
\begin{enumerate}
    \item Evaluasi actual parameters (dari kanan ke kiri atau kiri ke kanan, tergantung calling convention)
    \item Push parameters ke stack (atau pass melalui register)
    \item Save caller-saved registers
    \item Push return address
    \item Transfer control ke callee (CALL instruction)
\end{enumerate}

\subsubsection{Callee Sequence (Prologue)}

Instruksi yang dijalankan oleh callee di awal fungsi:
\begin{enumerate}
    \item Save frame pointer (FP) dari caller
    \item Set FP baru ke current stack pointer (SP)
    \item Allocate space untuk local variables (adjust SP)
    \item Save callee-saved registers (jika diperlukan)
\end{enumerate}

\subsubsection{Return Sequence (Epilogue)}

Instruksi yang dijalankan saat fungsi kembali:
\begin{enumerate}
    \item Place return value (di register atau stack)
    \item Restore callee-saved registers
    \item Restore SP (deallocate local variables)
    \item Restore FP dari control link
    \item Restore return address
    \item Return control ke caller (RET instruction)
\end{enumerate}

\subsection{Contoh Calling Sequence}

Mari kita lihat contoh calling sequence untuk program sederhana:

\begin{lstlisting}[language=C++, caption={Contoh program untuk analisis calling sequence}]
int add(int x, int y) {
    int sum = x + y;
    return sum;
}

int main() {
    int a = 5;
    int b = 10;
    int result = add(a, b);
    return 0;
}
\end{lstlisting}

Assembly code yang dihasilkan (simplified):

\begin{lstlisting}[language={[x86masm]Assembler},basicstyle=\ttfamily\footnotesize,breaklines=true,breakatwhitespace=false]
main:
    push rbp              ; Save caller's frame pointer
    mov rbp, rsp          ; Set new frame pointer
    sub rsp, 16           ; Allocate space for locals (a, b, result)
    
    mov [rbp-4], 5        ; a = 5
    mov [rbp-8], 10       ; b = 10
    
    ; Call add(a, b)
    mov eax, [rbp-8]      ; Load b
    push eax              ; Push parameter 2
    mov eax, [rbp-4]      ; Load a
    push eax              ; Push parameter 1
    call add              ; Call function
    add rsp, 8            ; Clean up parameters
    mov [rbp-12], eax     ; result = return value
    
    mov eax, 0            ; return 0
    mov rsp, rbp          ; Restore stack pointer
    pop rbp                ; Restore frame pointer
    ret                    ; Return

add:
    push rbp              ; Save caller's frame pointer
    mov rbp, rsp          ; Set new frame pointer
    sub rsp, 4            ; Allocate space for local (sum)
    
    mov eax, [rbp+8]      ; Load x (parameter 1)
    add eax, [rbp+12]     ; Add y (parameter 2)
    mov [rbp-4], eax      ; sum = x + y
    mov eax, [rbp-4]      ; Load sum for return
    
    mov rsp, rbp          ; Restore stack pointer
    pop rbp                ; Restore frame pointer
    ret                    ; Return
\end{lstlisting}

\section{Implementasi Runtime Stack Simulator}

Untuk memahami runtime stack dengan lebih baik, kita akan mengimplementasikan simulator sederhana dalam C++.

\subsection{Struktur Data Activation Record}

\begin{lstlisting}[language=C++, caption={Struktur data untuk activation record}]
#include <string>
#include <vector>
#include <unordered_map>
#include <iostream>

// Representasi activation record
struct ActivationRecord {
    std::string function_name;           // Nama fungsi
    void* return_address;                // Return address (simulated)
    ActivationRecord* control_link;      // Pointer ke caller's AR
    ActivationRecord* access_link;       // Pointer ke enclosing scope
    
    // Local variables dan parameters
    std::unordered_map<std::string, int> locals;
    std::unordered_map<std::string, int> parameters;
    
    // Return value
    int return_value;
    
    ActivationRecord(const std::string& name, 
                    ActivationRecord* caller = nullptr)
        : function_name(name), 
          return_address(nullptr),
          control_link(caller),
          access_link(nullptr),
          return_value(0) {}
};
\end{lstlisting}

\subsection{Stack Manager}

\begin{lstlisting}[language=C++, caption={Implementasi runtime stack manager}]
class RuntimeStack {
private:
    ActivationRecord* top;  // Top of stack (current activation)
    int frame_count;
    
public:
    RuntimeStack() : top(nullptr), frame_count(0) {}
    
    // Push activation record baru (function call)
    void pushFrame(const std::string& function_name) {
        ActivationRecord* new_frame = 
            new ActivationRecord(function_name, top);
        new_frame->access_link = top;  // Simplified: same as control link
        top = new_frame;
        frame_count++;
        
        std::cout << ">>> Called: " << function_name 
                  << " (Frame #" << frame_count << ")\n";
        printStack();
    }
    
    // Pop activation record (function return)
    void popFrame() {
        if (top == nullptr) {
            std::cerr << "Error: Cannot pop from empty stack!\n";
            return;
        }
        
        std::string func_name = top->function_name;
        int ret_val = top->return_value;
        
        ActivationRecord* old_top = top;
        top = top->control_link;
        delete old_top;
        frame_count--;
        
        std::cout << "<<< Returned from: " << func_name 
                  << " (return value: " << ret_val << ")\n";
        printStack();
    }
    
    // Get current activation record
    ActivationRecord* getCurrentFrame() {
        return top;
    }
    
    // Set local variable di current frame
    void setLocal(const std::string& name, int value) {
        if (top == nullptr) {
            std::cerr << "Error: No active frame!\n";
            return;
        }
        top->locals[name] = value;
        std::cout << "  Set local: " << name << " = " << value << "\n";
    }
    
    // Get local variable dari current frame atau enclosing scopes
    int getLocal(const std::string& name) {
        ActivationRecord* frame = top;
        while (frame != nullptr) {
            if (frame->locals.find(name) != frame->locals.end()) {
                return frame->locals[name];
            }
            frame = frame->access_link;  // Check enclosing scope
        }
        std::cerr << "Error: Variable '" << name 
                  << "' not found!\n";
        return 0;
    }
    
    // Set parameter
    void setParameter(const std::string& name, int value) {
        if (top == nullptr) {
            std::cerr << "Error: No active frame!\n";
            return;
        }
        top->parameters[name] = value;
        std::cout << "  Set parameter: " << name << " = " << value << "\n";
    }
    
    // Set return value
    void setReturnValue(int value) {
        if (top == nullptr) {
            std::cerr << "Error: No active frame!\n";
            return;
        }
        top->return_value = value;
        std::cout << "  Set return value: " << value << "\n";
    }
    
    // Print stack untuk debugging
    void printStack() {
        std::cout << "Stack (top to bottom):\n";
        ActivationRecord* frame = top;
        int level = 0;
        while (frame != nullptr) {
            std::cout << "  [" << level << "] " 
                      << frame->function_name << "\n";
            frame = frame->control_link;
            level++;
        }
        std::cout << "\n";
    }
    
    ~RuntimeStack() {
        while (top != nullptr) {
            popFrame();
        }
    }
};
\end{lstlisting}

\subsection{Contoh Penggunaan Simulator}

\begin{lstlisting}[language=C++, caption={Contoh penggunaan runtime stack simulator}]
int main() {
    RuntimeStack stack;
    
    // Simulasi: main() calls factorial(5)
    stack.pushFrame("main");
    stack.setLocal("n", 5);
    
    // Call factorial(5)
    stack.pushFrame("factorial");
    stack.setParameter("n", 5);
    
    // Recursive call: factorial(4)
    stack.pushFrame("factorial");
    stack.setParameter("n", 4);
    
    // Recursive call: factorial(3)
    stack.pushFrame("factorial");
    stack.setParameter("n", 3);
    
    // Base case: factorial(1) returns 1
    stack.setReturnValue(1);
    stack.popFrame();
    
    // factorial(3) = 3 * factorial(2) = 3 * 2 = 6
    // (simplified, actual would need more frames)
    stack.setReturnValue(6);
    stack.popFrame();
    
    stack.setReturnValue(24);
    stack.popFrame();
    
    stack.setReturnValue(120);
    stack.popFrame();
    
    // main returns
    stack.popFrame();
    
    return 0;
}
\end{lstlisting}

\section{Heap Memory Management}

Heap memory management adalah proses mengalokasikan dan membebaskan memory di heap secara dinamis. Terdapat dua pendekatan utama:

\subsection{Manual Memory Management}

Dalam manual memory management (seperti C/C++), programmer harus secara eksplisit:
\begin{itemize}
    \item Mengalokasikan memory: \texttt{malloc()}, \texttt{new}
    \item Membebaskan memory: \texttt{free()}, \texttt{delete}
\end{itemize}

Keuntungan:
\begin{itemize}
    \item Kontrol penuh atas memory
    \item Tidak ada overhead garbage collector
    \item Predictable performance
\end{itemize}

Kekurangan:
\begin{itemize}
    \item Rentan terhadap memory leaks
    \item Dangling pointers
    \item Double free errors
    \item Memory fragmentation
\end{itemize}

\subsection{Allocation Algorithms}

Heap manager menggunakan berbagai algoritma untuk mengalokasikan memory:

\subsubsection{First Fit}

Mencari block pertama yang cukup besar:
\begin{itemize}
    \item Cepat (tidak perlu mencari semua)
    \item Dapat menyebabkan fragmentation
\end{itemize}

\subsubsection{Best Fit}

Mencari block terkecil yang cukup besar:
\begin{itemize}
    \item Mengurangi wasted space
    \item Lebih lambat (harus mencari semua)
    \item Dapat menyebabkan banyak small fragments
\end{itemize}

\subsubsection{Worst Fit}

Mencari block terbesar:
\begin{itemize}
    \item Meninggalkan large free blocks
    \item Dapat mengurangi fragmentation kecil
\end{itemize}

\subsubsection{Buddy Allocation}

Membagi memory menjadi blocks dengan ukuran power of 2:
\begin{itemize}
    \item Mudah untuk merge adjacent blocks
    \item Dapat menyebabkan internal fragmentation
\end{itemize}

\subsection{Garbage Collection}

Garbage collection adalah automatic memory management yang membebaskan memory yang tidak lagi digunakan. Menurut sumber dari StudyLib:

\begin{quote}
``Runtime environment: stack, heap, activation records; garbage collection intro. Managing run-time structures (activation records, memory layout, symbol tables).''\cite{studylib2024obe}
\end{quote}

\subsubsection{Konsep Garbage Collection}

Garbage collector mengidentifikasi dan membebaskan memory yang tidak lagi dapat diakses (unreachable) dari program. Object dianggap garbage jika:
\begin{itemize}
    \item Tidak ada pointer/reference yang menunjuk ke object tersebut
    \item Tidak dapat diakses dari root set (stack, global variables, registers)
\end{itemize}

\subsubsection{Strategi Garbage Collection}

\paragraph{Mark and Sweep}
\begin{enumerate}
    \item \textbf{Mark Phase}: Traverse dari root set, mark semua reachable objects
    \item \textbf{Sweep Phase}: Scan semua objects, free yang tidak di-mark
\end{enumerate}

Keuntungan:
\begin{itemize}
    \item Dapat menangani cyclic references
    \item Tidak memerlukan memory compaction
\end{itemize}

Kekurangan:
\begin{itemize}
    \item Dapat menyebabkan fragmentation
    \item Stop-the-world pauses
\end{itemize}

\paragraph{Reference Counting}
Setiap object memiliki counter yang menghitung jumlah reference ke object tersebut. Ketika counter menjadi 0, object di-free.

Keuntungan:
\begin{itemize}
    \item Incremental (tidak perlu stop-the-world)
    \item Memory dibebaskan segera saat tidak digunakan
\end{itemize}

Kekurangan:
\begin{itemize}
    \item Tidak dapat menangani cyclic references
    \item Overhead untuk setiap assignment
\end{itemize}

\paragraph{Copying Collector (Generational GC)}
Memory dibagi menjadi young generation dan old generation. Young objects yang survive beberapa collections dipromote ke old generation.

Keuntungan:
\begin{itemize}
    \item Efisien untuk short-lived objects
    \item Automatic compaction
\end{itemize}

Kekurangan:
\begin{itemize}
    \item Memerlukan extra memory (copying)
    \item Overhead untuk promotion
\end{itemize}

\subsubsection{Implementasi Sederhana Mark and Sweep}

Berikut adalah implementasi sederhana mark-and-sweep garbage collector:

\begin{lstlisting}[language=C++, caption={Implementasi sederhana mark-and-sweep GC}]
#include <vector>
#include <unordered_set>

class GCObject {
public:
    bool marked;
    std::vector<GCObject*> references;
    
    GCObject() : marked(false) {}
    virtual ~GCObject() {}
    
    void addReference(GCObject* obj) {
        references.push_back(obj);
    }
};

class SimpleGC {
private:
    std::vector<GCObject*> heap;
    std::vector<GCObject*> roots;  // Root set (stack, globals)
    
public:
    // Allocate new object
    GCObject* allocate() {
        GCObject* obj = new GCObject();
        heap.push_back(obj);
        return obj;
    }
    
    // Add to root set
    void addRoot(GCObject* obj) {
        roots.push_back(obj);
    }
    
    // Mark phase: mark all reachable objects
    void mark() {
        std::vector<GCObject*> worklist = roots;
        
        while (!worklist.empty()) {
            GCObject* obj = worklist.back();
            worklist.pop_back();
            
            if (!obj->marked) {
                obj->marked = true;
                // Add all references to worklist
                for (GCObject* ref : obj->references) {
                    if (!ref->marked) {
                        worklist.push_back(ref);
                    }
                }
            }
        }
    }
    
    // Sweep phase: free unmarked objects
    void sweep() {
        auto it = heap.begin();
        while (it != heap.end()) {
            GCObject* obj = *it;
            if (!obj->marked) {
                delete obj;
                it = heap.erase(it);
            } else {
                obj->marked = false;  // Reset for next collection
                ++it;
            }
        }
    }
    
    // Run garbage collection
    void collect() {
        mark();
        sweep();
    }
    
    ~SimpleGC() {
        for (GCObject* obj : heap) {
            delete obj;
        }
    }
};
\end{lstlisting}

\section{Memory Layout untuk Program Contoh}

Mari kita analisis memory layout untuk program yang lebih kompleks:

\begin{lstlisting}[language=C++, caption={Program contoh untuk analisis memory layout}]
int global_var = 100;           // Static/Global
static int static_var = 200;    // Static

int* createArray(int size) {    // Function
    int* arr = new int[size];   // Heap allocation
    return arr;
}

int factorial(int n) {         // Function
    static int counter = 0;     // Static local
    counter++;
    
    if (n <= 1) return 1;
    int temp = n * factorial(n - 1);  // Stack: recursive
    return temp;
}

int main() {                    // Function
    int local_a = 10;           // Stack: local variable
    int local_b = 20;           // Stack: local variable
    
    int* heap_array = createArray(100);  // Heap allocation
    
    int result = factorial(5);  // Stack: recursive calls
    
    delete[] heap_array;        // Heap deallocation
    return 0;
}
\end{lstlisting}

Memory layout saat eksekusi:

\begin{verbatim}
High Address
    +---------------------+
    |  Stack (grows down) |
    |                     |
    |  [factorial(1) AR]  | <- Top of stack
    |    n = 1            |
    |    temp = ?          |
    |    return addr       |
    +----------------------+
    |  [factorial(2) AR]  |
    |    n = 2            |
    |    temp = ?          |
    +----------------------+
    |  ...                |
    +----------------------+
    |  [factorial(5) AR]  |
    |    n = 5            |
    |    temp = ?          |
    +----------------------+
    |  [main AR]          |
    |    local_a = 10     |
    |    local_b = 20     |
    |    heap_array = ptr |
    |    result = ?        |
    +----------------------+
    |                     |
    |  (free space)       |
    |                     |
    +----------------------+
    |  Heap (grows up)    |
    |  [heap_array[100]]  | <- 100 integers
    +----------------------+
    |  BSS                |
    |  (uninitialized)    |
    +----------------------+
    |  Data (initialized) |
    |    global_var = 100 |
    |    static_var = 200 |
    |    counter = ?       |
    +----------------------+
    |  Text/Code          |
    |  (instructions)     |
Low Address
\end{verbatim}

\section{Kesimpulan}

Dalam bab ini, kita telah mempelajari:

\begin{enumerate}
    \item Runtime environment adalah konteks eksekusi program yang mencakup memory organization, calling conventions, dan memory management
    
    \item Memory layout terdiri dari code segment, static/global data, stack, dan heap, masing-masing dengan karakteristik dan tujuan penggunaan yang berbeda
    
    \item Activation records (stack frames) menyimpan informasi tentang eksekusi fungsi, termasuk parameters, local variables, return address, dan links
    
    \item Stack-based allocation cocok untuk local variables dengan automatic management, sementara heap allocation diperlukan untuk dynamic data dengan flexible lifetime
    
    \item Garbage collection adalah teknik automatic memory management yang membebaskan unreachable objects, dengan berbagai strategi seperti mark-and-sweep, reference counting, dan generational GC
\end{enumerate}

Pemahaman tentang runtime environment dan memory management sangat penting untuk:
\begin{itemize}
    \item Merancang compiler yang efisien
    \item Memahami bagaimana program dieksekusi
    \item Mengoptimalkan penggunaan memory
    \item Mengimplementasikan fitur bahasa seperti recursion, closures, dan dynamic allocation
\end{itemize}

\section{Latihan}

\begin{enumerate}
    \item Jelaskan perbedaan antara static, stack, dan heap allocation. Berikan contoh penggunaan masing-masing.
    
    \item Buatlah diagram activation records untuk program berikut saat \texttt{factorial(3)} sedang dieksekusi:
    \begin{lstlisting}[language=C++]
    int factorial(int n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    }
    
    int main() {
        int result = factorial(3);
        return 0;
    }
    \end{lstlisting}
    
    \item Implementasikan runtime stack simulator yang dapat menangani:
    \begin{itemize}
        \item Function calls dengan parameters
        \item Local variables
        \item Return values
        \item Nested function calls
    \end{itemize}
    
    \item Jelaskan calling sequence untuk fungsi dengan 3 parameters. Sertakan assembly code (simplified).
    
    \item Bandingkan manual memory management dengan garbage collection. Apa keuntungan dan kekurangan masing-masing?
    
    \item Implementasikan mark-and-sweep garbage collector sederhana yang dapat:
    \begin{itemize}
        \item Mark reachable objects dari root set
        \item Sweep dan free unreachable objects
        \item Handle cyclic references
    \end{itemize}
    
    \item Analisis memory layout untuk program berikut dan identifikasi di mana setiap variabel dialokasikan:
    \begin{lstlisting}[language=C++]
    int global;
    static int static_var;
    
    void func() {
        int local;
        static int static_local;
        int* ptr = new int;
        // ...
    }
    \end{lstlisting}
    
    \item Jelaskan apa yang terjadi pada stack saat terjadi recursive call yang sangat dalam (misalnya 1000 level). Apa masalah yang mungkin terjadi?
\end{enumerate}

\section{Referensi dan Bahan Bacaan Lanjutan}

Untuk memperdalam pemahaman tentang runtime environment dan memory management, mahasiswa disarankan membaca:

\begin{itemize}
    \item \textbf{Dragon Book}: Aho, Lam, Sethi, \& Ullman (2006). \textit{Compilers: Principles, Techniques, and Tools} \cite{aho2006compilers} - Bab 7: Run-Time Environments
    
    \item \textbf{Engineering a Compiler}: Cooper \& Torczon (2011) \cite{cooper2011engineering} - Bab 6: The Procedure Abstraction
    
    \item \textbf{StudyLib - Outcomes-Based Education}: Materials tentang runtime environment dan activation records \cite{studylib2024obe}
    
    \item \textbf{UC San Diego CSE 231}: Course materials tentang compiler construction dan runtime organization \cite{ucsd2024compiler}
    
    \item \textbf{Northeastern University CS 4410}: Comprehensive compiler design course dengan coverage runtime issues \cite{neu2024compiler}
\end{itemize}
