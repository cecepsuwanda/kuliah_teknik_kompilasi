% Bab 5: Context-Free Grammar dan Pengenalan Parsing
% File ini dapat dikompilasi terpisah atau sebagai bagian dari main.tex

\chapter{Context-Free Grammar dan Pengenalan Parsing}
\label{chap:cfg-parsing}

\section{Tujuan Pembelajaran}

Setelah mempelajari bab ini, mahasiswa diharapkan mampu:
\begin{enumerate}
    \item Memahami konsep context-free grammar (CFG) dan perannya dalam syntax analysis
    \item Menjelaskan notasi BNF (Backus-Naur Form) dan EBNF (Extended BNF)
    \item Menulis grammar untuk ekspresi aritmatika dan konstruksi bahasa sederhana
    \item Memahami konsep derivation (leftmost dan rightmost)
    \item Membuat parse tree untuk kalimat yang diberikan
    \item Mengidentifikasi dan menjelaskan ambiguity dalam grammar
    \item Memahami hubungan antara grammar, parsing, dan syntax analysis
\end{enumerate}

\section{Pendahuluan}

Setelah lexical analysis menghasilkan stream token, fase berikutnya dalam kompilator adalah syntax analysis atau parsing. Menurut sumber terbuka:

\begin{quote}
``Given the stream of tokens from the lexer, syntax analysis checks whether they form a valid sequence under the language grammar. Builds a parse tree or AST that represents nested structure of language constructs.''\cite{diznr2024phases}
\end{quote}

Syntax analysis membutuhkan formal grammar untuk mendefinisikan struktur yang valid dalam bahasa pemrograman. Context-free grammar (CFG) adalah alat formal yang paling umum digunakan untuk tujuan ini karena kemampuannya dalam menangani struktur nested dan recursive yang umum ditemui dalam bahasa pemrograman.

\section{Context-Free Grammar (CFG)}

\subsection{Definisi Formal}

Context-free grammar adalah tipe formal grammar yang didefinisikan sebagai tuple \(G = (V, \Sigma, R, S)\) dimana:

\begin{itemize}
    \item \(V\) adalah himpunan \textbf{nonterminal symbols} (variabel yang dapat di-expand)
    \item \(\Sigma\) adalah himpunan \textbf{terminal symbols} (token yang tidak dapat di-expand, disjoint dari \(V\))
    \item \(R\) adalah himpunan \textbf{productions} (rules) dengan bentuk \(A \rightarrow \alpha\), dimana \(A \in V\) dan \(\alpha \in (V \cup \Sigma)^*\)
    \item \(S \in V\) adalah \textbf{start symbol}
\end{itemize}

CFG disebut "context-free" karena aturan produksi dapat diterapkan tanpa mempertimbangkan konteks di sekitar nonterminal. Artinya, jika ada produksi \(A \rightarrow \alpha\), maka \(A\) dapat diganti dengan \(\alpha\) di manapun \(A\) muncul, terlepas dari simbol di sekitarnya.

\subsection{Contoh Grammar Sederhana}

Mari kita lihat contoh grammar untuk ekspresi aritmatika sederhana:

\begin{verbatim}
E → E + T | E - T | T
T → T * F | T / F | F
F → ( E ) | number
\end{verbatim}

Dalam grammar ini:
\begin{itemize}
    \item \textbf{Nonterminals}: \(E\) (expression), \(T\) (term), \(F\) (factor)
    \item \textbf{Terminals}: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{(}, \texttt{)}, \texttt{number}
    \item \textbf{Start symbol}: \(E\)
\end{itemize}

Grammar ini dapat menghasilkan ekspresi seperti \texttt{3 + 4 * 5}, \texttt{(2 + 3) * 4}, dll.

\subsection{Perbedaan Regular Grammar dan Context-Free Grammar}

Penting untuk memahami perbedaan antara regular grammar (yang digunakan untuk lexical analysis) dan context-free grammar:

\begin{itemize}
    \item \textbf{Regular Grammar}: Hanya dapat menangani struktur linear, tidak dapat menangani nested structures seperti parentheses yang seimbang
    \item \textbf{Context-Free Grammar}: Dapat menangani struktur nested dan recursive, seperti:
    \begin{itemize}
        \item Parentheses matching: \texttt{((()))}
        \item Nested blocks: \texttt{\{\{ \}\}}
        \item Recursive function calls
        \item Nested if-statements
    \end{itemize}
\end{itemize}

Inilah mengapa CFG digunakan untuk syntax analysis, sementara regular grammar cukup untuk lexical analysis.

\section{BNF dan EBNF Notasi}

\subsection{Backus-Naur Form (BNF)}

BNF adalah notasi metalanguage yang dikembangkan oleh John Backus dan Peter Naur untuk mendefinisikan syntax bahasa pemrograman. BNF menggunakan simbol-simbol berikut:

\begin{itemize}
    \item \texttt{::=} atau \texttt{→}: Menandakan "didefinisikan sebagai"
    \item \texttt{|}: Menandakan alternatif (OR)
    \item \texttt{<nonterminal>}: Nonterminal symbol (biasanya dalam angle brackets)
    \item \texttt{terminal}: Terminal symbol (biasanya tanpa angle brackets)
\end{itemize}

Contoh grammar dalam BNF:

\begin{verbatim}
<expression> ::= <expression> + <term> 
               | <expression> - <term>
               | <term>

<term> ::= <term> * <factor>
        | <term> / <factor>
        | <factor>

<factor> ::= ( <expression> )
          | <number>
\end{verbatim}

\subsection{Extended BNF (EBNF)}

EBNF memperluas BNF dengan konstruksi tambahan untuk membuat grammar lebih kompak dan mudah dibaca:

\begin{itemize}
    \item \textbf{Optional}: \texttt{[ ... ]} atau \texttt{?} - elemen opsional (nol atau satu kali)
    \item \textbf{Repetition}: 
    \begin{itemize}
        \item \texttt{*}: Nol atau lebih kali
        \item \texttt{+}: Satu atau lebih kali
    \end{itemize}
    \item \textbf{Grouping}: \texttt{( ... )} - untuk mengelompokkan
    \item \textbf{Terminal strings}: \texttt{"..."} atau \texttt{'...'} - untuk literal strings
\end{itemize}

Contoh grammar yang sama dalam EBNF:

\begin{verbatim}
expression = term { ("+" | "-") term }
term       = factor { ("*" | "/") factor }
factor     = "(" expression ")" | number
\end{verbatim}

EBNF lebih ringkas dan mudah dibaca. Banyak spesifikasi bahasa modern menggunakan EBNF, termasuk ISO standard untuk grammar notation.

\subsection{Contoh Grammar untuk Konstruksi Bahasa}

Berikut contoh grammar untuk beberapa konstruksi bahasa pemrograman:

\subsubsection{If-Statement}

\begin{verbatim}
<if_statement> ::= if ( <expression> ) <statement>
                 | if ( <expression> ) <statement> else <statement>
\end{verbatim}

Dalam EBNF:
\begin{verbatim}
if_statement = "if" "(" expression ")" statement 
               [ "else" statement ]
\end{verbatim}

\subsubsection{While Loop}

\begin{verbatim}
<while_statement> ::= while ( <expression> ) <statement>
\end{verbatim}

Dalam EBNF:
\begin{verbatim}
while_statement = "while" "(" expression ")" statement
\end{verbatim}

\subsubsection{Variable Declaration}

\begin{verbatim}
<declaration> ::= <type> <identifier> [ = <expression> ] ;
\end{verbatim}

Dalam EBNF:
\begin{verbatim}
declaration = type identifier [ "=" expression ] ";"
\end{verbatim}

\section{Derivation}

Derivation adalah proses menerapkan aturan produksi untuk menghasilkan string terminal dari start symbol. Terdapat dua jenis derivation yang penting:

\subsection{Leftmost Derivation}

Leftmost derivation selalu mengganti nonterminal paling kiri terlebih dahulu pada setiap langkah.

Contoh untuk ekspresi \texttt{3 + 4 * 5} dengan grammar:
\begin{verbatim}
E → E + T | E - T | T
T → T * F | T / F | F
F → ( E ) | number
\end{verbatim}

Leftmost derivation:
\begin{align*}
E &\Rightarrow E + T \\
  &\Rightarrow T + T \\
  &\Rightarrow F + T \\
  &\Rightarrow \texttt{3} + T \\
  &\Rightarrow \texttt{3} + T * F \\
  &\Rightarrow \texttt{3} + F * F \\
  &\Rightarrow \texttt{3} + \texttt{4} * F \\
  &\Rightarrow \texttt{3} + \texttt{4} * \texttt{5}
\end{align*}

\subsection{Rightmost Derivation}

Rightmost derivation selalu mengganti nonterminal paling kanan terlebih dahulu pada setiap langkah.

Rightmost derivation untuk \texttt{3 + 4 * 5}:
\begin{align*}
E &\Rightarrow E + T \\
  &\Rightarrow E + T * F \\
  &\Rightarrow E + T * \texttt{5} \\
  &\Rightarrow E + F * \texttt{5} \\
  &\Rightarrow E + \texttt{4} * \texttt{5} \\
  &\Rightarrow T + \texttt{4} * \texttt{5} \\
  &\Rightarrow F + \texttt{4} * \texttt{5} \\
  &\Rightarrow \texttt{3} + \texttt{4} * \texttt{5}
\end{align*}

\subsection{Pentingnya Derivation}

Derivation penting karena:
\begin{itemize}
    \item Menunjukkan bagaimana string dihasilkan dari grammar
    \item Menentukan urutan penggantian nonterminal (penting untuk parsing)
    \item Leftmost derivation digunakan dalam top-down parsing
    \item Rightmost derivation digunakan dalam bottom-up parsing
\end{itemize}

\section{Parse Tree}

Parse tree (juga disebut derivation tree atau concrete syntax tree) adalah representasi visual dari bagaimana string diturunkan dari grammar.

\subsection{Struktur Parse Tree}

Parse tree memiliki struktur berikut:
\begin{itemize}
    \item \textbf{Root}: Labeled dengan start symbol \(S\)
    \item \textbf{Internal nodes}: Nonterminal symbols
    \item \textbf{Leaves}: Terminal symbols (dari kiri ke kanan membentuk input string)
    \item \textbf{Edges}: Menunjukkan aplikasi aturan produksi
\end{itemize}

\subsection{Contoh Parse Tree}

Untuk ekspresi \texttt{3 + 4 * 5} dengan grammar sebelumnya, parse tree-nya adalah:

\begin{verbatim}
        E
       /|\
      / | \
     E  +  T
     |     /|\
     T    / | \
     |   T  *  F
     F   |     |
     |   F     5
     3   |
         4
\end{verbatim}

Atau dalam representasi yang lebih kompak:

\begin{verbatim}
           E
      /    |    \
     E     +     T
     |          /|\
     T        T  *  F
     |        |     |
     F        F     5
     |        |
     3        4
\end{verbatim}

\subsection{Parse Tree vs Abstract Syntax Tree (AST)}

Perbedaan penting antara parse tree dan AST:

\begin{itemize}
    \item \textbf{Parse Tree (Concrete Syntax Tree)}:
    \begin{itemize}
        \item Mencakup semua detail sintaksis, termasuk punctuation
        \item Setiap node sesuai dengan aturan produksi
        \item Lebih verbose, mencakup informasi yang tidak diperlukan untuk fase selanjutnya
    \end{itemize}
    
    \item \textbf{Abstract Syntax Tree (AST)}:
    \begin{itemize}
        \item Menghilangkan detail sintaksis yang tidak relevan (seperti parentheses grouping yang sudah jelas dari struktur)
        \item Fokus pada struktur semantik program
        \item Lebih kompak dan efisien untuk analisis semantik dan code generation
    \end{itemize}
\end{itemize}

Contoh: Untuk ekspresi \texttt{3 + 4 * 5}, AST-nya lebih sederhana:

\begin{verbatim}
        +
       / \
      3   *
         / \
        4   5
\end{verbatim}

AST menghilangkan node-node intermediate seperti \(E\), \(T\), \(F\) yang tidak diperlukan untuk pemahaman semantik.

\section{Ambiguity dalam Grammar}

\subsection{Definisi Ambiguity}

Grammar dikatakan \textbf{ambiguous} jika terdapat setidaknya satu string dalam bahasa yang dapat memiliki lebih dari satu parse tree (atau derivation) yang berbeda. Ambiguity adalah masalah karena dapat menyebabkan interpretasi yang berbeda dari program yang sama.

\subsection{Contoh Grammar Ambiguous}

Pertimbangkan grammar berikut untuk ekspresi:

\begin{verbatim}
E → E + E | E * E | number
\end{verbatim}

Grammar ini ambiguous karena ekspresi \texttt{3 + 4 * 5} dapat di-parse dengan dua cara:

\textbf{Parse Tree 1} (mengasumsikan + memiliki precedence lebih tinggi):
\begin{verbatim}
        E
       /|\
      E + E
     /|   |\
    E * E 5
    |   |
    3   4
\end{verbatim}
Ini akan mengevaluasi sebagai \texttt{(3 + 4) * 5 = 35}

\textbf{Parse Tree 2} (mengasumsikan * memiliki precedence lebih tinggi):
\begin{verbatim}
        E
       /|\
      E * E
     /|   |
    E + E 5
    |   |
    3   4
\end{verbatim}
Ini akan mengevaluasi sebagai \texttt{3 + (4 * 5) = 23}

\subsection{Mengatasi Ambiguity}

Ada beberapa cara untuk mengatasi ambiguity:

\begin{enumerate}
    \item \textbf{Menulis Grammar yang Unambiguous}:
    Menggunakan grammar yang secara eksplisit mendefinisikan precedence dan associativity. Contoh:
    \begin{verbatim}
    E → E + T | E - T | T
    T → T * F | T / F | F
    F → ( E ) | number
    \end{verbatim}
    Grammar ini unambiguous karena:
    \begin{itemize}
        \item Precedence: * dan / lebih tinggi dari + dan - (karena \(T\) lebih dalam dari \(E\))
        \item Associativity: Left-associative untuk semua operator (karena left-recursive grammar)
    \end{itemize}
    
    \item \textbf{Disambiguating Rules}:
    Beberapa parser generator (seperti Yacc/Bison) memungkinkan penentuan precedence dan associativity secara eksplisit tanpa mengubah grammar.
    
    \item \textbf{Operator Precedence Parsing}:
    Menggunakan tabel precedence untuk menentukan urutan evaluasi.
\end{enumerate}

\section{Left Recursion dan Left Factoring}

\subsection{Left Recursion}

Left recursion terjadi ketika nonterminal muncul di posisi paling kiri dari produksinya sendiri. Contoh:

\begin{verbatim}
E → E + T | T
\end{verbatim}

Left recursion dapat menyebabkan masalah pada top-down parser (khususnya recursive descent) karena dapat menyebabkan infinite loop. Parser akan terus mencoba mem-parse \(E\) tanpa pernah maju.

\textbf{Eliminasi Left Recursion}:

Grammar dengan left recursion:
\begin{verbatim}
A → A a | b
\end{verbatim}

Dapat diubah menjadi:
\begin{verbatim}
A  → b A'
A' → a A' | epsilon
\end{verbatim}

Contoh: \texttt{E → E + T | T} menjadi:
\begin{verbatim}
E  → T E'
E' → + T E' | epsilon
\end{verbatim}

\subsection{Left Factoring}

Left factoring diperlukan ketika beberapa produksi dimulai dengan simbol yang sama, membuat parser tidak dapat memutuskan produksi mana yang harus digunakan tanpa lookahead lebih lanjut.

Contoh grammar yang membutuhkan left factoring:
\begin{verbatim}
S → if E then S else S
  | if E then S
\end{verbatim}

Setelah left factoring:
\begin{verbatim}
S → if E then S S'
S' → else S | epsilon
\end{verbatim}

\section{Contoh Praktis: Grammar untuk Ekspresi Aritmatika}

Mari kita buat grammar lengkap untuk ekspresi aritmatika yang dapat menangani:
\begin{itemize}
    \item Operasi: +, -, *, /, mod
    \item Precedence: * dan / lebih tinggi dari + dan -
    \item Associativity: Left-associative
    \item Parentheses untuk grouping
    \item Unary minus
    \item Integer dan floating point numbers
\end{itemize}

Grammar dalam EBNF:

\begin{verbatim}
expression = term { ("+" | "-") term }
term       = factor { ("*" | "/" | "mod") factor }
factor     = [ "-" ] ( "(" expression ")" | number )
number     = integer | float
integer    = digit { digit }
float      = integer "." integer
digit      = "0" | "1" | ... | "9"
\end{verbatim}

Atau dalam BNF:

\begin{verbatim}
<expression> ::= <term> | <expression> + <term> | <expression> - <term>
<term>       ::= <factor> | <term> * <factor> | <term> / <factor> 
               | <term> mod <factor>
<factor>     ::= - <factor> | ( <expression> ) | <number>
<number>     ::= <integer> | <float>
<integer>    ::= <digit> | <integer> <digit>
<float>      ::= <integer> . <integer>
<digit>      ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
\end{verbatim}

\section{Manual Parsing: Latihan Derivation}

Mari kita lakukan manual parsing untuk ekspresi \texttt{2 + 3 * 4} menggunakan grammar:

\begin{verbatim}
E → E + T | E - T | T
T → T * F | T / F | F
F → ( E ) | number
\end{verbatim}

\textbf{Leftmost Derivation}:

\begin{enumerate}
    \item \(E \Rightarrow E + T\)
    \item \(E + T \Rightarrow T + T\)
    \item \(T + T \Rightarrow F + T\)
    \item \(F + T \Rightarrow \texttt{2} + T\)
    \item \(\texttt{2} + T \Rightarrow \texttt{2} + T * F\)
    \item \(\texttt{2} + T * F \Rightarrow \texttt{2} + F * F\)
    \item \(\texttt{2} + F * F \Rightarrow \texttt{2} + \texttt{3} * F\)
    \item \(\texttt{2} + \texttt{3} * F \Rightarrow \texttt{2} + \texttt{3} * \texttt{4}\)
\end{enumerate}

\textbf{Parse Tree}:

\begin{verbatim}
        E
       /|\
      / | \
     E  +  T
     |     /|\
     T   / | \
     |  T  *  F
     F  |     |
     |  F     4
     2  |
        3
\end{verbatim}

\section{Kesimpulan}

Dalam bab ini, kita telah mempelajari:

\begin{enumerate}
    \item Context-free grammar adalah alat formal untuk mendefinisikan syntax bahasa pemrograman
    \item BNF dan EBNF adalah notasi untuk menulis grammar
    \item Derivation menunjukkan bagaimana string dihasilkan dari grammar
    \item Parse tree merepresentasikan struktur sintaksis program
    \item Ambiguity dalam grammar dapat menyebabkan interpretasi yang berbeda
    \item Left recursion dan left factoring adalah isu penting dalam parsing
\end{enumerate}

Pemahaman tentang CFG dan konsep-konsep terkait ini menjadi dasar penting untuk mempelajari teknik parsing (top-down dan bottom-up) yang akan dibahas dalam bab-bab selanjutnya.

\section{Latihan}

\begin{enumerate}
    \item Tuliskan grammar dalam BNF untuk:
    \begin{itemize}
        \item Ekspresi boolean dengan operator AND, OR, NOT
        \item Assignment statement: \texttt{variable = expression;}
        \item For loop: \texttt{for (init; condition; update) statement}
    \end{itemize}
    
    \item Konversi grammar berikut ke EBNF:
    \begin{verbatim}
    <list> ::= <item> | <list> , <item>
    <item> ::= <number> | <string>
    \end{verbatim}
    
    \item Buatlah leftmost dan rightmost derivation untuk ekspresi \texttt{(2 + 3) * 4} menggunakan grammar ekspresi aritmatika yang telah dipelajari.
    
    \item Gambarkan parse tree untuk ekspresi berikut menggunakan grammar yang sesuai:
    \begin{itemize}
        \item \texttt{1 + 2 * 3}
        \item \texttt{10 / 2 - 3}
        \item \texttt{(5 + 3) * 2}
    \end{itemize}
    
    \item Identifikasi apakah grammar berikut ambiguous. Jika ya, berikan contoh string yang dapat di-parse dengan lebih dari satu cara:
    \begin{verbatim}
    S → a S a | b S b | a | b | epsilon
    \end{verbatim}
    
    \item Eliminasi left recursion dari grammar berikut:
    \begin{verbatim}
    A → A + B | A - B | B
    B → B * C | B / C | C
    C → ( A ) | number
    \end{verbatim}
    
    \item Lakukan left factoring pada grammar berikut:
    \begin{verbatim}
    S → if E then S else S
      | if E then S
      | while E do S
      | id = E
    \end{verbatim}
    
    \item Rancang grammar untuk bahasa sederhana yang mendukung:
    \begin{itemize}
        \item Variable declarations: \texttt{int x;}
        \item Assignments: \texttt{x = 5;}
        \item If-else statements
        \item While loops
        \item Arithmetic expressions
    \end{itemize}
    Tulis grammar dalam EBNF dan berikan contoh program valid.
\end{enumerate}

\section{Referensi dan Bahan Bacaan Lanjutan}

Untuk memperdalam pemahaman tentang context-free grammar dan parsing, mahasiswa disarankan membaca:

\begin{itemize}
    \item \textbf{Dragon Book}: Aho, Lam, Sethi, \& Ullman (2006). \textit{Compilers: Principles, Techniques, and Tools} \cite{aho2006compilers} - Bab 4: Syntax Analysis
    
    \item \textbf{Engineering a Compiler}: Cooper \& Torczon (2011) \cite{cooper2011engineering} - Bab 3: Scanners dan Bab 4: Parsers
    
    \item \textbf{UC San Diego CSE 231}: Course materials tentang syntax analysis \cite{ucsd2024compiler}
    
    \item \textbf{Northeastern University CS 4410}: Materials tentang parsing techniques \cite{neu2024compiler}
    
    \item \textbf{Johns Hopkins University EN.601.428}: Course tentang syntax trees dan parsing \cite{jhu2024compilers}
\end{itemize}
