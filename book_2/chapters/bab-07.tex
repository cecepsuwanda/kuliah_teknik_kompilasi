% Bab 7: Bottom-Up Parsing, LR Parser, dan Parser Generator
% File ini dapat dikompilasi terpisah atau sebagai bagian dari main.tex

\chapter{Bottom-Up Parsing, LR Parser, dan Parser Generator}
\label{chap:bottom-up-parsing}

\section{Tujuan Pembelajaran}

Setelah mempelajari bab ini, mahasiswa diharapkan mampu:
\begin{enumerate}
    \item Menjelaskan konsep bottom-up parsing dan perbedaannya dengan top-down parsing
    \item Memahami shift-reduce parsing dan operasi-operasinya
    \item Menjelaskan berbagai jenis LR parser (LR(0), SLR(1), CLR(1), LALR(1))
    \item Memahami konstruksi LR parsing table untuk grammar sederhana
    \item Menggunakan parser generator (Bison/Yacc) untuk membuat parser
    \item Mengintegrasikan Flex lexer dengan Bison parser
    \item Menambahkan semantic actions untuk membangun AST
    \item Mengimplementasikan error handling dalam parser generator
\end{enumerate}

\section{Pendahuluan}

Setelah mempelajari top-down parsing pada bab sebelumnya, kita sekarang akan mempelajari pendekatan alternatif yang lebih powerful: bottom-up parsing. Menurut sumber terbuka:

\begin{quote}
``Bottom-up parsers (LR, LALR, GLR) – more powerful; often generated by tools like Bison/Yacc. The choice affects ease of specification and parsing power.''\cite{diznr2024phases}
\end{quote}

Bottom-up parsing membangun parse tree dari leaves (token) ke root (start symbol), yang merupakan kebalikan dari top-down parsing. Pendekatan ini lebih powerful karena dapat menangani lebih banyak jenis grammar, termasuk grammar dengan left recursion yang tidak dapat ditangani langsung oleh top-down parser.

\section{Konsep Bottom-Up Parsing}

\subsection{Definisi Bottom-Up Parsing}

Bottom-up parsing adalah teknik parsing yang dimulai dari input tokens dan mencoba membangun parse tree dari bawah ke atas, dengan tujuan mencapai start symbol. Parser menggunakan rightmost derivation dalam reverse, yaitu membangun derivation dari kanan ke kiri.

Karakteristik utama bottom-up parsing:
\begin{itemize}
    \item Membangun parse tree dari leaves (terminals) ke root (start symbol)
    \item Menggunakan rightmost derivation dalam reverse
    \item Menggunakan stack untuk menyimpan state parsing
    \item Lebih powerful daripada top-down parsing (dapat menangani lebih banyak grammar)
    \item Umumnya diimplementasikan menggunakan parsing table yang di-generate
\end{itemize}

\subsection{Handle dan Reduction}

Konsep penting dalam bottom-up parsing adalah \textbf{handle}. Handle adalah substring dari sentential form saat ini yang cocok dengan right-hand side (RHS) dari suatu production rule, dan reduction terhadap handle ini akan membawa kita lebih dekat ke start symbol.

Menurut definisi formal:

\begin{quote}
``A handle is a substring of the current sentential form that matches the RHS of a production and whose reduction must lead toward the start symbol.''\footnote{\url{https://ebooks.inflibnet.ac.in/csp10/chapter/top-down-parser-parsing-tableshift-reduce-parser/}}
\end{quote}

Contoh: Jika kita memiliki grammar:
\begin{verbatim}
E -> E + T | T
T -> T * F | F
F -> ( E ) | id
\end{verbatim}

Dan sentential form saat ini adalah \texttt{id + id * id}, maka handle yang tepat adalah \texttt{id} (yang dapat di-reduce menjadi F, kemudian T, kemudian E).

\section{Shift-Reduce Parsing}

\subsection{Konsep Shift-Reduce}

Shift-reduce parsing adalah implementasi dasar dari bottom-up parsing yang menggunakan stack dan empat operasi dasar. Menurut GeeksforGeeks:

\begin{quote}
``Shift-Reduce Parser uses a stack and four basic operations:
1. Shift: push the next input symbol onto the stack.
2. Reduce: when the top of stack matches RHS of some grammar rule, pop it and push the LHS nonterminal.
3. Accept: if the stack has start symbol and input is exhausted.
4. Error: no valid shift/reduce possible.''\footnote{\url{https://www.geeksforgeeks.org/compiler-design/shift-reduce-parser-compiler/}}
\end{quote}

\subsection{Operasi Shift}

Operasi \textbf{shift} memindahkan token berikutnya dari input ke stack. Ini dilakukan ketika parser belum menemukan handle yang lengkap di stack.

Contoh: Jika stack berisi \texttt{[E, +]} dan input berikutnya adalah \texttt{id}, maka operasi shift akan menghasilkan stack \texttt{[E, +, id]}.

\subsection{Operasi Reduce}

Operasi \textbf{reduce} mengganti handle di top of stack dengan left-hand side (LHS) dari production rule yang sesuai. Handle harus cocok persis dengan RHS dari suatu production.

Contoh: Jika stack berisi \texttt{[E, +, T, *, F]} dan kita memiliki production \texttt{F -> id}, dan top of stack adalah \texttt{id} yang cocok dengan RHS, maka reduce akan menghasilkan stack \texttt{[E, +, T, *, F]}.

\subsection{Operasi Accept}

Operasi \textbf{accept} terjadi ketika:
\begin{itemize}
    \item Stack hanya berisi start symbol (atau augmented start symbol)
    \item Input sudah habis (hanya end marker \$ tersisa)
\end{itemize}

Ini menandakan bahwa parsing berhasil dan input valid.

\subsection{Operasi Error}

Operasi \textbf{error} terjadi ketika tidak ada operasi shift atau reduce yang valid. Ini berarti input tidak valid menurut grammar.

\subsection{Contoh Shift-Reduce Parsing}

Mari kita lihat contoh parsing ekspresi \texttt{id + id} dengan grammar sederhana:

\begin{verbatim}
E -> E + T | T
T -> id
\end{verbatim}

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Stack} & \textbf{Input} & \textbf{Action} & \textbf{Production} \\
\hline
\$ & id + id \$ & Shift & \\
\hline
\$ id & + id \$ & Reduce & T -> id \\
\hline
\$ T & + id \$ & Reduce & E -> T \\
\hline
\$ E & + id \$ & Shift & \\
\hline
\$ E + & id \$ & Shift & \\
\hline
\$ E + id & \$ & Reduce & T -> id \\
\hline
\$ E + T & \$ & Reduce & E -> E + T \\
\hline
\$ E & \$ & Accept & \\
\hline
\end{tabular}
\caption{Contoh shift-reduce parsing untuk \texttt{id + id}}
\label{tab:shift-reduce-example}
\end{table}

\section{LR Parsers}

\subsection{Definisi LR Parser}

LR parser adalah kelas bottom-up parser yang membaca input dari \textbf{L}eft ke right dan menghasilkan \textbf{R}ightmost derivation dalam reverse. Notasi LR(k) menunjukkan bahwa parser menggunakan k token lookahead.

Menurut GeeksforGeeks:

\begin{quote}
``LR parsers read input Left-to-right and produce a Rightmost derivation in reverse. They use a parsing table to decide when to shift and when to reduce.''\footnote{\url{https://www.geeksforgeeks.org/bottom-up-or-shift-reduce-parsers-set-2/}}
\end{quote}

LR parser menggunakan dua tabel utama:
\begin{itemize}
    \item \textbf{Action Table}: Menentukan aksi (shift, reduce, accept, error) berdasarkan state saat ini dan lookahead token
    \item \textbf{GOTO Table}: Menentukan state berikutnya setelah reduce berdasarkan state saat ini dan non-terminal yang dihasilkan
\end{itemize}

\subsection{Jenis-jenis LR Parser}

Terdapat beberapa varian LR parser, masing-masing dengan karakteristik berbeda:

\subsubsection{LR(0)}

LR(0) adalah varian paling sederhana yang tidak menggunakan lookahead. Karakteristik:
\begin{itemize}
    \item Tidak memerlukan lookahead token
    \item Tabel parsing kecil
    \item Sangat terbatas dalam kemampuan parsing (banyak grammar menghasilkan conflict)
    \item Jarang digunakan dalam praktik
\end{itemize}

\subsubsection{SLR(1) - Simple LR}

SLR(1) menggunakan 1 token lookahead dan Follow sets untuk menentukan kapan melakukan reduce. Karakteristik:
\begin{itemize}
    \item Menggunakan LR(0) item sets
    \item Reduce hanya dilakukan jika lookahead token berada dalam Follow set dari non-terminal yang di-reduce
    \item Lebih powerful daripada LR(0)
    \item Tabel lebih kecil daripada CLR(1)
    \item Masih dapat menghasilkan conflict untuk beberapa grammar
\end{itemize}

Menurut GeeksforGeeks:

\begin{quote}
``SLR(1) uses LR(0) item sets, and reduction is allowed on lookahead symbols in Follow(A) for production A -> $\alpha$ when the item [A -> $\alpha$ •] appears in the state. This can lead to conflicts CLR(1) avoids.''\footnote{\url{https://www.geeksforgeeks.org/bottom-up-or-shift-reduce-parsers-set-2/}}
\end{quote}

\subsubsection{CLR(1) - Canonical LR}

CLR(1) adalah varian paling powerful yang menggunakan full LR(1) items dengan lookahead spesifik. Karakteristik:
\begin{itemize}
    \item Menggunakan LR(1) items (production dengan lookahead spesifik)
    \item Reduce hanya dilakukan pada lookahead token yang spesifik
    \item Dapat menangani lebih banyak grammar daripada SLR(1)
    \item Tabel parsing sangat besar (banyak states)
    \item Lebih lambat dalam konstruksi tabel
\end{itemize}

\subsubsection{LALR(1) - Look-Ahead LR}

LALR(1) adalah kompromi praktis antara SLR(1) dan CLR(1). Karakteristik:
\begin{itemize}
    \item Merge states dari CLR(1) yang memiliki LR(0) core yang sama
    \item Menggabungkan lookahead sets dari states yang di-merge
    \item Jumlah states sama atau mendekati SLR(1)
    \item Lebih powerful daripada SLR(1), hampir sekuat CLR(1)
    \item Digunakan oleh Yacc dan Bison (parser generator populer)
\end{itemize}

Menurut GeeksforGeeks:

\begin{quote}
``LALR(1) merges states in the CLR(1) automaton that have identical LR(0) cores (i.e. same productions \& dot positions), combining their lookahead sets. Then construct table using merged states. This reduces size while often preserving correctness.''\footnote{\url{https://www.geeksforgeeks.org/compiler-design/lalr-parser-with-examples/}}
\end{quote}

\subsection{Perbandingan LR Parser Variants}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Variant} & \textbf{Lookahead} & \textbf{Table Size} & \textbf{Parsing Power} \\
\hline
LR(0) & None & Smallest & Weakest \\
\hline
SLR(1) & 1 token (Follow sets) & Small & Moderate \\
\hline
LALR(1) & 1 token (merged) & Small-Medium & Strong \\
\hline
CLR(1) & 1 token (full) & Largest & Strongest \\
\hline
\end{tabular}
\caption{Perbandingan varian LR parser}
\label{tab:lr-variants}
\end{table}

\section{Konstruksi LR Parsing Table}

\subsection{Augmented Grammar}

Langkah pertama dalam konstruksi LR parsing table adalah membuat \textbf{augmented grammar}. Kita menambahkan production baru:
\begin{verbatim}
S' -> S
\end{verbatim}
di mana S adalah start symbol asli. Ini memungkinkan state accept yang unambiguous.

\subsection{LR Items}

LR item adalah production dengan dot (•) yang menandai posisi parsing saat ini. Format: \texttt{A -> $\alpha$ • $\beta$}

Contoh:
\begin{itemize}
    \item \texttt{E -> • E + T}: Belum membaca apapun dari production ini
    \item \texttt{E -> E • + T}: Sudah membaca E, menunggu +
    \item \texttt{E -> E + • T}: Sudah membaca E dan +, menunggu T
    \item \texttt{E -> E + T •}: Sudah membaca seluruh RHS, siap untuk reduce
\end{itemize}

\subsubsection{LR(0) Items}

LR(0) item hanya berisi production dengan dot, tanpa informasi lookahead.

\subsubsection{LR(1) Items}

LR(1) item adalah LR(0) item yang ditambahkan dengan lookahead token. Format: \texttt{[A -> $\alpha$ • $\beta$, a]} di mana \texttt{a} adalah lookahead token.

\subsection{Closure Operation}

Closure operation menambahkan semua production yang relevan ke set items. Jika kita memiliki item \texttt{[A -> $\alpha$ • B $\beta$]} dalam set, kita menambahkan semua items \texttt{[B -> • $\gamma$]} untuk setiap production \texttt{B -> $\gamma$}.

Algoritma closure:
\begin{enumerate}
    \item Mulai dengan set items awal
    \item Untuk setiap item \texttt{[A -> $\alpha$ • B $\beta$]}:
    \begin{itemize}
        \item Tambahkan semua items \texttt{[B -> • $\gamma$]} untuk setiap production \texttt{B -> $\gamma$}
        \item Jika LR(1), hitung lookahead untuk items baru
    \end{itemize}
    \item Ulangi sampai tidak ada item baru yang ditambahkan
\end{enumerate}

\subsection{GOTO Operation}

GOTO operation memindahkan dot melewati simbol grammar X. Jika kita memiliki item \texttt{[A -> $\alpha$ • X $\beta$]} dan membaca X, kita mendapatkan item \texttt{[A -> $\alpha$ X • $\beta$]}.

Algoritma GOTO:
\begin{enumerate}
    \item Mulai dengan set items I dan simbol grammar X
    \item Untuk setiap item \texttt{[A -> $\alpha$ • X $\beta$]} dalam I:
    \begin{itemize}
        \item Tambahkan \texttt{[A -> $\alpha$ X • $\beta$]} ke set baru
    \end{itemize}
    \item Ambil closure dari set baru
\end{enumerate}

\subsection{Canonical Collection of Item Sets}

Canonical collection adalah kumpulan semua state yang mungkin dalam LR automaton. Konstruksinya:

\begin{enumerate}
    \item Mulai dengan \texttt{I\_0 = closure(\{S' -> • S, \$\})}
    \item Untuk setiap state I dan setiap simbol grammar X:
    \begin{itemize}
        \item Hitung \texttt{GOTO(I, X)}
        \item Jika hasilnya non-empty dan belum ada, tambahkan sebagai state baru
    \end{itemize}
    \item Ulangi sampai tidak ada state baru
\end{enumerate}

\subsection{Konstruksi Action dan GOTO Tables}

Setelah canonical collection dibuat, kita konstruksi dua tabel:

\subsubsection{Action Table}

Action table menentukan aksi berdasarkan state dan lookahead token:
\begin{itemize}
    \item \textbf{Shift}: Jika \texttt{GOTO(I, a) = J} untuk terminal \texttt{a}, maka \texttt{action[I, a] = shift J}
    \item \textbf{Reduce}: Jika item \texttt{[A -> $\alpha$ •, a]} ada di state I, maka \texttt{action[I, a] = reduce A -> $\alpha$}
    \item \textbf{Accept}: Jika item \texttt{[S' -> S •, \$]} ada di state I, maka \texttt{action[I, \$] = accept}
    \item \textbf{Error}: Jika tidak ada aksi yang valid
\end{itemize}

\subsubsection{GOTO Table}

GOTO table menentukan state berikutnya setelah reduce:
\begin{itemize}
    \item Jika \texttt{GOTO(I, A) = J} untuk non-terminal \texttt{A}, maka \texttt{goto[I, A] = J}
\end{itemize}

\subsection{Contoh Konstruksi Parsing Table (Simplified)}

Mari kita lihat contoh sederhana untuk grammar:
\begin{verbatim}
S -> A A
A -> a A | b
\end{verbatim}

Augmented grammar:
\begin{verbatim}
S' -> S
S -> A A
A -> a A | b
\end{verbatim}

Langkah-langkah konstruksi (disederhanakan):
\begin{enumerate}
    \item Buat I\_0 dengan closure dari \texttt{S' -> • S}
    \item Hitung GOTO untuk setiap simbol
    \item Lanjutkan sampai semua state ditemukan
    \item Konstruksi action dan goto tables
\end{enumerate}

\section{GLR Parsing (Generalized LR)}

\subsection{Konsep GLR}

GLR (Generalized LR) adalah ekstensi dari LR parsing yang dapat menangani ambiguous grammar atau grammar yang akan menghasilkan conflict dalam tabel LR biasa.

Menurut Wikipedia:

\begin{quote}
``GLR extends LR parsing to handle ambiguous grammars or grammars that would cause conflicts in LR tables. It allows multiple possible parse actions in a state and pursues them in parallel.''\footnote{\url{https://en.wikipedia.org/wiki/GLR_parser}}
\end{quote}

GLR parser menjaga multiple stacks atau parse trees aktif secara bersamaan ketika terjadi conflict, dan merge stack prefixes yang mungkin untuk berbagi pekerjaan.

\subsection{Kapan Menggunakan GLR}

GLR parsing berguna untuk:
\begin{itemize}
    \item Grammar yang ambiguous (memiliki multiple parse trees valid)
    \item Grammar yang tidak LR(1) tetapi masih ingin di-parse secara deterministik
    \item Bahasa dengan syntax yang extensible
    \item Natural language processing
\end{itemize}

\section{Parser Generator: Bison dan Yacc}

\subsection{Pengenalan Parser Generator}

Parser generator adalah tool yang secara otomatis menghasilkan parser dari specification grammar. Menurut sumber dari IT Trip:

\begin{quote}
``Bison / YACC: define grammar in a .y file, specify \%token s, grammar rules, actions, etc. Generates C parser (or C++ variants). Flex + Bison: use Flex to build the lexer (.l file), Bison for parser, integrate them via tokens.''\cite{ittrip2024bison}
\end{quote}

Keuntungan menggunakan parser generator:
\begin{itemize}
    \item Menghemat waktu development
    \item Mengurangi kemungkinan error
    \item Mudah di-maintain (ubah grammar, regenerate parser)
    \item Menghasilkan parser yang efisien
    \item Mendukung semantic actions untuk membangun AST
\end{itemize}

\subsection{Yacc (Yet Another Compiler Compiler)}

Yacc adalah parser generator yang dikembangkan di Bell Labs pada tahun 1970-an. Yacc menghasilkan LALR(1) parser dari grammar specification.

\subsection{Bison (GNU Yacc)}

Bison adalah implementasi open source dari Yacc yang dikembangkan oleh GNU Project. Bison lebih powerful dan memiliki fitur tambahan:
\begin{itemize}
    \item Mendukung LALR(1), LR(1), dan GLR parsing
    \item Mendukung C++ output
    \item Error recovery yang lebih baik
    \item Dokumentasi yang lebih lengkap
\end{itemize}

\subsection{Struktur File Bison (.y)}

File Bison memiliki struktur berikut:

\begin{verbatim}
%{
/* C/C++ code: includes, declarations */
%}

/* Bison declarations: tokens, types, precedence */
%token NUMBER IDENTIFIER
%left '+' '-'
%left '*' '/'

%%
/* Grammar rules */
expression:
    expression '+' term { /* semantic action */ }
    | term
    ;

term:
    term '*' factor { /* semantic action */ }
    | factor
    ;

factor:
    NUMBER { /* semantic action */ }
    | IDENTIFIER { /* semantic action */ }
    | '(' expression ')' { /* semantic action */ }
    ;

%%
/* User code: helper functions */
\end{verbatim}

\subsection{Integrasi Flex dan Bison}

Flex dan Bison dirancang untuk bekerja bersama:

\begin{enumerate}
    \item \textbf{Flex file (.l)}: Mendefinisikan token patterns
    \begin{verbatim}
    %{
    #include "parser.tab.h"  // Generated by Bison
    %}
    %%
    [0-9]+     { yylval = atoi(yytext); return NUMBER; }
    [a-zA-Z]+  { return IDENTIFIER; }
    \+         { return '+'; }
    \*         { return '*'; }
    %%
    \end{verbatim}

    \item \textbf{Bison file (.y)}: Mendefinisikan grammar dan semantic actions
    \begin{verbatim}
    %token NUMBER IDENTIFIER
    %%
    expression: expression '+' term | term;
    term: term '*' factor | factor;
    factor: NUMBER | IDENTIFIER | '(' expression ')';
    %%
    \end{verbatim}

    \item \textbf{Compilation}: 
    \begin{verbatim}
    flex lexer.l
    bison -d parser.y
    gcc lex.yy.c parser.tab.c -o parser
    \end{verbatim}
\end{enumerate}

\subsection{Semantic Actions}

Semantic actions adalah kode C/C++ yang dieksekusi ketika production rule di-reduce. Actions dapat:
\begin{itemize}
    \item Membangun AST nodes
    \item Mengevaluasi ekspresi
    \item Memvalidasi semantik
    \item Menghasilkan output
\end{itemize}

Contoh semantic action untuk membangun AST:

\begin{verbatim}
expression:
    expression '+' term 
    { 
        $$ = create_binary_op(PLUS, $1, $3); 
    }
    | term 
    { 
        $$ = $1; 
    }
    ;
\end{verbatim}

Di mana:
\begin{itemize}
    \item \texttt{\$\$}: Nilai yang dihasilkan oleh production (LHS)
    \item \texttt{\$1, \$2, ...}: Nilai dari simbol-simbol di RHS
\end{itemize}

\subsection{Error Handling dalam Bison}

Bison menyediakan mekanisme error handling:

\begin{verbatim}
%error-verbose  // Better error messages

expression:
    expression '+' term
    | error '+' term  // Error recovery: skip until '+'
    | term
    ;
\end{verbatim}

Error recovery rules memungkinkan parser untuk:
\begin{itemize}
    \item Mendeteksi error
    \item Melakukan recovery (skip tokens sampai synchronization point)
    \item Melanjutkan parsing
    \item Menghasilkan multiple error messages
\end{itemize}

\section{Perbandingan Top-Down vs Bottom-Up Parsing}

\subsection{Perbandingan Karakteristik}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Aspek} & \textbf{Top-Down} & \textbf{Bottom-Up} \\
\hline
Parse Tree Direction & Root -> Leaves & Leaves -> Root \\
\hline
Derivation & Leftmost & Rightmost (reverse) \\
\hline
Implementation & Recursive descent & Table-driven \\
\hline
Lookahead & Usually 1 token & Usually 1 token \\
\hline
Left Recursion & Problem & No problem \\
\hline
Right Recursion & No problem & Less efficient \\
\hline
Parsing Power & LL(1) grammars & LR(1) grammars \\
\hline
Error Detection & Early & Later \\
\hline
Error Messages & More intuitive & Less intuitive \\
\hline
Table Size & Small & Larger \\
\hline
\end{tabular}
\caption{Perbandingan top-down dan bottom-up parsing}
\label{tab:top-down-vs-bottom-up}
\end{table}

\subsection{Kapan Menggunakan Masing-masing}

\textbf{Gunakan Top-Down Parsing jika:}
\begin{itemize}
    \item Grammar sudah dalam bentuk yang sesuai (tidak ada left recursion)
    \item Error messages yang intuitif penting
    \item Implementasi manual diperlukan
    \item Grammar relatif sederhana
\end{itemize}

\textbf{Gunakan Bottom-Up Parsing jika:}
\begin{itemize}
    \item Grammar memiliki left recursion
    \item Parsing power yang lebih besar diperlukan
    \item Menggunakan parser generator (Bison/Yacc)
    \item Grammar kompleks dengan banyak precedence levels
\end{itemize}

\section{Kesimpulan}

Dalam bab ini, kita telah mempelajari:

\begin{enumerate}
    \item Bottom-up parsing membangun parse tree dari leaves ke root menggunakan rightmost derivation dalam reverse
    \item Shift-reduce parsing menggunakan empat operasi: shift, reduce, accept, dan error
    \item LR parser adalah kelas bottom-up parser yang powerful dengan berbagai varian (LR(0), SLR(1), CLR(1), LALR(1))
    \item Konstruksi LR parsing table melibatkan augmented grammar, LR items, closure, GOTO, dan canonical collection
    \item Parser generator seperti Bison/Yacc secara otomatis menghasilkan parser dari grammar specification
    \item Integrasi Flex dan Bison memungkinkan pembangunan lexer dan parser yang terintegrasi
    \item Semantic actions memungkinkan pembangunan AST selama parsing
    \item Bottom-up parsing lebih powerful tetapi top-down parsing lebih mudah diimplementasikan secara manual
\end{enumerate}

Pemahaman tentang bottom-up parsing dan parser generator ini penting untuk mengimplementasikan parser yang robust dan efisien untuk bahasa pemrograman yang kompleks.

\section{Latihan}

\begin{enumerate}
    \item Jelaskan perbedaan antara top-down dan bottom-up parsing. Berikan contoh situasi di mana masing-masing lebih cocok digunakan.
    
    \item Untuk grammar berikut:
    \begin{verbatim}
    E -> E + T | T
    T -> T * F | F
    F -> ( E ) | id
    \end{verbatim}
    Lakukan shift-reduce parsing manual untuk input \texttt{id + id * id}. Tunjukkan stack, input, dan action pada setiap langkah.
    
    \item Jelaskan perbedaan antara SLR(1), CLR(1), dan LALR(1). Mengapa LALR(1) menjadi pilihan populer untuk parser generator?
    
    \item Buatlah file Bison sederhana untuk grammar ekspresi aritmatika dengan:
    \begin{itemize}
        \item Operator +, -, *, / dengan precedence yang benar
        \item Parentheses untuk grouping
        \item Semantic actions yang mencetak ekspresi yang di-parse
    \end{itemize}
    
    \item Integrasikan Flex lexer dengan Bison parser untuk membuat calculator sederhana yang dapat mengevaluasi ekspresi aritmatika.
    
    \item Implementasikan error recovery dalam Bison untuk menangani syntax error dengan baik. Test dengan input yang mengandung error.
    
    \item Bandingkan performa dan kompleksitas implementasi antara recursive descent parser (top-down) dan parser yang di-generate oleh Bison (bottom-up) untuk grammar yang sama.
\end{enumerate}

\section{Referensi dan Bahan Bacaan Lanjutan}

Untuk memperdalam pemahaman tentang bottom-up parsing dan parser generator, mahasiswa disarankan membaca:

\begin{itemize}
    \item \textbf{Dragon Book}: Aho, Lam, Sethi, \& Ullman (2006). \textit{Compilers: Principles, Techniques, and Tools} \cite{aho2006compilers} - Bab 4: Syntax-Directed Translation, Bab 5: Bottom-Up Parsers
    
    \item \textbf{Engineering a Compiler}: Cooper \& Torczon (2011) \cite{cooper2011engineering} - Bab 3: Scanners and Parsers
    
    \item \textbf{flex \& bison}: Levine (2009) \cite{levine2009flex} - Buku lengkap tentang Flex dan Bison
    
    \item \textbf{GeeksforGeeks}: Tutorial tentang shift-reduce parsing dan LR parsers\footnote{\url{https://www.geeksforgeeks.org/compiler-design/shift-reduce-parser-compiler/}}
    
    \item \textbf{IT Trip}: Tutorial tentang integrasi Flex dan Bison \cite{ittrip2024bison}
    
    \item \textbf{UC San Diego CSE 231}: Course materials tentang parser construction \cite{ucsd2024compiler}
    
    \item \textbf{Northeastern University CS 4410}: Comprehensive compiler design course \cite{neu2024compiler}
\end{itemize}
