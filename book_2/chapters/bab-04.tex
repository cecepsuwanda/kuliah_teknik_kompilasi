% Bab 4: Lexer Generator (Flex/re2c) dan Praktikum Lexer
% File ini dapat dikompilasi terpisah atau sebagai bagian dari main.tex

\chapter{Lexer Generator (Flex/re2c) dan Praktikum Lexer}
\label{chap:lexer-generator}

\section{Tujuan Pembelajaran}

Setelah mempelajari bab ini, mahasiswa diharapkan mampu:
\begin{enumerate}
    \item Memahami konsep dan keuntungan menggunakan lexer generator
    \item Menggunakan Flex untuk membuat specification file (.l) dan generate lexer code
    \item Menggunakan re2c untuk membuat lexer dengan embedded specification
    \item Membuat specification file untuk lexer bahasa sederhana
    \item Mengintegrasikan generated lexer dengan program utama
    \item Membandingkan hand-written lexer dengan generator-based lexer
    \item Mengevaluasi trade-off antara performa, kemudahan maintenance, dan fleksibilitas
\end{enumerate}

\section{Pendahuluan}

Pada bab sebelumnya, kita telah mempelajari implementasi hand-written lexer. Meskipun pendekatan tersebut memberikan kontrol penuh dan pemahaman mendalam, dalam praktik industri, penggunaan \textbf{lexer generator} lebih umum karena efisiensi dan kemudahan maintenance. Menurut sumber terbuka:

\begin{quote}
``re2c is a high-performance lexer generator for C/C++ that takes regex specifications and builds deterministic finite automata. It's used in real projects.''\cite{wikipedia2024re2c}
\end{quote}

Lexer generator adalah tools yang menerima specification file (berisi pattern dan action) dan menghasilkan kode lexer yang siap digunakan. Dua generator populer untuk C/C++ adalah \textbf{Flex} (Fast Lexical Analyzer) dan \textbf{re2c} (Regular Expressions to Code).

Gambar \ref{fig:lexer-generator-overview} menunjukkan alur kerja lexer generator secara umum.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.9\textwidth,center}{%
    \begin{tikzpicture}[
        box/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.5cm, text centered, minimum height=0.7cm, rounded corners, font=\footnotesize, inner sep=4pt, align=center},
        arrow/.style={->, >=stealth, thick},
        node distance=1.5cm
    ]
    
    \node[box] (spec) {Specification\\File};
    \node[box, right=of spec] (gen) {Lexer\\Generator};
    \node[box, right=of gen] (code) {Generated\\Lexer Code};
    \node[box, below=of code] (compile) {Compile};
    \node[box, left=of compile] (lexer) {Executable\\Lexer};
    
    \draw[arrow] (spec) -- node[above, font=\tiny] {Input} (gen);
    \draw[arrow] (gen) -- node[above, font=\tiny] {Generate} (code);
    \draw[arrow] (code) -- (compile);
    \draw[arrow] (compile) -- (lexer);
    
    \end{tikzpicture}%
    }
    \caption{Alur kerja lexer generator}
    \label{fig:lexer-generator-overview}
\end{figure}

Keuntungan menggunakan lexer generator:
\begin{itemize}
    \item \textbf{Produktivitas}: Lebih cepat dalam development karena tidak perlu menulis state machine manual
    \item \textbf{Maintainability}: Specification file lebih mudah dibaca dan dimodifikasi dibanding kode state machine
    \item \textbf{Optimasi Otomatis}: Generator menghasilkan kode yang sudah dioptimasi (DFA minimization, dll.)
    \item \textbf{Konsistensi}: Mengurangi bug karena generator sudah teruji
\end{itemize}

\section{Flex (Fast Lexical Analyzer)}

Flex adalah lexer generator yang paling banyak digunakan, terutama dalam kombinasi dengan Bison (parser generator). Flex membaca specification file dengan ekstensi \texttt{.l} dan menghasilkan kode C untuk lexer.

\subsection{Struktur Flex Specification File}

File specification Flex (`.l`) terdiri dari tiga bagian yang dipisahkan oleh `\%\%`:

\begin{verbatim}
Definitions
%%
Rules
%%
User Code
\end{verbatim}

Gambar \ref{fig:flex-structure} menunjukkan struktur file specification Flex secara visual.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.85\textwidth,center}{%
    \begin{tikzpicture}[
        section/.style={rectangle, draw=blue!50, fill=blue!10, text width=6cm, minimum height=1cm, font=\footnotesize, align=left, inner sep=8pt, rounded corners},
        separator/.style={rectangle, draw=red!50, fill=red!10, text width=6cm, minimum height=0.3cm, font=\small\bfseries, align=center},
        arrow/.style={->, >=stealth, thick},
        node distance=0.4cm
    ]
    
    \node[section] (def) {Definitions Section\\\texttt{\%\{ \%\}} C code\\Named patterns (macros)\\Options};
    \node[separator, below=of def] (sep1) {\%\%};
    \node[section, below=of sep1] (rules) {Rules Section\\Pattern-action pairs\\Regular expressions\\C actions};
    \node[separator, below=of rules] (sep2) {\%\%};
    \node[section, below=of sep2] (user) {User Code Section\\\texttt{main()}, \texttt{yywrap()}\\Helper functions};
    
    \draw[arrow] (def) -- (sep1);
    \draw[arrow] (sep1) -- (rules);
    \draw[arrow] (rules) -- (sep2);
    \draw[arrow] (sep2) -- (user);
    
    \end{tikzpicture}%
    }
    \caption{Struktur file specification Flex}
    \label{fig:flex-structure}
\end{figure}

\subsubsection{Definitions Section}

Bagian ini berisi:
\begin{itemize}
    \item \textbf{Named patterns (macros)}: Definisi pattern yang dapat digunakan kembali
    \item \textbf{C code}: Kode C yang akan disalin langsung ke output (dalam `\%\{ \%\}`)
    \item \textbf{Options}: Konfigurasi Flex (misalnya `\%option noyywrap`)
\end{itemize}

Contoh:
\begin{verbatim}
%{
#include <stdio.h>
#include "tokens.h"  // Definisi token constants
%}

DIGIT    [0-9]
LETTER   [a-zA-Z]
ID       {LETTER}({LETTER}|{DIGIT})*
NUMBER   {DIGIT}+
\end{verbatim}

\subsubsection{Rules Section}

Bagian ini berisi pattern-action pairs. Pattern menggunakan regular expression, dan action adalah kode C yang dieksekusi ketika pattern match.

Contoh:
\begin{lstlisting}[language={},basicstyle=\ttfamily\footnotesize,breaklines=true,breakatwhitespace=false]
%%
"if"          { return IF; }
"else"        { return ELSE; }
"while"       { return WHILE; }
{ID}          { return IDENTIFIER; }
{NUMBER}      { yylval.intval = atoi(yytext); return NUMBER; }
"=="          { return EQ; }
"!="          { return NE; }
[ \t\n]+      { /* skip whitespace */ }
"//".*        { /* skip single-line comment */ }
"/*"          { BEGIN(COMMENT); }
<COMMENT>"*/" { BEGIN(INITIAL); }
<COMMENT>.    { /* skip comment content */ }
.             { return yytext[0]; }  /* default: return character */
%%
\end{lstlisting}

Gambar \ref{fig:flex-start-conditions} menunjukkan penggunaan start conditions dalam Flex untuk menangani komentar multi-line.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.85\textwidth,center}{%
    \begin{tikzpicture}[
        state/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.5cm, minimum height=0.7cm, font=\footnotesize, align=center, rounded corners, inner sep=4pt},
        arrow/.style={->, >=stealth, thick},
        label/.style={font=\tiny, above, align=center},
        node distance=1.5cm
    ]
    
    \node[state] (initial) {INITIAL\\State};
    \node[state, right=of initial] (comment) {COMMENT\\State};
    
    \draw[arrow] (initial) to[out=45, in=135] node[label] {"/*"} (comment);
    \draw[arrow] (comment) to[out=225, in=315] node[label] {"*/"} (initial);
    
    \node[below=0.3cm of initial, font=\tiny, align=center] {Normal\\tokenization};
    \node[below=0.3cm of comment, font=\tiny, align=center] {Skip\\comment};
    
    \end{tikzpicture}%
    }
    \caption{Start conditions dalam Flex untuk handling komentar}
    \label{fig:flex-start-conditions}
\end{figure}

\subsubsection{User Code Section}

Bagian ini berisi fungsi-fungsi pendukung seperti `main()`, `yywrap()`, dan helper functions.

Gambar \ref{fig:flex-pattern-matching} menunjukkan proses pattern matching dalam Flex.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.85\textwidth,center}{%
    \begin{tikzpicture}[
        input/.style={rectangle, draw=blue!50, fill=blue!10, minimum width=0.5cm, minimum height=0.5cm, font=\footnotesize\ttfamily, align=center},
        pattern/.style={rectangle, draw=green!50, fill=green!10, text width=2cm, minimum height=0.6cm, font=\tiny, align=center, rounded corners},
        action/.style={rectangle, draw=orange!50, fill=orange!10, text width=2.5cm, minimum height=0.6cm, font=\tiny, align=center, rounded corners},
        arrow/.style={->, >=stealth, thick},
        node distance=0.4cm and 0.2cm
    ]
    
    % Input
    \node[input] (i1) {i};
    \node[input, right=of i1] (i2) {f};
    \node[input, right=of i2] (i3) {(};
    
    % Pattern matching
    \node[pattern, below=0.5cm of i1] (p1) {Pattern:\\"if"};
    \node[pattern, below=0.5cm of i2] (p2) {Match!};
    \node[pattern, below=0.5cm of i3] (p3) {Next\\Token};
    
    % Action
    \node[action, below=0.5cm of p2] (a1) {Action:\\return IF;};
    
    \draw[arrow] (i1) -- (p1);
    \draw[arrow] (i2) -- (p2);
    \draw[arrow] (i3) -- (p3);
    \draw[arrow] (p2) -- (a1);
    
    \end{tikzpicture}%
    }
    \caption{Proses pattern matching dalam Flex}
    \label{fig:flex-pattern-matching}
\end{figure}

\subsection{Contoh Lengkap: Flex Lexer untuk Bahasa Sederhana}

Berikut adalah contoh specification file Flex untuk bahasa sederhana dengan token: identifier, number, keyword, dan operator:

\begin{lstlisting}[language=C, caption={Contoh Flex specification file (calc.l)}]
%{
#include <stdio.h>
#include <stdlib.h>
#include "parser.tab.h"  // Header dari Bison

int yylineno = 1;
%}

%option noyywrap
%option yylineno

DIGIT    [0-9]
LETTER   [a-zA-Z_]
ID       {LETTER}({LETTER}|{DIGIT})*
NUMBER   {DIGIT}+
FLOAT    {DIGIT}+\.{DIGIT}+

%%

"int"       { return INT; }
"float"     { return FLOAT_TYPE; }
"if"        { return IF; }
"else"      { return ELSE; }
"while"     { return WHILE; }
"return"   { return RETURN; }

{ID}        { 
                yylval.string = strdup(yytext);
                return IDENTIFIER;
            }

{NUMBER}    { 
                yylval.intval = atoi(yytext);
                return NUMBER;
            }

{FLOAT}     {
                yylval.floatval = atof(yytext);
                return FLOAT_LITERAL;
            }

"+"         { return PLUS; }
"-"         { return MINUS; }
"*"         { return MULTIPLY; }
"/"         { return DIVIDE; }
"="         { return ASSIGN; }
"=="        { return EQ; }
"!="        { return NE; }
"<"         { return LT; }
">"         { return GT; }
"<="        { return LE; }
">="        { return GE; }

"("         { return LPAREN; }
")"         { return RPAREN; }
"{"         { return LBRACE; }
"}"         { return RBRACE; }
";"         { return SEMICOLON; }
","         { return COMMA; }

[ \t]+      { /* skip whitespace */ }
\n          { yylineno++; }
"//".*      { /* skip single-line comment */ }
"/*"        { 
                int c;
                while ((c = input()) != EOF) {
                    if (c == '\n') yylineno++;
                    if (c == '*' && (c = input()) == '/') break;
                    if (c != EOF) unput(c);
                }
            }

.           { 
                fprintf(stderr, "Error: unexpected character '%c' at line %d\n", 
                        yytext[0], yylineno);
                return ERROR;
            }

%%

int yywrap(void) {
    return 1;
}
\end{lstlisting}

Gambar \ref{fig:flex-workflow} menunjukkan workflow penggunaan Flex dari specification file hingga executable.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.9\textwidth,center}{%
    \begin{tikzpicture}[
        file/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.5cm, text centered, minimum height=0.7cm, rounded corners, font=\footnotesize, inner sep=4pt, align=center},
        process/.style={rectangle, draw=green!50, fill=green!10, text width=2.5cm, text centered, minimum height=0.7cm, rounded corners, font=\footnotesize, inner sep=4pt, align=center},
        arrow/.style={->, >=stealth, thick},
        node distance=1.2cm
    ]
    
    \node[file] (spec) {lexer.l\\Specification};
    \node[process, right=of spec] (flex) {flex\\Generator};
    \node[file, right=of flex] (code) {lex.yy.c\\Generated};
    \node[process, below=of code] (gcc) {gcc\\Compiler};
    \node[file, left=of gcc] (exe) {lexer\\Executable};
    
    \draw[arrow] (spec) -- node[above, font=\tiny] {Input} (flex);
    \draw[arrow] (flex) -- node[above, font=\tiny] {Generate} (code);
    \draw[arrow] (code) -- node[right, font=\tiny] {Compile} (gcc);
    \draw[arrow] (gcc) -- node[below, font=\tiny] {Link} (exe);
    
    \end{tikzpicture}%
    }
    \caption{Workflow kompilasi dan penggunaan Flex}
    \label{fig:flex-workflow}
\end{figure}

\subsection{Kompilasi dan Penggunaan Flex}

Untuk menggunakan Flex:

\begin{enumerate}
    \item Buat file specification (misalnya \texttt{lexer.l})
    \item Generate lexer code: \texttt{flex lexer.l} (menghasilkan \texttt{lex.yy.c})
    \item Compile dengan compiler C: \texttt{gcc lex.yy.c -o lexer -lfl}
    \item Atau link dengan program utama: \texttt{gcc main.c lex.yy.c -o program -lfl}
\end{enumerate}

Fungsi utama yang digunakan:
\begin{itemize}
    \item \texttt{yylex()}: Fungsi yang dipanggil untuk mendapatkan token berikutnya
    \item \texttt{yytext}: String yang berisi lexeme yang baru saja di-match
    \item \texttt{yyleng}: Panjang dari \texttt{yytext}
    \item \texttt{yylval}: Union untuk menyimpan nilai semantic (untuk integrasi dengan parser)
\end{itemize}

Gambar \ref{fig:flex-functions} menunjukkan penggunaan fungsi-fungsi utama Flex.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.85\textwidth,center}{%
    \begin{tikzpicture}[
        func/.style={rectangle, draw=blue!50, fill=blue!10, text width=3cm, minimum height=0.7cm, font=\footnotesize, align=center, rounded corners, inner sep=4pt},
        var/.style={rectangle, draw=green!50, fill=green!10, text width=2.5cm, minimum height=0.6cm, font=\tiny, align=center, rounded corners, inner sep=4pt},
        arrow/.style={->, >=stealth, thick},
        node distance=0.6cm and 0.3cm
    ]
    
    \node[func] (yylex) {yylex()};
    \node[var, below left=of yylex] (yytext) {yytext\\lexeme};
    \node[var, below=of yylex] (yyleng) {yyleng\\length};
    \node[var, below right=of yylex] (yylval) {yylval\\semantic};
    
    \draw[arrow] (yylex) -- (yytext);
    \draw[arrow] (yylex) -- (yyleng);
    \draw[arrow] (yylex) -- (yylval);
    
    \node[below=0.3cm of yyleng, font=\tiny] {Return: Token Type};
    
    \end{tikzpicture}%
    }
    \caption{Fungsi dan variabel utama dalam Flex}
    \label{fig:flex-functions}
\end{figure}

Gambar \ref{fig:flex-vs-re2c} menunjukkan perbandingan arsitektur Flex dan re2c.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.9\textwidth,center}{%
    \begin{tikzpicture}[
        box/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.5cm, text centered, minimum height=0.7cm, rounded corners, font=\footnotesize, inner sep=4pt, align=center},
        arrow/.style={->, >=stealth, thick},
        title/.style={font=\bfseries\small},
        node distance=0.6cm and 0.3cm
    ]
    
    % Flex column
    \node[title] (flex-title) {FLEX};
    
    \node[box, below=of flex-title] (flex1) {lexer.l\\Separate File};
    \node[box, below=of flex1] (flex2) {flex\\Tool};
    \node[box, below=of flex2] (flex3) {lex.yy.c\\Generated};
    \node[box, below=of flex3] (flex4) {Compile\\\& Link};
    
    \draw[arrow] (flex1) -- (flex2);
    \draw[arrow] (flex2) -- (flex3);
    \draw[arrow] (flex3) -- (flex4);
    
    % re2c column
    \node[title, right=4cm of flex-title] (re2c-title) {RE2C};
    
    \node[box, below=of re2c-title] (re2c1) {lexer.re.c\\Embedded Spec};
    \node[box, below=of re2c1] (re2c2) {re2c\\Tool};
    \node[box, below=of re2c2] (re2c3) {lexer.c\\Generated};
    \node[box, below=of re2c3] (re2c4) {Compile\\\& Link};
    
    \draw[arrow] (re2c1) -- (re2c2);
    \draw[arrow] (re2c2) -- (re2c3);
    \draw[arrow] (re2c3) -- (re2c4);
    
    \end{tikzpicture}%
    }
    \caption{Perbandingan arsitektur Flex dan re2c}
    \label{fig:flex-vs-re2c}
\end{figure}

\section{re2c (Regular Expressions to Code)}

re2c adalah lexer generator modern yang menghasilkan kode C/C++ dengan performa tinggi. Berbeda dengan Flex yang menggunakan file terpisah, re2c menggunakan \textbf{embedded specification} dalam kode C/C++.

Menurut dokumentasi resmi re2c:

\begin{quote}
``re2c is a tool that generates fast lexers for C, C++ and Go. It compiles regular expressions to deterministic finite automata and encodes them as conditional jumps and comparisons. The generated code is highly optimized and does not use tables.''\footnote{\url{https://re2c.org/}}
\end{quote}

\subsection{Struktur re2c Specification}

re2c specification ditulis dalam komentar khusus `/*!re2c ... */` yang disisipkan dalam kode C/C++:

\begin{lstlisting}[language=C, caption={Struktur dasar re2c}]
#include <stdio.h>

static int lex(const char *YYCURSOR) {
    const char *YYMARKER;
    /*!re2c
        re2c:define:YYCTYPE = "char";
        re2c:yyfill:enable = 0;
        
        // Named patterns
        digit    = [0-9];
        letter   = [a-zA-Z_];
        id       = letter (letter | digit)*;
        number   = digit+;
        
        // Rules
        *        { return 0; }  // error
        number   { printf("Number: %.*s\n", (int)(YYCURSOR - YYMARKER), YYMARKER); return 1; }
        id       { printf("ID: %.*s\n", (int)(YYCURSOR - YYMARKER), YYMARKER); return 1; }
        [ \t\n]+ { continue; }  // skip whitespace
    */
}

int main(int argc, char *argv[]) {
    for (int i = 1; i < argc; i++) {
        lex(argv[i]);
    }
    return 0;
}
\end{lstlisting}

Gambar \ref{fig:re2c-workflow} menunjukkan workflow penggunaan re2c.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.9\textwidth,center}{%
    \begin{tikzpicture}[
        file/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.5cm, text centered, minimum height=0.7cm, rounded corners, font=\footnotesize, inner sep=4pt, align=center},
        process/.style={rectangle, draw=green!50, fill=green!10, text width=2.5cm, text centered, minimum height=0.7cm, rounded corners, font=\footnotesize, inner sep=4pt, align=center},
        arrow/.style={->, >=stealth, thick},
        node distance=1.2cm
    ]
    
    \node[file] (spec) {lexer.re.c\\Embedded Spec};
    \node[process, right=of spec] (re2c) {re2c\\Generator};
    \node[file, right=of re2c] (code) {lexer.c\\Generated};
    \node[process, below=of code] (gcc) {gcc\\Compiler};
    \node[file, left=of gcc] (exe) {lexer\\Executable};
    
    \draw[arrow] (spec) -- node[above, font=\tiny] {Process} (re2c);
    \draw[arrow] (re2c) -- node[above, font=\tiny] {Generate} (code);
    \draw[arrow] (code) -- node[right, font=\tiny] {Compile} (gcc);
    \draw[arrow] (gcc) -- node[below, font=\tiny] {Link} (exe);
    
    \end{tikzpicture}%
    }
    \caption{Workflow kompilasi dan penggunaan re2c}
    \label{fig:re2c-workflow}
\end{figure}

\subsection{Key Concepts dalam re2c}

Gambar \ref{fig:re2c-variables} menunjukkan penggunaan variabel khusus dalam re2c.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.85\textwidth,center}{%
    \begin{tikzpicture}[
        buffer/.style={rectangle, draw=gray!30, fill=gray!5, text width=8cm, minimum height=0.6cm, font=\footnotesize\ttfamily, align=left, inner sep=4pt},
        pointer/.style={rectangle, draw=red!50, fill=red!10, minimum width=0.3cm, minimum height=0.3cm, font=\tiny, align=center},
        label/.style={font=\tiny, align=center},
        arrow/.style={->, >=stealth, thick, red},
        node distance=0.3cm
    ]
    
    % Buffer
    \node[buffer] (buf) {int x = 42;};
    
    % Pointers
    \node[pointer, above=0.2cm of buf, xshift=-3.5cm] (cursor) {};
    \node[label, above=0.1cm of cursor] {YYCURSOR};
    
    \node[pointer, above=0.2cm of buf, xshift=-2.5cm, draw=blue!50, fill=blue!10] (marker) {};
    \node[label, above=0.1cm of marker] {YYMARKER};
    
    \node[pointer, above=0.2cm of buf, xshift=3.5cm, draw=green!50, fill=green!10] (limit) {};
    \node[label, above=0.1cm of limit] {YYLIMIT};
    
    % Arrows
    \draw[arrow] (cursor) -- node[left, font=\tiny] {current} (buf);
    \draw[arrow, blue] (marker) -- node[left, font=\tiny] {backtrack} (buf);
    \draw[arrow, green] (limit) -- node[right, font=\tiny] {end} (buf);
    
    \end{tikzpicture}%
    }
    \caption{Variabel khusus re2c untuk tracking posisi input}
    \label{fig:re2c-variables}
\end{figure}

\subsubsection{Variables Khusus}

re2c menggunakan variabel khusus untuk tracking posisi input:
\begin{itemize}
    \item \texttt{YYCURSOR}: Pointer ke posisi saat ini dalam input
    \item \texttt{YYMARKER}: Pointer untuk backtracking
    \item \texttt{YYLIMIT}: Pointer ke akhir buffer
    \item \texttt{YYCTYPE}: Tipe data untuk karakter (default: \texttt{unsigned char})
\end{itemize}

\subsubsection{Directives}

Directives mengkonfigurasi behavior re2c:
\begin{itemize}
    \item \texttt{re2c:define:YYCTYPE}: Mendefinisikan tipe karakter
    \item \texttt{re2c:yyfill:enable}: Enable/disable buffer filling
    \item \texttt{re2c:input}: Mendefinisikan cara membaca input
    \item \texttt{re2c:conditions}: Enable start conditions (seperti Flex)
\end{itemize}

\subsection{Contoh Lengkap: re2c Lexer untuk Identifier dan Number}

\begin{lstlisting}[language=C, caption={Contoh re2c lexer (lexer.re.c)}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef enum {
    TOKEN_EOF,
    TOKEN_IDENTIFIER,
    TOKEN_NUMBER,
    TOKEN_PLUS,
    TOKEN_MINUS,
    TOKEN_MULTIPLY,
    TOKEN_DIVIDE,
    TOKEN_ERROR
} TokenType;

typedef struct {
    TokenType type;
    char *value;
    int line;
} Token;

static Token tokenize(const char *input, int *line) {
    const char *YYCURSOR = input;
    const char *YYMARKER;
    const char *start;
    Token token = {TOKEN_EOF, NULL, *line};
    
    /*!re2c
        re2c:define:YYCTYPE = "char";
        re2c:yyfill:enable = 0;
        re2c:define:YYCURSOR = "YYCURSOR";
        
        digit    = [0-9];
        letter   = [a-zA-Z_];
        id       = letter (letter | digit)*;
        number   = digit+;
        ws       = [ \t]+;
        newline  = "\n";
        
        * {
            token.type = TOKEN_ERROR;
            return token;
        }
        
        "\x00" {
            token.type = TOKEN_EOF;
            return token;
        }
        
        ws {
            continue;
        }
        
        newline {
            (*line)++;
            continue;
        }
        
        number {
            start = YYMARKER;
            int len = YYCURSOR - start;
            token.value = (char*)malloc(len + 1);
            strncpy(token.value, start, len);
            token.value[len] = '\0';
            token.type = TOKEN_NUMBER;
            token.line = *line;
            return token;
        }
        
        id {
            start = YYMARKER;
            int len = YYCURSOR - start;
            token.value = (char*)malloc(len + 1);
            strncpy(token.value, start, len);
            token.value[len] = '\0';
            token.type = TOKEN_IDENTIFIER;
            token.line = *line;
            return token;
        }
        
        "+" {
            token.type = TOKEN_PLUS;
            token.line = *line;
            return token;
        }
        
        "-" {
            token.type = TOKEN_MINUS;
            token.line = *line;
            return token;
        }
        
        "*" {
            token.type = TOKEN_MULTIPLY;
            token.line = *line;
            return token;
        }
        
        "/" {
            token.type = TOKEN_DIVIDE;
            token.line = *line;
            return token;
        }
    */
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <input>\n", argv[0]);
        return 1;
    }
    
    int line = 1;
    Token token;
    
    do {
        token = tokenize(argv[1], &line);
        printf("Token: %d, Value: %s, Line: %d\n", 
               token.type, token.value ? token.value : "NULL", token.line);
        if (token.value) free(token.value);
    } while (token.type != TOKEN_EOF && token.type != TOKEN_ERROR);
    
    return 0;
}
\end{lstlisting}

Untuk mengkompilasi:
\begin{verbatim}
re2c -o lexer.c lexer.re.c
gcc lexer.c -o lexer
\end{verbatim}

Gambar \ref{fig:re2c-example} menunjukkan contoh penggunaan re2c untuk tokenize input sederhana.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.85\textwidth,center}{%
    \begin{tikzpicture}[
        code/.style={rectangle, draw=gray!30, fill=gray!5, text width=6cm, minimum height=0.6cm, font=\footnotesize\ttfamily, align=left, inner sep=4pt},
        token/.style={rectangle, draw=blue!50, fill=blue!10, text width=1.2cm, minimum height=0.5cm, font=\tiny, align=center, inner sep=2pt},
        arrow/.style={->, >=stealth, thick, gray},
        node distance=0.3cm and 0.15cm
    ]
    
    % Input
    \node[code] (input) {Input: "x + 42"};
    
    % Tokens
    \node[token, below=0.5cm of input, xshift=-2cm] (t1) {x\\ID};
    \node[token, right=of t1] (t2) {+\\PLUS};
    \node[token, right=of t2] (t3) {42\\NUM};
    
    % Arrows
    \draw[arrow] (input.south) to[out=-90, in=90] (t1.north);
    \draw[arrow] (input.south) to[out=-90, in=90] (t2.north);
    \draw[arrow] (input.south) to[out=-90, in=90] (t3.north);
    
    \node[below=0.3cm of t2, font=\small\bfseries] {re2c Token Stream};
    
    \end{tikzpicture}%
    }
    \caption{Contoh tokenization dengan re2c}
    \label{fig:re2c-example}
\end{figure}

Gambar \ref{fig:comparison-table} menunjukkan perbandingan visual antara hand-written, Flex, dan re2c.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.95\textwidth,center}{%
    \begin{tikzpicture}[
        box/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.8cm, text centered, minimum height=0.6cm, rounded corners, font=\footnotesize, inner sep=4pt, align=center},
        good/.style={rectangle, draw=green!50, fill=green!10, text width=2.8cm, text centered, minimum height=0.6cm, rounded corners, font=\tiny, inner sep=4pt, align=center},
        medium/.style={rectangle, draw=orange!50, fill=orange!10, text width=2.8cm, text centered, minimum height=0.6cm, rounded corners, font=\tiny, inner sep=4pt, align=center},
        node distance=0.3cm and 0.2cm
    ]
    
    % Headers
    \node[box, font=\bfseries] (h1) {Aspek};
    \node[box, right=of h1, font=\bfseries] (h2) {Hand-Written};
    \node[box, right=of h2, font=\bfseries] (h3) {Flex};
    \node[box, right=of h3, font=\bfseries] (h4) {re2c};
    
    % Rows
    \node[box, below=of h1] (r1) {Produktivitas};
    \node[medium, below=of h2] {Rendah};
    \node[good, below=of h3] {Tinggi};
    \node[good, below=of h4] {Tinggi};
    
    \node[box, below=of r1] (r2) {Maintainability};
    \node[medium, below=of r2] {Sedang};
    \node[good, below=of r2, xshift=2.8cm] {Tinggi};
    \node[good, below=of r2, xshift=5.6cm] {Tinggi};
    
    \node[box, below=of r2] (r3) {Performa};
    \node[good, below=of r3] {Tinggi};
    \node[medium, below=of r3, xshift=2.8cm] {Sedang};
    \node[good, below=of r3, xshift=5.6cm] {Sangat Tinggi};
    
    \node[box, below=of r3] (r4) {Fleksibilitas};
    \node[good, below=of r4] {Sangat Tinggi};
    \node[medium, below=of r4, xshift=2.8cm] {Sedang};
    \node[medium, below=of r4, xshift=5.6cm] {Sedang};
    
    \end{tikzpicture}%
    }
    \caption{Perbandingan hand-written, Flex, dan re2c}
    \label{fig:comparison-table}
\end{figure}

\section{Perbandingan Hand-Written vs Generator-Based Lexer}

Setelah mempelajari kedua pendekatan, mari kita bandingkan:

\subsection{Hand-Written Lexer}

\textbf{Keuntungan:}
\begin{itemize}
    \item Kontrol penuh terhadap implementasi
    \item Tidak ada dependency eksternal
    \item Dapat dioptimasi secara spesifik untuk kebutuhan
    \item Pemahaman mendalam tentang proses tokenization
\end{itemize}

\textbf{Kekurangan:}
\begin{itemize}
    \item Lebih banyak kode yang harus ditulis dan maintain
    \item Lebih mudah terjadi bug (edge cases)
    \item Perlu implementasi ulang untuk setiap bahasa
    \item Lebih sulit untuk modifikasi pattern
\end{itemize}

\subsection{Generator-Based Lexer}

\textbf{Keuntungan:}
\begin{itemize}
    \item Specification lebih ringkas dan mudah dibaca
    \item Generator menghasilkan kode yang sudah teroptimasi
    \item Lebih cepat dalam development
    \item Pattern mudah dimodifikasi tanpa mengubah banyak kode
    \item Sudah teruji dan digunakan di banyak project
\end{itemize}

\textbf{Kekurangan:}
\begin{itemize}
    \item Perlu mempelajari syntax generator
    \item Dependency pada tool eksternal
    \item Kurang fleksibel untuk kasus yang sangat spesifik
    \item Generated code mungkin lebih sulit di-debug
\end{itemize}

Gambar \ref{fig:performance-comparison} menunjukkan perbandingan performa secara visual.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.85\textwidth,center}{%
    \begin{tikzpicture}[
        bar/.style={rectangle, draw=blue!50, fill=blue!10, minimum height=0.5cm, font=\tiny, align=center, inner sep=2pt},
        label/.style={font=\footnotesize, align=center},
        node distance=0.3cm
    ]
    
    % Performance bars
    \node[label] (l1) {Hand-Written};
    \node[bar, right=0.2cm of l1, minimum width=2cm] (b1) {100\%};
    
    \node[label, below=0.3cm of l1] (l2) {Flex};
    \node[bar, right=0.2cm of l2, minimum width=1.5cm, draw=orange!50, fill=orange!10] (b2) {75\%};
    
    \node[label, below=0.3cm of l2] (l3) {re2c};
    \node[bar, right=0.2cm of l3, minimum width=2.2cm, draw=green!50, fill=green!10] (b3) {110\%};
    
    \node[right=3cm of l1, font=\tiny] {Relative Performance};
    
    \end{tikzpicture}%
    }
    \caption{Perbandingan performa relatif (hand-written = baseline)}
    \label{fig:performance-comparison}
\end{figure}

\subsection{Perbandingan Performa}

Secara umum, generator-based lexer (terutama re2c) memiliki performa yang sangat baik karena:
\begin{itemize}
    \item Kode dihasilkan dengan optimasi DFA
    \item Tidak ada overhead dari table lookup (untuk re2c)
    \item Compiler dapat mengoptimasi generated code lebih baik
\end{itemize}

Hand-written lexer dapat lebih cepat hanya jika dioptimasi secara khusus untuk kasus tertentu, tetapi memerlukan effort yang lebih besar.

Gambar \ref{fig:lexer-parser-integration} menunjukkan alur integrasi lexer dengan parser.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.9\textwidth,center}{%
    \begin{tikzpicture}[
        box/.style={rectangle, draw=blue!50, fill=blue!10, text width=2.5cm, text centered, minimum height=0.7cm, rounded corners, font=\footnotesize, inner sep=4pt, align=center},
        shared/.style={rectangle, draw=green!50, fill=green!10, text width=2.5cm, text centered, minimum height=0.7cm, rounded corners, font=\footnotesize, inner sep=4pt, align=center},
        arrow/.style={->, >=stealth, thick},
        node distance=1.2cm
    ]
    
    \node[box] (source) {Source\\Code};
    \node[box, right=of source] (lexer) {Lexer\\(Flex/re2c)};
    \node[shared, below=of lexer] (tokens) {tokens.h\\Shared};
    \node[box, right=of lexer] (parser) {Parser\\(Bison)};
    \node[box, below=of parser] (ast) {AST};
    
    \draw[arrow] (source) -- (lexer);
    \draw[arrow] (lexer) -- node[above, font=\tiny, align=center] {Token\\Stream} (parser);
    \draw[arrow] (parser) -- (ast);
    \draw[arrow, dashed] (tokens) -- (lexer);
    \draw[arrow, dashed] (tokens) -- (parser);
    
    \end{tikzpicture}%
    }
    \caption{Integrasi lexer dengan parser}
    \label{fig:lexer-parser-integration}
\end{figure}

\section{Integrasi dengan Parser}

Lexer biasanya digunakan bersama dengan parser. Integrasi dilakukan melalui:

\subsection{Token Definitions}

Token constants didefinisikan dalam header file yang dibagi antara lexer dan parser:

\begin{lstlisting}[language=C, caption={File tokens.h}]
#ifndef TOKENS_H
#define TOKENS_H

typedef enum {
    // Keywords
    TOKEN_IF = 256,
    TOKEN_ELSE,
    TOKEN_WHILE,
    TOKEN_RETURN,
    TOKEN_INT,
    TOKEN_FLOAT,
    
    // Identifiers and literals
    TOKEN_IDENTIFIER,
    TOKEN_NUMBER,
    TOKEN_FLOAT_LITERAL,
    
    // Operators
    TOKEN_PLUS,
    TOKEN_MINUS,
    TOKEN_MULTIPLY,
    TOKEN_DIVIDE,
    TOKEN_ASSIGN,
    TOKEN_EQ,
    TOKEN_NE,
    
    // Punctuation
    TOKEN_LPAREN,
    TOKEN_RPAREN,
    TOKEN_LBRACE,
    TOKEN_RBRACE,
    TOKEN_SEMICOLON,
    TOKEN_COMMA,
    
    TOKEN_EOF,
    TOKEN_ERROR
} TokenType;

#endif
\end{lstlisting}

\subsection{Semantic Values}

Untuk mengirim nilai dari lexer ke parser, digunakan union \texttt{yylval}:

\begin{lstlisting}[language=C, caption={File yystype.h}]
#ifndef YYSTYPE_H
#define YYSTYPE_H

#include "tokens.h"

typedef union {
    int intval;
    double floatval;
    char *string;
} YYSTYPE;

extern YYSTYPE yylval;

#endif
\end{lstlisting}

Gambar \ref{fig:flex-bison-integration} menunjukkan contoh integrasi Flex dengan Bison secara detail.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.85\textwidth,center}{%
    \begin{tikzpicture}[
        file/.style={rectangle, draw=blue!50, fill=blue!10, text width=3cm, minimum height=0.8cm, font=\footnotesize, align=center, rounded corners, inner sep=4pt},
        shared/.style={rectangle, draw=green!50, fill=green!10, text width=3cm, minimum height=0.8cm, font=\footnotesize, align=center, rounded corners, inner sep=4pt},
        arrow/.style={->, >=stealth, thick},
        node distance=0.8cm
    ]
    
    \node[file] (flex) {lexer.l\\Flex Spec};
    \node[file, right=of flex] (bison) {parser.y\\Bison Spec};
    \node[shared, below=of flex] (tokens) {tokens.h\\yystype.h};
    \node[shared, below=of bison] (parser-tab) {parser.tab.h};
    \node[file, below=of tokens] (lex-yy) {lex.yy.c\\Generated};
    \node[file, below=of parser-tab] (parser-tab-c) {parser.tab.c\\Generated};
    \node[file, below=1.5cm of lex-yy, xshift=1.5cm] (exe) {program\\Executable};
    
    \draw[arrow] (flex) -- (lex-yy);
    \draw[arrow] (bison) -- (parser-tab-c);
    \draw[arrow, dashed] (tokens) -- (flex);
    \draw[arrow, dashed] (tokens) -- (bison);
    \draw[arrow, dashed] (parser-tab) -- (flex);
    \draw[arrow] (lex-yy) -- (exe);
    \draw[arrow] (parser-tab-c) -- (exe);
    
    \end{tikzpicture}%
    }
    \caption{Integrasi Flex dengan Bison: file dan dependencies}
    \label{fig:flex-bison-integration}
\end{figure}

\subsection{Contoh Integrasi Flex dengan Bison}

File Flex (\texttt{lexer.l}):
\begin{lstlisting}[language={},basicstyle=\ttfamily\footnotesize,breaklines=true,breakatwhitespace=false]
%{
#include "parser.tab.h"
#include "yystype.h"
%}

%%
{NUMBER} { yylval.intval = atoi(yytext); return NUMBER; }
{ID}     { yylval.string = strdup(yytext); return IDENTIFIER; }
%%
\end{lstlisting}

File Bison (\texttt{parser.y}):
\begin{verbatim}
%{
#include "yystype.h"
%}

%union {
    int intval;
    char *string;
}

%token <intval> NUMBER
%token <string> IDENTIFIER

%%
expression: NUMBER { printf("Number: %d\n", $1); }
         | IDENTIFIER { printf("ID: %s\n", $1); }
         ;
%%
\end{verbatim}

Gambar \ref{fig:tokenization-example} menunjukkan contoh tokenization menggunakan Flex untuk input sederhana.

\begin{figure}[H]
    \centering
    \adjustbox{max width=0.9\textwidth,center}{%
    \begin{tikzpicture}[
        code/.style={rectangle, draw=gray!30, fill=gray!5, text width=8cm, minimum height=0.6cm, font=\footnotesize\ttfamily, align=left, inner sep=4pt},
        token/.style={rectangle, draw=blue!50, fill=blue!10, text width=1.3cm, minimum height=0.5cm, font=\tiny, align=center, inner sep=2pt},
        arrow/.style={->, >=stealth, thick, gray},
        node distance=0.3cm and 0.15cm
    ]
    
    % Source code
    \node[code] (source) {int x = 42 + y;};
    
    % Tokens
    \node[token, below=0.5cm of source, xshift=-3cm] (t1) {int\\KEYWORD};
    \node[token, right=of t1] (t2) {x\\IDENTIFIER};
    \node[token, right=of t2] (t3) {=\\ASSIGN};
    \node[token, right=of t3] (t4) {42\\NUMBER};
    \node[token, right=of t4] (t5) {+\\PLUS};
    \node[token, right=of t5] (t6) {y\\IDENTIFIER};
    \node[token, right=of t6] (t7) {;\\SEMICOLON};
    
    % Arrows
    \draw[arrow] (source.south) to[out=-90, in=90] (t1.north);
    \draw[arrow] (source.south) to[out=-90, in=90] (t2.north);
    \draw[arrow] (source.south) to[out=-90, in=90] (t3.north);
    \draw[arrow] (source.south) to[out=-90, in=90] (t4.north);
    \draw[arrow] (source.south) to[out=-90, in=90] (t5.north);
    \draw[arrow] (source.south) to[out=-90, in=90] (t6.north);
    \draw[arrow] (source.south) to[out=-90, in=90] (t7.north);
    
    \node[below=0.3cm of t4, font=\small\bfseries] {Flex Token Stream};
    
    \end{tikzpicture}%
    }
    \caption{Contoh tokenization dengan Flex: \texttt{int x = 42 + y;}}
    \label{fig:tokenization-example}
\end{figure}

\section{Praktikum: Membuat Lexer dengan Flex}

\subsection{Tugas Praktikum}

Buatlah lexer menggunakan Flex untuk bahasa mini dengan minimal 10 token types:

\begin{enumerate}
    \item \textbf{Keywords}: \texttt{if}, \texttt{else}, \texttt{while}, \texttt{int}, \texttt{float}, \texttt{return}
    \item \textbf{Identifiers}: Nama variabel dan fungsi
    \item \textbf{Literals}: Integer dan float numbers
    \item \textbf{Operators}: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{=}, \texttt{==}, \texttt{!=}, \texttt{<}, \texttt{>}
    \item \textbf{Punctuation}: \texttt{(}, \texttt{)}, \texttt{\{}, \texttt{\}}, \texttt{;}, \texttt{,}
    \item \textbf{Comments}: Single-line (\texttt{//}) dan multi-line (\texttt{/* */})
\end{enumerate}

\subsection{Langkah-langkah}

\begin{enumerate}
    \item Buat file \texttt{lexer.l} dengan specification sesuai requirement
    \item Generate lexer: \texttt{flex lexer.l}
    \item Buat program test sederhana yang menggunakan \texttt{yylex()}
    \item Test dengan berbagai input (valid dan invalid)
    \item Dokumentasikan token types dan behavior lexer
\end{enumerate}

\subsection{Expected Output}

Lexer harus dapat:
\begin{itemize}
    \item Mengenali semua token types yang didefinisikan
    \item Menangani whitespace dan comments dengan benar
    \item Memberikan error message yang informatif untuk invalid input
    \item Melacak line number untuk error reporting
\end{itemize}

\section{Kesimpulan}

Dalam bab ini, kita telah mempelajari:

\begin{enumerate}
    \item Keuntungan menggunakan lexer generator dibanding hand-written lexer
    \item Cara menggunakan Flex untuk membuat specification file dan generate lexer
    \item Cara menggunakan re2c dengan embedded specification
    \item Perbandingan antara hand-written dan generator-based lexer
    \item Integrasi lexer dengan parser menggunakan token definitions dan semantic values
\end{enumerate}

Generator-based lexer adalah pilihan yang tepat untuk sebagian besar kasus karena memberikan keseimbangan yang baik antara produktivitas, maintainability, dan performa. Namun, pemahaman tentang hand-written lexer (seperti yang dipelajari di bab sebelumnya) tetap penting untuk memahami proses tokenization secara mendalam.

\section{Latihan}

\begin{enumerate}
    \item Buatlah specification file Flex untuk mengenali token-token berikut:
    \begin{itemize}
        \item Keywords: \texttt{for}, \texttt{break}, \texttt{continue}
        \item String literals (dengan escape sequences: \texttt{\textbackslash n}, \texttt{\textbackslash t}, \texttt{\textbackslash "})
        \item Character literals (dalam single quotes)
        \item Operators: \texttt{++}, \texttt{--}, \texttt{+=}, \texttt{-=}
    \end{itemize}
    
    \item Implementasikan lexer menggunakan re2c untuk bahasa yang sama seperti soal 1. Bandingkan kompleksitas specification antara Flex dan re2c.
    
    \item Jelaskan kapan sebaiknya menggunakan hand-written lexer dan kapan menggunakan generator. Berikan contoh kasus untuk masing-masing.
    
    \item Buatlah program yang mengintegrasikan Flex lexer dengan Bison parser sederhana untuk:
    \begin{itemize}
        \item Parsing ekspresi aritmatika: \texttt{a + b * c}
        \item Parsing assignment: \texttt{x = 42;}
        \item Parsing conditional: \texttt{if (x > 0) \{ ... \}}
    \end{itemize}
    
    \item Analisis performa: Buat benchmark untuk membandingkan:
    \begin{itemize}
        \item Hand-written lexer (dari Bab 3)
        \item Flex-generated lexer
        \item re2c-generated lexer
    \end{itemize}
    Gunakan input file yang besar (misalnya 10MB) dan ukur waktu eksekusi.
    
    \item Jelaskan bagaimana Flex menangani longest match dan rule priority. Berikan contoh yang menunjukkan perbedaan hasil ketika urutan rule diubah.
    
    Gambar \ref{fig:longest-match} menunjukkan contoh longest match dalam Flex.
    
    \begin{figure}[H]
        \centering
        \adjustbox{max width=0.8\textwidth,center}{%
        \begin{tikzpicture}[
            input/.style={rectangle, draw=blue!50, fill=blue!10, minimum width=0.5cm, minimum height=0.5cm, font=\footnotesize\ttfamily, align=center},
            match/.style={rectangle, draw=green!50, fill=green!10, text width=2.5cm, minimum height=0.6cm, font=\tiny, align=center, rounded corners},
            node distance=0.2cm and 0.15cm
        ]
        
        % Input: ==
        \node[input] (c1) {=};
        \node[input, right=of c1] (c2) {=};
        \node[input, right=of c2] (c3) {;};
        
        % Matches
        \node[match, below=0.5cm of c1] (m1) {Match 1:\\"=" (ASSIGN)};
        \node[match, below=0.5cm of c2] (m2) {Match 2:\\"==" (EQ)\\Longest!};
        
        \draw[->, >=stealth, thick, green] (c1) -- (m1);
        \draw[->, >=stealth, thick, green] (c2) -- (m2);
        \draw[->, >=stealth, thick, dashed, red] (m1) to[out=0, in=180] node[above, font=\tiny, align=center] {Reject} (m2);
        
        \node[below=0.3cm of m2, font=\tiny] {Flex memilih longest match: "=="};
        
        \end{tikzpicture}%
        }
        \caption{Longest match dalam Flex: \texttt{==} dipilih daripada \texttt{=}}
        \label{fig:longest-match}
    \end{figure}
\end{enumerate}

\section{Referensi dan Bahan Bacaan Lanjutan}

Untuk memperdalam pemahaman tentang lexer generator, mahasiswa disarankan membaca:

\begin{itemize}
    \item \textbf{Flex Manual}: Dokumentasi resmi Flex \footnote{\url{https://www.gnu.org/software/flex/manual/}}
    
    \item \textbf{re2c Documentation}: Dokumentasi dan tutorial re2c \footnote{\url{https://re2c.org/}}
    
    \item \textbf{flex \& bison}: Levine, J. R. (2009). \textit{flex \& bison: Text Processing Tools} \cite{levine2009flex} - Bab 2: Using Flex
    
    \item \textbf{Engineering a Compiler}: Cooper \& Torczon (2011) \cite{cooper2011engineering} - Bab 2: Lexical Analysis (bagian tentang lexer generators)
    
    \item \textbf{IT Trip - C Parser Flex Bison}: Tutorial tentang integrasi Flex dan Bison \cite{ittrip2024bison}
    
    \item \textbf{Wikipedia - re2c}: Artikel tentang re2c \cite{wikipedia2024re2c}
    
    \item \textbf{Wikipedia - RE/flex}: Artikel tentang RE/flex (modern C++ lexer generator) \footnote{\url{https://en.wikipedia.org/wiki/Draft:RE/flex}}
\end{itemize}
