% Bab 14: Code Generation untuk Target Architecture
% File ini dapat dikompilasi terpisah atau sebagai bagian dari main.tex

\chapter{Code Generation untuk Target Architecture}
\label{chap:code-generation}

\section{Tujuan Pembelajaran}

Setelah mempelajari bab ini, mahasiswa diharapkan mampu:
\begin{enumerate}
    \item Memahami proses code generation dari intermediate representation ke target code
    \item Menjelaskan konsep instruction selection dan implementasinya
    \item Mengimplementasikan register allocation sederhana (local allocation)
    \item Membuat code generator untuk operasi aritmatika dan assignment
    \item Memahami dan mengimplementasikan calling convention untuk function calls
    \item Menghasilkan assembly code yang valid untuk target architecture (x86 atau RISC-V)
\end{enumerate}

\section{Pengenalan Code Generation}

Code generation adalah fase terakhir dalam back-end kompilator yang bertanggung jawab untuk menghasilkan target code dari intermediate representation (IR) yang telah dioptimasi. Menurut sumber dari StudyLib:

\begin{quote}
``Code generation: instruction selection, machine model. Implement code generation for a target architecture, mapping intermediate code into efficient target code, managing run-time structures.''\cite{studylib2024obe}
\end{quote}

Code generator mengambil IR (biasanya dalam bentuk three-address code atau format serupa) dan menghasilkan kode assembly atau machine code yang dapat dieksekusi pada target architecture tertentu.

\subsection{Tugas Code Generator}

Code generator memiliki beberapa tugas utama:

\begin{enumerate}
    \item \textbf{Instruction Selection}: Memilih instruksi machine yang tepat untuk setiap operasi IR
    \item \textbf{Register Allocation}: Mengalokasikan register untuk variabel dan temporary values
    \item \textbf{Instruction Scheduling}: Mengatur urutan instruksi untuk optimasi pipeline
    \item \textbf{Address Assignment}: Mengalokasikan memory untuk variabel dan data structures
    \item \textbf{Code Emission}: Menghasilkan assembly atau machine code dalam format yang sesuai
\end{enumerate}

\subsection{Input dan Output Code Generator}

\textbf{Input Code Generator:}
\begin{itemize}
    \item Optimized Intermediate Representation (TAC, quadruples, atau format IR lainnya)
    \item Symbol table dengan informasi tipe dan alamat variabel
    \item Target architecture specification (instruction set, register set, addressing modes)
\end{itemize}

\textbf{Output Code Generator:}
\begin{itemize}
    \item Assembly code (untuk assembler) atau machine code langsung
    \item Relocation information (jika diperlukan)
    \item Debug information (optional)
\end{itemize}

\section{Target Architecture}

Target architecture adalah platform hardware yang menjadi tujuan kompilasi. Setiap architecture memiliki karakteristik yang berbeda yang mempengaruhi bagaimana code generator bekerja.

\subsection{Karakteristik Target Architecture}

Menurut dokumentasi LLVM\footnote{\url{https://llvm.org/docs/CodeGenerator.html}}, target architecture memiliki beberapa karakteristik penting:

\begin{enumerate}
    \item \textbf{Instruction Set Architecture (ISA)}: Kumpulan instruksi yang didukung oleh processor
    \begin{itemize}
        \item RISC (Reduced Instruction Set Computer): Instruksi sederhana, uniform, banyak register
        \item CISC (Complex Instruction Set Computer): Instruksi kompleks, berbagai format, addressing modes yang kaya
    \end{itemize}
    
    \item \textbf{Register Set}: Jumlah dan jenis register yang tersedia
    \begin{itemize}
        \item General-purpose registers
        \item Special-purpose registers (stack pointer, frame pointer, dll.)
        \item Floating-point registers
    \end{itemize}
    
    \item \textbf{Addressing Modes}: Cara mengakses operan (register, memory, immediate)
    \begin{itemize}
        \item Register addressing: \texttt{ADD R1, R2}
        \item Immediate addressing: \texttt{ADD R1, \#42}
        \item Memory addressing: \texttt{LOAD R1, [address]}
        \item Indexed addressing: \texttt{LOAD R1, [R2 + offset]}
    \end{itemize}
    
    \item \textbf{Memory Model}: Bagaimana memory diorganisir dan diakses
    \begin{itemize}
        \item Byte-addressable vs word-addressable
        \item Alignment requirements
        \item Endianness (little-endian vs big-endian)
    \end{itemize}
\end{enumerate}

\subsection{Contoh Target Architecture}

Dalam pembelajaran ini, kita akan fokus pada dua target architecture populer:

\textbf{1. x86-64 (AMD64)}
\begin{itemize}
    \item CISC architecture dengan instruksi kompleks
    \item 16 general-purpose registers (RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, R8-R15)
    \item Berbagai addressing modes
    \item Variable-length instructions
    \item Little-endian
\end{itemize}

\textbf{2. RISC-V}
\begin{itemize}
    \item RISC architecture dengan instruksi sederhana
    \item 32 general-purpose registers (x0-x31)
    \item Fixed-length instructions (32-bit atau 16-bit untuk compressed)
    \item Simple addressing modes
    \item Little-endian atau big-endian (configurable)
    \item Open standard, populer untuk pembelajaran
\end{itemize}

Untuk pembelajaran, kita akan menggunakan subset sederhana dari RISC-V karena lebih mudah dipahami dan diimplementasikan.

\section{Instruction Selection}

Instruction selection adalah proses memilih instruksi machine yang tepat untuk mengimplementasikan setiap operasi dalam IR. Tujuannya adalah menghasilkan kode yang efisien dalam hal:
\begin{itemize}
    \item Execution time (runtime performance)
    \item Code size
    \item Energy consumption
\end{itemize}

\subsection{Metode Instruction Selection}

Menurut Wikipedia\footnote{\url{https://en.wikipedia.org/wiki/Instruction_selection}}, terdapat beberapa metode instruction selection:

\subsubsection{1. Simple Translation}

Metode paling sederhana: setiap operasi IR langsung dipetakan ke satu atau beberapa instruksi machine.

Contoh: TAC \texttt{t1 = t2 + t3} untuk RISC-V:
\begin{verbatim}
ADD t1, t2, t3
\end{verbatim}

Kelebihan: Implementasi mudah, cepat
Kekurangan: Tidak selalu optimal, tidak memanfaatkan instruksi kompleks

\subsubsection{2. Tree Pattern Matching}

Menggunakan expression tree dan mencocokkan subtree dengan pattern instruksi machine.

Contoh: Ekspresi \texttt{a + b * c} dapat dicocokkan dengan pattern:
\begin{itemize}
    \item Pattern 1: MUL + ADD (dua instruksi terpisah)
    \item Pattern 2: FMA (fused multiply-add, satu instruksi jika tersedia)
\end{itemize}

\subsubsection{3. Dynamic Programming}

Menggunakan dynamic programming untuk menemukan sequence instruksi yang optimal dengan mempertimbangkan cost.

\subsection{Contoh Instruction Selection}

Mari kita lihat contoh instruction selection untuk operasi sederhana pada RISC-V:

\textbf{Contoh 1: Assignment}
\begin{verbatim}
TAC: x = y
RISC-V: MV x, y    (atau ADD x, y, x0 untuk register zero)
\end{verbatim}

\textbf{Contoh 2: Arithmetic Operations}
\begin{verbatim}
TAC: t1 = a + b
RISC-V: ADD t1, a, b

TAC: t2 = c * d
RISC-V: MUL t2, c, d

TAC: t3 = t1 - t2
RISC-V: SUB t3, t1, t2
\end{verbatim}

\textbf{Contoh 3: Load/Store}
\begin{verbatim}
TAC: x = mem[addr]
RISC-V: LW x, 0(addr)    (load word)

TAC: mem[addr] = x
RISC-V: SW x, 0(addr)    (store word)
\end{verbatim}

\textbf{Contoh 4: Constant Loading}
\begin{verbatim}
TAC: x = 42
RISC-V: LI x, 42         (load immediate, pseudo-instruction)
       atau
       ADDI x, x0, 42   (add immediate dengan zero register)
\end{verbatim}

\section{Register Allocation}

Register allocation adalah proses menentukan variabel dan temporary values mana yang disimpan di register (fast storage) dan mana yang di-spill ke memory. Karena jumlah register fisik terbatas, ini adalah optimasi yang constrained.

\subsection{Mengapa Register Allocation Penting?}

Menurut Wikipedia\footnote{\url{https://en.wikipedia.org/wiki/Register_allocation}}:

\begin{itemize}
    \item Register jauh lebih cepat daripada memory access
    \item Jumlah register fisik terbatas (biasanya 16-32 register)
    \item Program mungkin memiliki lebih banyak variabel aktif daripada jumlah register
    \item Register allocation yang baik dapat meningkatkan performa secara signifikan
\end{itemize}

\subsection{Dua Fase Register Allocation}

\subsubsection{1. Allocation Phase}

Memutuskan \textit{mana} nilai yang harus disimpan di register pada setiap program point. Ini melibatkan:
\begin{itemize}
    \item Live range analysis: Kapan variabel hidup (live) dan kapan mati (dead)
    \item Interference graph: Grafik yang menunjukkan variabel mana yang tidak bisa menggunakan register yang sama secara bersamaan
\end{itemize}

\subsubsection{2. Assignment Phase}

Memetakan nilai yang dialokasikan ke register fisik spesifik. Jika lebih banyak nilai yang perlu register daripada register yang tersedia, beberapa nilai harus di-spill ke memory.

\subsection{Local Register Allocation}

Local register allocation bekerja dalam satu basic block (satu entry, satu exit, tidak ada branching). Ini lebih sederhana karena control flow linear.

\subsubsection{Algoritma Simple Local Allocation}

Algoritma sederhana untuk local allocation:

\begin{enumerate}
    \item Scan basic block dari awal hingga akhir
    \item Untuk setiap instruksi:
    \begin{itemize}
        \item Jika operan tidak di register, load dari memory
        \item Eksekusi operasi menggunakan register
        \item Jika hasil perlu disimpan dan register penuh, spill register yang paling lama tidak digunakan
    \end{itemize}
    \item Di akhir block, store semua register yang modified ke memory
\end{enumerate}

\subsubsection{Contoh Local Allocation}

Misalkan kita memiliki basic block dengan TAC berikut:
\begin{verbatim}
t1 = a + b
t2 = t1 * c
d = t2
\end{verbatim}

Dengan 3 register tersedia (R1, R2, R3), allocation bisa seperti ini:
\begin{verbatim}
LOAD R1, a        ; Load a ke R1
LOAD R2, b        ; Load b ke R2
ADD R1, R1, R2    ; R1 = a + b (t1)
LOAD R2, c        ; Load c ke R2 (b tidak lagi diperlukan)
MUL R1, R1, R2    ; R1 = t1 * c (t2)
STORE R1, d       ; Store hasil ke d
\end{verbatim}

\subsection{Global Register Allocation}

Global register allocation bekerja lintas basic blocks atau seluruh function. Ini lebih kompleks karena perlu mempertimbangkan control flow.

Metode populer:
\begin{itemize}
    \item \textbf{Graph Coloring}: Membangun interference graph dan mewarnainya dengan k warna (k = jumlah register)
    \item \textbf{Linear Scan}: Lebih cepat, menghitung live intervals dan assign register dalam satu pass
\end{itemize}

Untuk pembelajaran, kita akan fokus pada local allocation yang lebih sederhana.

\section{Code Generation untuk Operasi Aritmatika}

Mari kita implementasikan code generator untuk operasi aritmatika dasar. Kita akan menggunakan RISC-V sebagai target architecture.

\subsection{Struktur Code Generator Sederhana}

Code generator sederhana dapat diimplementasikan sebagai visitor pattern yang traverse AST atau TAC dan menghasilkan assembly code.

\subsubsection{Contoh Implementasi dalam C++}

Berikut adalah struktur dasar code generator:

\begin{lstlisting}[language=C++, caption={Struktur dasar Code Generator}]
class CodeGenerator {
private:
    std::vector<std::string> assemblyCode;
    int tempCounter;
    std::map<std::string, std::string> varToReg;
    std::set<std::string> availableRegs;
    
public:
    CodeGenerator() : tempCounter(0) {
        // Inisialisasi register yang tersedia
        for (int i = 1; i <= 8; i++) {
            availableRegs.insert("t" + std::to_string(i));
        }
    }
    
    std::string getRegister(const std::string& var) {
        // Alokasi register untuk variabel
        if (varToReg.find(var) != varToReg.end()) {
            return varToReg[var];
        }
        
        if (!availableRegs.empty()) {
            std::string reg = *availableRegs.begin();
            availableRegs.erase(reg);
            varToReg[var] = reg;
            return reg;
        }
        
        // Spill ke memory jika register penuh
        return spillRegister(var);
    }
    
    void generateAdd(const std::string& result, 
                     const std::string& op1, 
                     const std::string& op2) {
        std::string reg1 = getRegister(op1);
        std::string reg2 = getRegister(op2);
        std::string regResult = getRegister(result);
        
        assemblyCode.push_back("ADD " + regResult + ", " + 
                              reg1 + ", " + reg2);
    }
    
    void generateMul(const std::string& result,
                     const std::string& op1,
                     const std::string& op2) {
        std::string reg1 = getRegister(op1);
        std::string reg2 = getRegister(op2);
        std::string regResult = getRegister(result);
        
        assemblyCode.push_back("MUL " + regResult + ", " +
                              reg1 + ", " + reg2);
    }
    
    void generateLoad(const std::string& reg, 
                      const std::string& var) {
        assemblyCode.push_back("LW " + reg + ", " + var);
    }
    
    void generateStore(const std::string& var,
                       const std::string& reg) {
        assemblyCode.push_back("SW " + reg + ", " + var);
    }
    
    std::vector<std::string> getAssembly() {
        return assemblyCode;
    }
};
\end{lstlisting}

\subsection{Generating Code untuk Ekspresi Kompleks}

Untuk ekspresi kompleks seperti \texttt{a + b * c}, kita perlu mempertimbangkan precedence:

\begin{verbatim}
TAC untuk: result = a + b * c

t1 = b * c
t2 = a + t1
result = t2

Generated RISC-V code:
LW t1, a          ; Load a
LW t2, b          ; Load b
LW t3, c          ; Load c
MUL t4, t2, t3    ; t4 = b * c
ADD t5, t1, t4    ; t5 = a + t4
SW t5, result     ; Store result
\end{verbatim}

\section{Handling Function Calls dan Calling Convention}

Function calls memerlukan koordinasi antara caller dan callee untuk:
\begin{itemize}
    \item Passing arguments
    \item Saving/restoring registers
    \item Managing stack frame
    \item Returning values
\end{itemize}

Calling convention mendefinisikan aturan ini.

\subsection{RISC-V Calling Convention}

RISC-V memiliki calling convention yang didefinisikan dalam ABI (Application Binary Interface):

\subsubsection{Register Usage}

\begin{itemize}
    \item \textbf{Argument Registers}: a0-a7 (x10-x17) untuk 8 argument pertama
    \item \textbf{Return Register}: a0 (x10) untuk return value
    \item \textbf{Caller-saved Registers}: t0-t6 (x5-x7, x28-x31) - caller harus save
    \item \textbf{Callee-saved Registers}: s0-s11 (x8-x9, x18-x27) - callee harus save
    \item \textbf{Stack Pointer}: sp (x2)
    \item \textbf{Frame Pointer}: fp/s0 (x8)
\end{itemize}

\subsubsection{Function Call Sequence}

\textbf{Caller Side:}
\begin{verbatim}
# Save caller-saved registers jika diperlukan
# Pass arguments ke a0-a7
# Call function
JAL ra, function_name
# Return value di a0
# Restore caller-saved registers
\end{verbatim}

\textbf{Callee Side (Function Prologue):}
\begin{verbatim}
function_name:
    # Save return address dan frame pointer
    ADDI sp, sp, -frame_size
    SW ra, frame_size-4(sp)
    SW fp, frame_size-8(sp)
    ADDI fp, sp, frame_size
    
    # Save callee-saved registers yang digunakan
    # Allocate space untuk local variables
\end{verbatim}

\textbf{Callee Side (Function Epilogue):}
\begin{verbatim}
    # Restore callee-saved registers
    # Put return value di a0
    # Restore frame pointer dan return address
    LW fp, frame_size-8(sp)
    LW ra, frame_size-4(sp)
    ADDI sp, sp, frame_size
    RET  # atau JALR x0, 0(ra)
\end{verbatim}

\subsection{Contoh Function Call}

Mari kita lihat contoh function call untuk \texttt{int add(int a, int b)}:

\textbf{Caller Code:}
\begin{verbatim}
# Prepare arguments
LI a0, 10        # First argument (a = 10)
LI a1, 20        # Second argument (b = 20)

# Call function
JAL ra, add

# Result is in a0
# Use result...
\end{verbatim}

\textbf{Callee Code (add function):}
\begin{verbatim}
add:
    # Function prologue
    ADDI sp, sp, -16    # Allocate stack frame
    SW ra, 12(sp)       # Save return address
    SW fp, 8(sp)        # Save frame pointer
    ADDI fp, sp, 16     # Set frame pointer
    
    # Function body
    ADD a0, a0, a1      # a0 = a0 + a1 (result)
    
    # Function epilogue
    LW fp, 8(sp)        # Restore frame pointer
    LW ra, 12(sp)       # Restore return address
    ADDI sp, sp, 16     # Deallocate stack frame
    RET                 # Return
\end{verbatim}

\section{Implementasi Code Generator Lengkap}

Mari kita buat implementasi code generator yang lebih lengkap yang dapat menangani berbagai operasi.

\subsection{Code Generator untuk TAC}

Berikut adalah contoh code generator yang mengambil TAC dan menghasilkan RISC-V assembly:

\begin{lstlisting}[language=C++, caption={Code Generator untuk TAC ke RISC-V}]
class TACCodeGenerator {
private:
    std::vector<std::string> assembly;
    int labelCounter;
    std::map<std::string, int> varOffset;  // Offset di stack frame
    int stackOffset;
    
public:
    TACCodeGenerator() : labelCounter(0), stackOffset(0) {}
    
    void generateTAC(const TACInstruction& tac) {
        switch (tac.op) {
            case TAC_OP::ADD:
                generateAdd(tac.result, tac.arg1, tac.arg2);
                break;
            case TAC_OP::SUB:
                generateSub(tac.result, tac.arg1, tac.arg2);
                break;
            case TAC_OP::MUL:
                generateMul(tac.result, tac.arg1, tac.arg2);
                break;
            case TAC_OP::DIV:
                generateDiv(tac.result, tac.arg1, tac.arg2);
                break;
            case TAC_OP::ASSIGN:
                generateAssign(tac.result, tac.arg1);
                break;
            case TAC_OP::LOAD:
                generateLoad(tac.result, tac.arg1);
                break;
            case TAC_OP::STORE:
                generateStore(tac.arg1, tac.result);
                break;
            // ... operasi lainnya
        }
    }
    
    void generateAdd(const std::string& result,
                     const std::string& arg1,
                     const std::string& arg2) {
        std::string reg1 = loadToRegister(arg1);
        std::string reg2 = loadToRegister(arg2);
        std::string regResult = allocateRegister(result);
        
        assembly.push_back("ADD " + regResult + ", " + 
                          reg1 + ", " + reg2);
        
        releaseRegister(reg1);
        releaseRegister(reg2);
    }
    
    // ... implementasi operasi lainnya
};
\end{lstlisting}

\section{Testing dan Validasi}

Setelah code generator menghasilkan assembly, kita perlu:
\begin{enumerate}
    \item \textbf{Assemble}: Mengubah assembly menjadi object file
    \item \textbf{Link}: Menyatukan object files menjadi executable
    \item \textbf{Run}: Mengeksekusi program dan memverifikasi hasilnya
\end{enumerate}

\subsection{Workflow Lengkap}

\begin{verbatim}
Source Code (C/C++)
    ↓
[Compiler Front-end]
    ↓
TAC / IR
    ↓
[Code Generator] → Assembly Code (.s)
    ↓
[Assembler] → Object File (.o)
    ↓
[Linker] → Executable
    ↓
[Run] → Verify Output
\end{verbatim}

\subsection{Contoh Testing}

Misalkan kita memiliki program sederhana:
\begin{verbatim}
int main() {
    int a = 10;
    int b = 20;
    int c = a + b;
    return c;
}
\end{verbatim}

TAC yang dihasilkan:
\begin{verbatim}
t1 = 10
a = t1
t2 = 20
b = t2
t3 = a + b
c = t3
return c
\end{verbatim}

Assembly yang dihasilkan (RISC-V):
\begin{verbatim}
main:
    ADDI sp, sp, -16
    SW ra, 12(sp)
    SW fp, 8(sp)
    ADDI fp, sp, 16
    
    # a = 10
    LI t0, 10
    SW t0, -4(fp)    # Store a di stack
    
    # b = 20
    LI t0, 20
    SW t0, -8(fp)    # Store b di stack
    
    # c = a + b
    LW t1, -4(fp)    # Load a
    LW t2, -8(fp)    # Load b
    ADD t0, t1, t2
    SW t0, -12(fp)   # Store c
    
    # return c
    LW a0, -12(fp)   # Return value
    
    LW fp, 8(sp)
    LW ra, 12(sp)
    ADDI sp, sp, 16
    RET
\end{verbatim}

\section{Kesimpulan}

Dalam bab ini, kita telah mempelajari:

\begin{enumerate}
    \item Code generation adalah fase terakhir yang mengubah IR menjadi target code
    \item Instruction selection memilih instruksi machine yang tepat untuk setiap operasi IR
    \item Register allocation menentukan variabel mana yang disimpan di register vs memory
    \item Local register allocation lebih sederhana dan cocok untuk pembelajaran awal
    \item Calling convention mengatur bagaimana function calls dilakukan
    \item Code generator harus menghasilkan assembly yang valid dan dapat di-assemble, link, dan run
\end{enumerate}

Implementasi code generator yang baik memerlukan pemahaman mendalam tentang target architecture dan trade-off antara code size, execution time, dan register pressure.

\section{Latihan}

\begin{enumerate}
    \item Implementasikan code generator sederhana untuk operasi aritmatika dasar (+, -, *, /) yang menghasilkan RISC-V assembly.
    
    \item Buatlah code generator untuk assignment statement. Test dengan berbagai skenario:
    \begin{itemize}
        \item Assignment dari constant ke variabel
        \item Assignment dari variabel ke variabel
        \item Assignment dari ekspresi ke variabel
    \end{itemize}
    
    \item Implementasikan local register allocation dengan algoritma sederhana. Test dengan basic block yang memiliki lebih banyak variabel aktif daripada jumlah register yang tersedia.
    
    \item Buatlah code generator untuk function call sederhana dengan 2-3 parameter. Implementasikan calling convention RISC-V.
    
    \item Test workflow lengkap: compile → assemble → link → run untuk program sederhana yang menghitung \texttt{a * b + c}.
    
    \item Bandingkan code yang dihasilkan untuk ekspresi \texttt{a + b * c} dengan dan tanpa optimasi register allocation. Hitung jumlah instruksi dan memory access.
    
    \item Implementasikan code generator untuk conditional statement (if-else) dengan branch instructions.
    
    \item Buatlah code generator untuk loop (for/while) dengan label dan jump instructions.
\end{enumerate}

\section{Referensi dan Bahan Bacaan Lanjutan}

Untuk memperdalam pemahaman tentang code generation, mahasiswa disarankan membaca:

\begin{itemize}
    \item \textbf{Dragon Book}: Aho, Lam, Sethi, \& Ullman (2006). \textit{Compilers: Principles, Techniques, and Tools} \cite{aho2006compilers} - Bab 8: Code Generation
    
    \item \textbf{Engineering a Compiler}: Cooper \& Torczon (2011) \cite{cooper2011engineering} - Bab 7-9: Code Shape, Introduction to Optimization, Scalar Optimizations
    
    \item \textbf{RISC-V Instruction Set Manual}: \url{https://riscv.org/technical/specifications/} - Dokumentasi lengkap instruksi RISC-V
    
    \item \textbf{LLVM Code Generator Documentation}: \url{https://llvm.org/docs/CodeGenerator.html} - Dokumentasi code generator LLVM
    
    \item \textbf{StudyLib - Outcomes-Based Education}: Materials tentang code generation dan runtime structures \cite{studylib2024obe}
    
    \item \textbf{Wikipedia - Register Allocation}: \url{https://en.wikipedia.org/wiki/Register_allocation} - Artikel tentang teknik register allocation
    
    \item \textbf{Wikipedia - Instruction Selection}: \url{https://en.wikipedia.org/wiki/Instruction_selection} - Artikel tentang instruction selection
\end{itemize}
