% Bab 6: Top-Down Parsing dan Recursive Descent
% File ini dapat dikompilasi terpisah atau sebagai bagian dari main.tex

\chapter{Top-Down Parsing dan Recursive Descent}
\label{chap:top-down-parsing}

\section{Tujuan Pembelajaran}

Setelah mempelajari bab ini, mahasiswa diharapkan mampu:
\begin{enumerate}
    \item Menjelaskan konsep top-down parsing dan perbedaannya dengan bottom-up parsing
    \item Memahami LL parsing dan karakteristiknya
    \item Mengimplementasikan recursive descent parser untuk grammar sederhana
    \item Menangani precedence dan associativity dalam recursive descent parser
    \item Mengimplementasikan error recovery pada recursive descent parser
    \item Mengintegrasikan lexer dengan recursive descent parser
    \item Mengevaluasi ekspresi aritmatika menggunakan recursive descent parser
\end{enumerate}

\section{Pendahuluan}

Setelah mempelajari lexical analysis dan context-free grammar pada bab-bab sebelumnya, kita sekarang akan mempelajari bagaimana mengimplementasikan parser yang menganalisis struktur sintaksis dari stream token yang dihasilkan oleh lexer. Top-down parsing adalah salah satu pendekatan yang paling intuitif dan mudah diimplementasikan secara manual.

Menurut sumber terbuka:

\begin{quote}
``Top-down parsers (recursive descent) – easy to hand-write; better for LL(1) grammars, when unambiguous. Works by writing functions for grammar nonterminals (e.g. expression(), term(), factor()) that consume tokens one at a time.''\cite{opengenus2024lexer}
\end{quote}

Pendekatan top-down parsing dimulai dari start symbol grammar dan mencoba menurunkan (derive) input dengan membangun parse tree dari root ke leaves. Ini berbeda dengan bottom-up parsing yang membangun parse tree dari leaves ke root.

\section{Konsep Top-Down Parsing}

\subsection{Definisi Top-Down Parsing}

Top-down parsing adalah teknik parsing yang dimulai dari start symbol grammar dan mencoba menurunkan input dengan menerapkan production rules dari atas ke bawah. Parser mencoba mencocokkan input dengan memprediksi production mana yang harus digunakan berdasarkan lookahead token.

Karakteristik utama top-down parsing:
\begin{itemize}
    \item Membangun parse tree dari root (start symbol) ke leaves (terminals)
    \item Menggunakan leftmost derivation
    \item Memerlukan lookahead untuk memprediksi production yang tepat
    \item Dapat diimplementasikan secara recursive atau iterative dengan stack
\end{itemize}

\subsection{LL Parsing}

LL parsing adalah kelas top-down parsing yang membaca input dari \textbf{L}eft ke right dan menghasilkan \textbf{L}eftmost derivation. Notasi LL(k) menunjukkan bahwa parser menggunakan k token lookahead untuk membuat keputusan parsing.

Menurut sumber dari USNA:

\begin{quote}
``Top-down parsing starts from the start symbol and tries to rewrite it to match the input, building a parse tree from root to leaves. LL parsing means scanning input Left-to-right, producing a Leftmost derivation, using k-token lookahead (usually LL(1)).''\footnote{\url{https://www.usna.edu/Users/cs/wcbrown/courses/F20SI413/lec/l09/lec.html}}
\end{quote}

LL(1) adalah yang paling umum digunakan karena hanya memerlukan satu token lookahead, membuat implementasinya lebih sederhana dan efisien.

\subsection{Keuntungan dan Keterbatasan Top-Down Parsing}

\textbf{Keuntungan:}
\begin{itemize}
    \item Mudah diimplementasikan secara manual (recursive descent)
    \item Error messages yang lebih intuitif (dapat menunjukkan posisi error dengan tepat)
    \item Tidak memerlukan preprocessing grammar yang kompleks (untuk grammar LL(1))
    \item Cocok untuk grammar yang sudah dalam bentuk yang sesuai
\end{itemize}

\textbf{Keterbatasan:}
\begin{itemize}
    \item Tidak dapat menangani left recursion secara langsung
    \item Memerlukan grammar yang sudah di-factoring untuk menghindari ambiguity
    \item Tidak sekuat LR parsing dalam hal kemampuan parsing
    \item Beberapa grammar memerlukan transformasi sebelum dapat di-parse dengan top-down
\end{itemize}

\section{Recursive Descent Parsing}

\subsection{Konsep Recursive Descent}

Recursive descent parsing adalah teknik implementasi top-down parsing di mana setiap non-terminal dalam grammar direpresentasikan sebagai sebuah fungsi. Fungsi-fungsi ini saling memanggil secara recursive sesuai dengan struktur grammar.

Menurut sumber dari Ernest Chu:

\begin{quote}
``Recursive-descent parsing is a hand-written parser (one function per non-terminal), possibly with backtracking. When you eliminate left recursion and factor grammar properly, you can build deterministic predictive parsers (LL(1))—recursive descent without backtracking.''\footnote{\url{https://ernestchu.github.io/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html}}
\end{quote}

Struktur dasar recursive descent parser:
\begin{enumerate}
    \item Setiap non-terminal memiliki fungsi sendiri
    \item Fungsi membaca token dari input stream
    \item Fungsi memanggil fungsi lain sesuai dengan production rules
    \item Terminal dicocokkan langsung dengan token saat ini
\end{enumerate}

\subsection{Implementasi Dasar}

Mari kita lihat contoh implementasi recursive descent parser untuk grammar ekspresi aritmatika sederhana. Grammar yang akan kita gunakan:

\begin{verbatim}
E  -> T E'
E' -> + T E' | epsilon
T  -> F T'
T' -> * F T' | epsilon
F  -> ( E ) | id | num
\end{verbatim}

Grammar ini sudah dalam bentuk yang sesuai untuk LL(1) parsing karena:
\begin{itemize}
    \item Tidak ada left recursion
    \item Sudah di-factoring (E' dan T' menangani associativity)
    \item Setiap production dapat diputuskan dengan satu token lookahead
\end{itemize}

Implementasi dalam C++:

\begin{lstlisting}[language=C++, caption={Struktur dasar recursive descent parser}]
#include <iostream>
#include <string>
#include <vector>

enum TokenType {
    TOK_ID, TOK_NUM, TOK_PLUS, TOK_MUL,
    TOK_LPAREN, TOK_RPAREN, TOK_END, TOK_ERROR
};

struct Token {
    TokenType type;
    std::string lexeme;
    int line, col;
};

class RecursiveDescentParser {
private:
    std::vector<Token> tokens;
    size_t current;
    Token lookahead;
    
    void nextToken() {
        if (current < tokens.size()) {
            lookahead = tokens[current++];
        } else {
            lookahead = {TOK_END, "", 0, 0};
        }
    }
    
    void match(TokenType expected) {
        if (lookahead.type == expected) {
            nextToken();
        } else {
            error("Expected " + tokenToString(expected) + 
                  " but got " + lookahead.lexeme);
        }
    }
    
    void error(const std::string& msg) {
        std::cerr << "Syntax error at line " << lookahead.line 
                  << ", col " << lookahead.col << ": " << msg << std::endl;
        exit(1);
    }
    
public:
    RecursiveDescentParser(const std::vector<Token>& t) 
        : tokens(t), current(0) {
        nextToken();
    }
    
    // Grammar: E -> T E'
    void parseE() {
        parseT();
        parseEPrime();
    }
    
    // Grammar: E' -> + T E' | epsilon
    void parseEPrime() {
        if (lookahead.type == TOK_PLUS) {
            match(TOK_PLUS);
            parseT();
            parseEPrime();
        }
        // else: epsilon production, do nothing
    }
    
    // Grammar: T -> F T'
    void parseT() {
        parseF();
        parseTPrime();
    }
    
    // Grammar: T' -> * F T' | epsilon
    void parseTPrime() {
        if (lookahead.type == TOK_MUL) {
            match(TOK_MUL);
            parseF();
            parseTPrime();
        }
        // else: epsilon production, do nothing
    }
    
    // Grammar: F -> ( E ) | id | num
    void parseF() {
        if (lookahead.type == TOK_LPAREN) {
            match(TOK_LPAREN);
            parseE();
            match(TOK_RPAREN);
        } else if (lookahead.type == TOK_ID) {
            match(TOK_ID);
        } else if (lookahead.type == TOK_NUM) {
            match(TOK_NUM);
        } else {
            error("Expected identifier, number, or '('");
        }
    }
    
    void parse() {
        parseE();
        if (lookahead.type != TOK_END) {
            error("Extra input after expression");
        }
        std::cout << "Parse successful!" << std::endl;
    }
};
\end{lstlisting}

\section{Handling Precedence dan Associativity}

\subsection{Konsep Precedence}

Precedence menentukan urutan evaluasi operator ketika beberapa operator muncul dalam ekspresi yang sama. Misalnya, dalam ekspresi \texttt{a + b * c}, operator \texttt{*} memiliki precedence lebih tinggi daripada \texttt{+}, sehingga dievaluasi terlebih dahulu.

Dalam recursive descent parser, precedence di-handle melalui struktur grammar. Operator dengan precedence lebih tinggi berada di level yang lebih dalam dalam parse tree.

\subsection{Handling Associativity}

Associativity menentukan bagaimana operator dengan precedence yang sama dievaluasi. Ada dua jenis:
\begin{itemize}
    \item \textbf{Left-associative}: Dievaluasi dari kiri ke kanan, misalnya \texttt{a - b - c} = \texttt{(a - b) - c}
    \item \textbf{Right-associative}: Dievaluasi dari kanan ke kiri, misalnya \texttt{a = b = c} = \texttt{a = (b = c)}
\end{itemize}

Dalam grammar yang kita gunakan, E' dan T' menggunakan left recursion yang diubah menjadi right recursion untuk menangani left associativity dengan benar.

Contoh grammar untuk menangani precedence dan associativity:

\begin{verbatim}
E  -> T E'        (expression level, lowest precedence)
E' -> + T E' | epsilon  (addition, left-associative)
T  -> F T'        (term level, higher precedence)
T' -> * F T' | epsilon  (multiplication, left-associative)
F  -> ( E ) | id  (factor level, highest precedence)
\end{verbatim}

Struktur ini memastikan bahwa:
\begin{itemize}
    \item Operator \texttt{*} memiliki precedence lebih tinggi daripada \texttt{+} (T berada di bawah E)
    \item Kedua operator left-associative (menggunakan right recursion dengan tail call)
    \item Parentheses memiliki precedence tertinggi (F)
\end{itemize}

\subsection{Implementasi dengan Evaluasi}

Berikut adalah implementasi recursive descent parser yang tidak hanya mem-parse tetapi juga mengevaluasi ekspresi:

\begin{lstlisting}[language=C++, caption={Recursive descent parser dengan evaluasi}]
class ExpressionEvaluator {
private:
    std::vector<Token> tokens;
    size_t current;
    Token lookahead;
    
    void nextToken() {
        if (current < tokens.size()) {
            lookahead = tokens[current++];
        } else {
            lookahead = {TOK_END, "", 0, 0};
        }
    }
    
    void match(TokenType expected) {
        if (lookahead.type == expected) {
            nextToken();
        } else {
            throw std::runtime_error("Syntax error");
        }
    }
    
public:
    ExpressionEvaluator(const std::vector<Token>& t) 
        : tokens(t), current(0) {
        nextToken();
    }
    
    // E -> T E'
    // Returns value of expression
    int parseE() {
        int value = parseT();
        return parseEPrime(value);
    }
    
    // E' -> + T E' | epsilon
    // Accumulates addition operations
    int parseEPrime(int left) {
        if (lookahead.type == TOK_PLUS) {
            match(TOK_PLUS);
            int right = parseT();
            return parseEPrime(left + right);
        }
        return left;  // epsilon production
    }
    
    // T -> F T'
    int parseT() {
        int value = parseF();
        return parseTPrime(value);
    }
    
    // T' -> * F T' | epsilon
    // Accumulates multiplication operations
    int parseTPrime(int left) {
        if (lookahead.type == TOK_MUL) {
            match(TOK_MUL);
            int right = parseF();
            return parseTPrime(left * right);
        }
        return left;  // epsilon production
    }
    
    // F -> ( E ) | num
    int parseF() {
        if (lookahead.type == TOK_LPAREN) {
            match(TOK_LPAREN);
            int value = parseE();
            match(TOK_RPAREN);
            return value;
        } else if (lookahead.type == TOK_NUM) {
            int value = std::stoi(lookahead.lexeme);
            match(TOK_NUM);
            return value;
        } else {
            throw std::runtime_error("Expected number or '('");
        }
    }
    
    int evaluate() {
        int result = parseE();
        if (lookahead.type != TOK_END) {
            throw std::runtime_error("Extra input");
        }
        return result;
    }
};
\end{lstlisting}

\section{Error Recovery pada Recursive Descent}

\subsection{Pentingnya Error Recovery}

Error recovery adalah kemampuan parser untuk melanjutkan parsing setelah menemukan error, sehingga dapat melaporkan multiple errors dalam satu pass. Tanpa error recovery, parser akan berhenti pada error pertama.

\subsection{Strategi Error Recovery}

Beberapa strategi error recovery yang umum digunakan:

\subsubsection{Synchronization Points}

Menentukan synchronization points (token-token yang dapat digunakan untuk recovery), seperti:
\begin{itemize}
    \item Statement terminators (\texttt{;}, \texttt{\}})
    \item Keywords yang menandai awal konstruksi baru (\texttt{if}, \texttt{while}, \texttt{return})
    \item Operator yang jelas (\texttt{+}, \texttt{-}, \texttt{*})
\end{itemize}

\subsubsection{Panic Mode Recovery}

Ketika error ditemukan, parser membuang token sampai menemukan synchronization point:

\begin{lstlisting}[language=C++, caption={Panic mode error recovery}]
void parseE() {
    parseT();
    parseEPrime();
}

void parseEPrime() {
    if (lookahead.type == TOK_PLUS) {
        match(TOK_PLUS);
        parseT();
        parseEPrime();
    } else if (!isValidFollow(lookahead.type)) {
        // Error recovery: skip until synchronization point
        error("Expected '+' or end of expression");
        while (!isSynchronizationPoint(lookahead.type) && 
               lookahead.type != TOK_END) {
            nextToken();
        }
    }
    // else: valid follow token, epsilon production
}

bool isSynchronizationPoint(TokenType t) {
    return t == TOK_RPAREN || t == TOK_END || 
           t == TOK_SEMICOLON;
}

bool isValidFollow(TokenType t) {
    return t == TOK_RPAREN || t == TOK_END || 
           t == TOK_SEMICOLON || t == TOK_PLUS;
}
\end{lstlisting}

\subsubsection{Error Production}

Menambahkan production khusus untuk menangani error:

\begin{verbatim}
E' -> + T E' | epsilon | error E'
\end{verbatim}

Ketika error ditemukan, parser dapat menggunakan error production untuk recovery.

\subsection{Implementasi Error Recovery yang Lebih Baik}

Berikut adalah implementasi yang lebih robust dengan error recovery:

\begin{lstlisting}[language=C++, caption={Error recovery yang lebih baik}]
class ParserWithRecovery {
private:
    int errorCount;
    std::vector<Token> tokens;
    size_t current;
    Token lookahead;
    
    void nextToken() {
        if (current < tokens.size()) {
            lookahead = tokens[current++];
        } else {
            lookahead = {TOK_END, "", 0, 0};
        }
    }
    
    void error(const std::string& msg) {
        errorCount++;
        std::cerr << "Error at line " << lookahead.line 
                  << ", col " << lookahead.col << ": " 
                  << msg << std::endl;
    }
    
    void synchronize() {
        // Skip tokens until synchronization point
        while (lookahead.type != TOK_END) {
            if (isSynchronizationPoint(lookahead.type)) {
                return;
            }
            nextToken();
        }
    }
    
    bool isSynchronizationPoint(TokenType t) {
        return t == TOK_RPAREN || t == TOK_SEMICOLON || 
               t == TOK_END || t == TOK_PLUS || t == TOK_MUL;
    }
    
public:
    ParserWithRecovery(const std::vector<Token>& t) 
        : tokens(t), current(0), errorCount(0) {
        nextToken();
    }
    
    void parseE() {
        try {
            parseT();
            parseEPrime();
        } catch (...) {
            error("Error in expression");
            synchronize();
        }
    }
    
    void parseEPrime() {
        if (lookahead.type == TOK_PLUS) {
            match(TOK_PLUS);
            parseT();
            parseEPrime();
        } else if (!isValidFollow(lookahead.type)) {
            error("Expected '+' or end of expression");
            synchronize();
        }
    }
    
    int getErrorCount() const { return errorCount; }
};
\end{lstlisting}

\section{Integrasi Lexer dengan Parser}

\subsection{Arsitektur Integrasi}

Dalam implementasi praktis, lexer dan parser bekerja bersama dalam pipeline:

\begin{lstlisting}[language={},basicstyle=\ttfamily\footnotesize,breaklines=true,breakatwhitespace=false]
Source Code -> Lexer -> Token Stream -> Parser -> Parse Tree/AST
\end{lstlisting}

Lexer membaca source code karakter demi karakter dan menghasilkan stream token. Parser kemudian membaca token dari stream ini.

\subsection{Implementasi Terintegrasi}

Berikut adalah contoh implementasi lexer dan parser yang terintegrasi:

\begin{lstlisting}[language=C++, caption={Lexer dan parser terintegrasi}]
#include <iostream>
#include <string>
#include <cctype>

class IntegratedLexerParser {
private:
    std::string input;
    size_t pos;
    int line, col;
    Token lookahead;
    
    // Lexer functions
    void skipWhitespace() {
        while (pos < input.size() && isspace(input[pos])) {
            if (input[pos] == '\n') {
                line++;
                col = 1;
            } else {
                col++;
            }
            pos++;
        }
    }
    
    Token nextToken() {
        skipWhitespace();
        
        if (pos >= input.size()) {
            return {TOK_END, "", line, col};
        }
        
        char c = input[pos];
        int startCol = col;
        
        // Identifier: [a-zA-Z][a-zA-Z0-9]*
        if (isalpha(c)) {
            std::string lexeme;
            while (pos < input.size() && isalnum(input[pos])) {
                lexeme += input[pos++];
                col++;
            }
            return {TOK_ID, lexeme, line, startCol};
        }
        
        // Number: [0-9]+
        if (isdigit(c)) {
            std::string lexeme;
            while (pos < input.size() && isdigit(input[pos])) {
                lexeme += input[pos++];
                col++;
            }
            return {TOK_NUM, lexeme, line, startCol};
        }
        
        // Operators and punctuation
        pos++;
        col++;
        switch (c) {
            case '+': return {TOK_PLUS, "+", line, startCol};
            case '*': return {TOK_MUL, "*", line, startCol};
            case '(': return {TOK_LPAREN, "(", line, startCol};
            case ')': return {TOK_RPAREN, ")", line, startCol};
            default: return {TOK_ERROR, std::string(1, c), line, startCol};
        }
    }
    
    void match(TokenType expected) {
        if (lookahead.type == expected) {
            lookahead = nextToken();
        } else {
            std::cerr << "Error: Expected " << expected 
                      << " but got " << lookahead.lexeme 
                      << " at line " << lookahead.line 
                      << ", col " << lookahead.col << std::endl;
            exit(1);
        }
    }
    
public:
    IntegratedLexerParser(const std::string& s) 
        : input(s), pos(0), line(1), col(1) {
        lookahead = nextToken();
    }
    
    // Parser functions (same as before)
    void parseE() {
        parseT();
        parseEPrime();
    }
    
    void parseEPrime() {
        if (lookahead.type == TOK_PLUS) {
            match(TOK_PLUS);
            parseT();
            parseEPrime();
        }
    }
    
    void parseT() {
        parseF();
        parseTPrime();
    }
    
    void parseTPrime() {
        if (lookahead.type == TOK_MUL) {
            match(TOK_MUL);
            parseF();
            parseTPrime();
        }
    }
    
    void parseF() {
        if (lookahead.type == TOK_LPAREN) {
            match(TOK_LPAREN);
            parseE();
            match(TOK_RPAREN);
        } else if (lookahead.type == TOK_ID) {
            match(TOK_ID);
        } else if (lookahead.type == TOK_NUM) {
            match(TOK_NUM);
        } else {
            std::cerr << "Error: Expected id, num, or '('" << std::endl;
            exit(1);
        }
    }
    
    void parse() {
        parseE();
        if (lookahead.type != TOK_END) {
            std::cerr << "Error: Extra input" << std::endl;
            exit(1);
        }
        std::cout << "Parse successful!" << std::endl;
    }
};
\end{lstlisting}

\section{Contoh Lengkap: Parser untuk Ekspresi Aritmatika}

Berikut adalah contoh lengkap implementasi recursive descent parser untuk ekspresi aritmatika yang dapat menangani:
\begin{itemize}
    \item Operasi penjumlahan dan perkalian
    \item Precedence (perkalian lebih tinggi dari penjumlahan)
    \item Left associativity
    \item Parentheses
    \item Identifier dan literal angka
    \item Error reporting yang informatif
\end{itemize}

\begin{lstlisting}[language=C++, caption={Parser lengkap untuk ekspresi aritmatika}]
#include <iostream>
#include <string>
#include <vector>
#include <cctype>
#include <stdexcept>

enum TokenType {
    TOK_ID, TOK_NUM, TOK_PLUS, TOK_MINUS, TOK_MUL, TOK_DIV,
    TOK_LPAREN, TOK_RPAREN, TOK_END, TOK_ERROR
};

struct Token {
    TokenType type;
    std::string lexeme;
    int line, col;
    
    Token(TokenType t, const std::string& l, int ln, int c)
        : type(t), lexeme(l), line(ln), col(c) {}
};

class ArithmeticParser {
private:
    std::string input;
    size_t pos;
    int line, col;
    Token lookahead;
    std::vector<std::string> errors;
    
    void skipWhitespace() {
        while (pos < input.size() && isspace(input[pos])) {
            if (input[pos] == '\n') {
                line++;
                col = 1;
            } else {
                col++;
            }
            pos++;
        }
    }
    
    Token nextToken() {
        skipWhitespace();
        
        if (pos >= input.size()) {
            return Token(TOK_END, "", line, col);
        }
        
        char c = input[pos];
        int startLine = line, startCol = col;
        
        // Identifier
        if (isalpha(c) || c == '_') {
            std::string lexeme;
            while (pos < input.size() && 
                   (isalnum(input[pos]) || input[pos] == '_')) {
                lexeme += input[pos++];
                col++;
            }
            return Token(TOK_ID, lexeme, startLine, startCol);
        }
        
        // Number
        if (isdigit(c)) {
            std::string lexeme;
            while (pos < input.size() && isdigit(input[pos])) {
                lexeme += input[pos++];
                col++;
            }
            return Token(TOK_NUM, lexeme, startLine, startCol);
        }
        
        // Operators
        pos++;
        col++;
        switch (c) {
            case '+': return Token(TOK_PLUS, "+", startLine, startCol);
            case '-': return Token(TOK_MINUS, "-", startLine, startCol);
            case '*': return Token(TOK_MUL, "*", startLine, startCol);
            case '/': return Token(TOK_DIV, "/", startLine, startCol);
            case '(': return Token(TOK_LPAREN, "(", startLine, startCol);
            case ')': return Token(TOK_RPAREN, ")", startLine, startCol);
            default: 
                return Token(TOK_ERROR, std::string(1, c), startLine, startCol);
        }
    }
    
    void match(TokenType expected) {
        if (lookahead.type == expected) {
            lookahead = nextToken();
        } else {
            std::string msg = "Expected " + tokenToString(expected) +
                            " but got " + lookahead.lexeme +
                            " at line " + std::to_string(lookahead.line) +
                            ", col " + std::to_string(lookahead.col);
            errors.push_back(msg);
            throw std::runtime_error(msg);
        }
    }
    
    std::string tokenToString(TokenType t) {
        switch (t) {
            case TOK_ID: return "identifier";
            case TOK_NUM: return "number";
            case TOK_PLUS: return "'+'";
            case TOK_MINUS: return "'-'";
            case TOK_MUL: return "'*'";
            case TOK_DIV: return "'/'";
            case TOK_LPAREN: return "'('";
            case TOK_RPAREN: return "')'";
            case TOK_END: return "end of input";
            default: return "unknown";
        }
    }
    
public:
    ArithmeticParser(const std::string& s) 
        : input(s), pos(0), line(1), col(1) {
        lookahead = nextToken();
    }
    
    // E -> T E'
    void parseE() {
        parseT();
        parseEPrime();
    }
    
    // E' -> (+ | -) T E' | epsilon
    void parseEPrime() {
        if (lookahead.type == TOK_PLUS || lookahead.type == TOK_MINUS) {
            TokenType op = lookahead.type;
            match(op);
            parseT();
            parseEPrime();
        }
    }
    
    // T -> F T'
    void parseT() {
        parseF();
        parseTPrime();
    }
    
    // T' -> (* | /) F T' | epsilon
    void parseTPrime() {
        if (lookahead.type == TOK_MUL || lookahead.type == TOK_DIV) {
            TokenType op = lookahead.type;
            match(op);
            parseF();
            parseTPrime();
        }
    }
    
    // F -> ( E ) | id | num
    void parseF() {
        if (lookahead.type == TOK_LPAREN) {
            match(TOK_LPAREN);
            parseE();
            match(TOK_RPAREN);
        } else if (lookahead.type == TOK_ID) {
            match(TOK_ID);
        } else if (lookahead.type == TOK_NUM) {
            match(TOK_NUM);
        } else {
            std::string msg = "Expected identifier, number, or '(' at line " +
                            std::to_string(lookahead.line) +
                            ", col " + std::to_string(lookahead.col);
            errors.push_back(msg);
            throw std::runtime_error(msg);
        }
    }
    
    bool parse() {
        try {
            parseE();
            if (lookahead.type != TOK_END) {
                errors.push_back("Extra input after expression");
                return false;
            }
            return errors.empty();
        } catch (...) {
            return false;
        }
    }
    
    void printErrors() {
        for (const auto& err : errors) {
            std::cerr << err << std::endl;
        }
    }
};

int main() {
    std::string input;
    std::cout << "Enter expression: ";
    std::getline(std::cin, input);
    
    ArithmeticParser parser(input);
    if (parser.parse()) {
        std::cout << "Parse successful!" << std::endl;
    } else {
        std::cout << "Parse failed!" << std::endl;
        parser.printErrors();
    }
    
    return 0;
}
\end{lstlisting}

\section{Kesimpulan}

Dalam bab ini, kita telah mempelajari:

\begin{enumerate}
    \item Top-down parsing adalah teknik parsing yang membangun parse tree dari root ke leaves
    \item LL parsing adalah kelas top-down parsing yang membaca input left-to-right dan menghasilkan leftmost derivation
    \item Recursive descent parsing adalah implementasi top-down parsing di mana setiap non-terminal direpresentasikan sebagai fungsi
    \item Precedence dan associativity di-handle melalui struktur grammar yang tepat
    \item Error recovery memungkinkan parser untuk melanjutkan setelah menemukan error
    \item Lexer dan parser dapat diintegrasikan dalam satu implementasi yang efisien
\end{enumerate}

Recursive descent parsing adalah teknik yang sangat cocok untuk implementasi manual parser karena mudah dipahami dan diimplementasikan. Namun, perlu diingat bahwa grammar harus dalam bentuk yang sesuai (tanpa left recursion, sudah di-factoring) untuk dapat di-parse dengan pendekatan ini.

\section{Latihan}

\begin{enumerate}
    \item Implementasikan recursive descent parser untuk grammar berikut:
    \begin{verbatim}
    S -> if E then S else S | id := E | while E do S
    E -> E + T | T
    T -> T * F | F
    F -> ( E ) | id | num
    \end{verbatim}
    
    \textbf{Perhatikan:} Grammar ini memiliki left recursion. Anda perlu mengeliminasi left recursion terlebih dahulu.
    
    \item Modifikasi parser ekspresi aritmatika untuk menambahkan operator unary minus (misalnya \texttt{-5} atau \texttt{-(3 + 4)}).
    
    \item Implementasikan error recovery pada parser yang telah Anda buat. Test dengan input yang mengandung multiple errors.
    
    \item Buatlah parser yang dapat mengevaluasi ekspresi boolean dengan operator \texttt{AND}, \texttt{OR}, dan \texttt{NOT}. Perhatikan precedence: \texttt{NOT} > \texttt{AND} > \texttt{OR}.
    
    \item Bandingkan recursive descent parser dengan table-driven LL parser. Apa keuntungan dan kerugian masing-masing pendekatan?
    
    \item Implementasikan parser untuk ekspresi dengan right-associative operator (misalnya operator assignment \texttt{=}).
\end{enumerate}

\section{Referensi dan Bahan Bacaan Lanjutan}

Untuk memperdalam pemahaman tentang top-down parsing dan recursive descent, mahasiswa disarankan membaca:

\begin{itemize}
    \item \textbf{Dragon Book}: Aho, Lam, Sethi, \& Ullman (2006). \textit{Compilers: Principles, Techniques, and Tools} \cite{aho2006compilers} - Bab 4: Syntax Analysis, Section 4.4: Top-Down Parsing
    
    \item \textbf{Engineering a Compiler}: Cooper \& Torczon (2011) \cite{cooper2011engineering} - Bab 3: Scanners, Section 3.4: Top-Down Parsing
    
    \item \textbf{OpenGenus Tutorial}: Build Lexer \cite{opengenus2024lexer} - Bagian tentang recursive descent parsing
    
    \item \textbf{USNA Course Notes}: Top-Down Parsing \footnote{\url{https://www.usna.edu/Users/cs/wcbrown/courses/F20SI413/lec/l09/lec.html}}
    
    \item \textbf{Ernest Chu Course Notes}: Syntax Analysis - Top-Down Parsing \footnote{\url{https://ernestchu.github.io/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html}}
    
    \item \textbf{TutorialsPoint}: Compiler Design - Top Down Parser \footnote{\url{https://www.tutorialspoint.com/compiler_design/compiler_design_top_down_parser.htm}}
\end{itemize}
