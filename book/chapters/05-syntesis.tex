% Chapter 5: Syntesis
\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Syntesis}

\section{Pengertian Syntesis}
Sintesis dalam kompilasi mengacu pada transformasi representasi program dari bentuk abstrak yang dianotasi menjadi bentuk menengah dan akhirnya kode mesin. Tahap ini memanfaatkan informasi yang diperoleh dari analisis leksikal, sintaksis, dan semantik untuk menyusun urutan instruksi yang setara secara semantik. Fokusnya adalah efisiensi dan korektitas hasil. Keterkaitan erat antara desain IR, optimisasi, dan pembangkitan kode membuat tahap ini menjadi area eksplorasi intensif dalam praktik kompilasi \citep{LLVMOverview,WikiOptimization}.

Pada perspektif arsitektur, sintesis membagi kerja antara generator kode menengah, pengoptimal, dan pembangkit kode akhir. Setiap komponen memiliki antarmuka yang jelas agar dapat diuji dan dikembangkan secara terpisah. Prinsip modularitas ini memfasilitasi evolusi sistem dan portabilitas lintas platform. Studi kasus pada LLVM menunjukkan keuntungan besar dari IR yang kaya dan analisis dataflow yang kuat. Temuan ini membimbing desain komponen-komponen berikutnya.

\section{Intermediate Code Generator}
\subsection{Three Address Code (TAC)}
TAC menyediakan bentuk representasi yang memecah ekspresi kompleks menjadi operasi primitif dengan paling banyak tiga alamat. Struktur ini memudahkan analisis data dan optimisasi berbasis aliran kontrol. Kelebihannya adalah keterbacaan, kemudahan transformasi, dan kedekatan dengan model mesin. Dalam praktik, TAC menjadi jembatan dari AST ke IR mesin yang lebih spesifik. Rujukan pengantar memberikan contoh konstruksi TAC untuk berbagai ekspresi \citep{WikiTAC}.

Penggunaan nama temporer yang sistematis memudahkan analisis dependensi dan pengangkatan konstanta. Bentuk SSA pada tahap selanjutnya menyederhanakan banyak optimisasi berbasis data. Keterkaitan ini menjadikan TAC fondasi yang kokoh untuk transformasi lanjut \citep{WikiTAC}. Dengan rancangan yang konsisten, lintasan optimisasi menjadi lebih jelas.

\subsection{Quadruples}
Quadruple merepresentasikan instruksi TAC sebagai tupel \texttt{(op, arg1, arg2, result)} yang eksplisit. Notasi ini memudahkan manipulasi dan analisis karena bidang-bidangnya terpisah jelas. Implementasi tabel simbol dan manajer temporer mendukung konsistensi referensi antar instruksi. Pada tahap lanjut, struktur quadruple memudahkan pemetaan ke instruksi target. Gaya representasi ini banyak digunakan dalam materi ajar dan prototipe.

Struktur eksplisit juga mempermudah serialisasi dan inspeksi untuk kebutuhan debug dan uji. Ketika kebutuhan analisis berubah, bidang tambahan dapat ditambahkan tanpa mengganggu alat yang ada. Fleksibilitas ini menjadikannya format yang ramah pengembangan. Dampaknya adalah waktu iterasi yang lebih singkat.

\subsection{Triples}
Triples menghilangkan kolom hasil eksplisit dan menggunakan referensi posisi untuk menyatakan dependensi antar instruksi. Pendekatan ini mengurangi kebutuhan nama temporer namun menambah kompleksitas pengelolaan. Dalam beberapa konteks, triples menawarkan jejak memori yang lebih kecil. Pemilihan antara quadruple dan triples bergantung pada kemudahan transformasi yang diinginkan. Keduanya menangkap esensi TAC dengan kompromi yang berbeda.

Referensi posisi menuntut kehati-hatian pada transformasi yang mengubah urutan instruksi. Mekanisme penomoran ulang dan peta jejak membantu menjaga konsistensi. Karena itu, triples lebih cocok pada tahap di mana urutan relatif stabil. Pilihan yang tepat mengurangi biaya pemeliharaan.

\subsection{Postfix Notation}
Notasi postfix atau Reverse Polish Notation memudahkan evaluasi ekspresi menggunakan \emph{stack} tanpa perlu kurung. Dalam konteks kompilasi, notasi ini sering menjadi perantara dalam pembentukan TAC atau langsung dipetakan ke instruksi \emph{stack machine}. Sifat deterministiknya menyederhanakan implementasi evaluator ekspresi. Walau kurang ekspresif untuk struktur kontrol, notasi ini tetap berguna untuk segmen perhitungan. Rujukan terbuka menyediakan pengantar dan contoh \citep{WikiPostfix}.

Konversi dari notasi infiks ke postfix dapat dilakukan dengan algoritma Shunting Yard yang sederhana. Representasi ini mengurangi kebutuhan \emph{lookahead} saat evaluasi. Meskipun demikian, pemodelan kontrol aliran memerlukan struktur tambahan di luar postfix \citep{WikiPostfix}. Dalam praktik, notasi ini menjadi komponen dalam pipeline yang lebih luas.

\subsection{Syntax Tree}
Pohon sintaks, khususnya AST, menyediakan struktur hirarkis yang menjadi sumber kebenaran sebelum translasi. Anotasi tipe dan informasi cakupan memperkaya simpul untuk keputusan sintesis yang tepat. Transformasi dari AST ke TAC mengikuti skema translasi yang konsisten. Kualitas desain AST memengaruhi kemudahan implementasi dan peluang optimisasi. Literatur ringkas menyoroti praktik umum dalam pemodelan AST \citep{WikiAST}.

Desain simpul yang kaya atribut memperkecil kebutuhan struktur tambahan pada tahap berikutnya. Penggunaan tipe sum yang eksplisit meningkatkan keamanan dan kejelasan akses. Praktik ini memudahkan pemeliharaan pada proyek jangka panjang \citep{WikiAST}. Dengan desain yang baik, sintesis menjadi lebih dapat diprediksi.

\section{Code Optimization}
\subsection{Optimasi Lokal}
Optimasi lokal beroperasi pada blok dasar untuk memperbaiki efisiensi tanpa mempertimbangkan aliran kontrol global. Teknik umum meliputi \emph{constant folding}, penghapusan kode mati, dan \emph{strength reduction}. Transformasi ini relatif aman dan mudah diverifikasi, cocok untuk tahap awal pengoptimalan \citep{WikiConstantFolding,WikiDCE,WikiStrengthReduction}. Efek kumulatifnya signifikan ketika diterapkan secara sistematis.

Validasi keamanan transformasi lokal dilakukan dengan menghormati ketentuan ketepatan numerik dan efek samping. Kumpulan uji regresi menjaga agar perubahan tidak memperkenalkan perilaku baru yang tak diinginkan. Dokumentasi praktik umum menyediakan pedoman penerapan yang aman \citep{WikiOptimization}. Dengan disiplin ini, kualitas tetap terjaga.

\subsubsection{Constant Folding}
\emph{Constant folding} menggantikan ekspresi yang dapat dievaluasi pada waktu kompilasi dengan nilai konstan untuk mengurangi kerja saat eksekusi. Teknik ini juga membuka peluang transformasi lanjutan dengan menyederhanakan pohon ekspresi. Implementasinya membutuhkan evaluasi yang berhati-hati untuk menghindari perubahan perilaku, misalnya pada representasi floating point. Dengan validasi ketat, manfaat performa dapat diperoleh tanpa risiko.

Pada arsitektur tertentu, perubahan urutan evaluasi dapat memengaruhi penanganan NaN dan tak hingga. Oleh karena itu, evaluasi pada waktu kompilasi harus mengikuti semantik bahasa, bukan mesin. Konsistensi ini mencegah perbedaan hasil lintas platform. Dokumentasi standar menjadi acuan pelaksanaan.

\subsubsection{Dead Code Elimination}
Eliminasi kode mati menghapus instruksi yang tidak memengaruhi hasil akhir program. Identifikasi dilakukan melalui analisis liveness dan ketergantungan data. Selain mengurangi ukuran kode, teknik ini menyederhanakan jalur eksekusi dan menurunkan konsumsi energi. Kombinasinya dengan \emph{constant propagation} semakin memperluas cakupan penghapusan. Literatur referensi menyediakan formulasi dataflow untuk implementasi yang sistematis \citep{WikiDCE}.

Analisis harus memperhitungkan efek samping seperti I/O dan penulisan memori agar tidak menghapus instruksi yang berpengaruh. Penandaan volatil pada variabel bertindak sebagai penghalang untuk transformasi agresif. Kebijakan ini menjaga kesahihan program \citep{WikiDCE}. Dengan pengujian menyeluruh, regresi dapat dihindari.

\subsubsection{Strength Reduction}
\emph{Strength reduction} mengganti operasi mahal dengan padanannya yang lebih murah, misalnya mengubah perkalian berulang menjadi penjumlahan atau pergeseran. Transformasi ini sering muncul pada optimisasi loop dengan induksi variabel. Selain menghemat siklus, ia juga dapat menurunkan tekanan register. Evaluasi keamanan transformasi wajib mempertimbangkan overflow dan aturan pembulatan. Sumber terbuka memberikan contoh konteks aplikatif yang jelas \citep{WikiStrengthReduction}.

Optimisasi ini sering disertai dengan pemilihan instruksi yang lebih efisien untuk memperkuat dampaknya. Analisis batas mencegah perubahan yang memicu overflow pada tipe bilangan terbatas. Pendekatan yang berhati-hati menghasilkan perbaikan stabil tanpa regresi. Dokumentasi arsitektur membantu kalibrasi keputusan.

\subsection{Optimasi Global}
\subsubsection{Loop Optimization}
Optimisasi loop menargetkan bagian program yang paling sering dieksekusi untuk perbaikan kinerja besar. Teknik seperti unrolling, invariant code motion, dan vectorization mengurangi overhead kontrol dan meningkatkan pemanfaatan perangkat keras. Analisis dependensi memastikan transformasi aman terhadap perubahan makna. Interaksi dengan hierarki memori menjadi faktor kunci dalam hasil akhir. Materi referensi menguraikan prasyarat dan dampak teknik ini \citep{WikiLoopOptimization}.

Interaksi dengan predikat cabang dan prediksi cabang pada CPU modern memengaruhi efektivitas unrolling. Selain itu, faktor ukuran cache menentukan titik manis untuk vectorization. Evaluasi empiris pada beban kerja target diperlukan untuk memilih strategi terbaik \citep{WikiLoopOptimization}. Hasil yang diukur mengarahkan keputusan yang tepat.

\subsubsection{Common Subexpression Elimination}
Eliminasi subekspresi umum menghindari evaluasi ulang perhitungan yang sama dengan menggunakan kembali hasil yang disimpan. Analisis jangkauan nilai dan ketergantungan memastikan bahwa penyederhanaan tidak mengubah perilaku. Teknik ini sering dipadukan dengan propagasi konstanta untuk dampak yang lebih besar. Implementasi yang efektif bergantung pada identifikasi blok dominator dan SSA. Rujukan memberikan tinjauan metode dan batasannya \citep{WikiCSE}.

Pengindeksan ekspresi dengan bentuk kanonik mengurangi peluang redundansi yang tidak terdeteksi. Kesesuaian dengan model memori memastikan penghapusan tidak melanggar aturan visibilitas. Dengan analisis yang cermat, CSE memberikan penghematan substansial \citep{WikiCSE}. Integrasi dengan dataflow meningkatkan akurasi.

\subsection{Data Flow Analysis}
\subsubsection{Reaching Definition}
Analisis \emph{reaching definition} menentukan asal-usul nilai yang mencapai titik tertentu dalam program. Informasi ini penting untuk berbagai optimisasi seperti \emph{copy propagation} dan DCE. Formulasi dataflow memanfaatkan persamaan set yang diselesaikan hingga mencapai titik tetap. Representasi CFG dan blok dasar menjadi substrat perhitungan. Referensi terbuka menyediakan contoh formulasi dan algoritma penyelesaiannya \citep{WikiReachingDef}.

Implementasi efisien menggunakan bitset dan operasi himpunan teroptimalkan agar skalabel. Representasi SSA menyederhanakan beberapa kasus dengan memperjelas asal-usul nilai. Pengujian pada grafik kontrol yang bervariasi memastikan kekokohan \citep{WikiReachingDef}. Dengan peralatan yang tepat, biaya komputasi dapat ditekan.

\subsubsection{Live Variable Analysis}
Analisis variabel hidup mengidentifikasi nilai yang masih dibutuhkan di masa depan, memandu alokasi register dan penghapusan kode. Dengan mengetahui nilai mana yang tidak lagi digunakan, kompiler dapat mengosongkan register dan meminimalkan penyimpanan memori. Prosesnya berjalan mundur pada CFG dengan persamaan standard liveness. Hasilnya menginformasikan banyak keputusan pengoptimalan tingkat rendah \citep{WikiLiveVariables}.

Informasi liveness digunakan untuk membangun graf interferensi pada alokasi register berbasis pewarnaan. Penggabungan nilai yang tidak saling interferen mengurangi tekanan register. Hasilnya adalah eksekusi yang lebih cepat dan jejak memori yang lebih kecil. Pendekatan ini membuktikan efektivitasnya pada banyak arsitektur.

\subsubsection{Available Expression}
Analisis ekspresi tersedia menandai ekspresi yang nilainya telah dihitung dan belum diubah di sepanjang jalur. Pengetahuan ini memungkinkan pemakaian ulang hasil tanpa evaluasi ulang. Kombinasi dengan CSE memberikan perbaikan yang konsisten pada runtime. Evaluasi yang akurat membutuhkan pemahaman efek samping dan aliasing. Sumber terbuka merangkum formulasi dan contoh aplikatif \citep{WikiAvailableExpr}.

Perubahan jalur karena cabang bersyarat atau predikat menuntut pembaruan informasi ketersediaan secara hati-hati. Ketika efek samping hadir, definisi ketersediaan harus dibatasi pada ekspresi murni. Prinsip ini mencegah kesalahan optimisasi \citep{WikiAvailableExpr}. Dokumentasi yang baik memudahkan verifikasi.

\section{Code Generator}
\subsection{Target Language}
Bahasa target adalah ISA atau mesin abstrak tempat program akan dieksekusi. Spesifikasi instruksi, mode pengalamatan, dan konvensi pemanggilan membentuk batasan desain pembangkitan kode. Keputusan representasi data dan endianness juga berpengaruh pada pemetaan nilai. Kompiler harus mematuhi ABI untuk interoperabilitas dan kompatibilitas biner. Dokumentasi platform menjadi referensi utama dalam implementasi.

Dokumentasi instruksi vektor dan SIMD membuka peluang percepatan signifikan pada beban kerja numerik. Dukungan untuk \emph{atomics} dan sinkronisasi menentukan strategi pada program paralel. Keselarasan dengan ABI memastikan interoperabilitas pustaka pihak ketiga. Dengan pengetahuan ini, pemetaan menjadi lebih efektif.

\subsection{Register Allocation}
Alokasi register menentukan pemetaan nilai sementara ke set register terbatas pada prosesor target. Tujuan utamanya adalah meminimalkan \emph{spilling} ke memori yang mahal. Pendekatan graf pewarnaan dan heuristik liveness umum digunakan untuk mencapai kompromi antara optimalitas dan waktu kompilasi. Kualitas alokasi memengaruhi performa secara langsung \citep{WikiRegisterAllocation}. Integrasi dengan pemilihan instruksi memperhalus hasil akhir.

\emph{Spilling} yang terkontrol mempertimbangkan hirarki memori untuk mengurangi penalti latensi. Koordinasi dengan penjadwalan instruksi menghindari konflik sumber daya. Integrasi yang baik menghasilkan kode target yang kompak dan cepat \citep{WikiRegisterAllocation}. Evaluasi mikro memastikan keputusan tepat sasaran.

\subsection{Instruction Selection}
Pemilihan instruksi memetakan operasi IR ke instruksi target yang setara dengan mempertimbangkan biaya. Teknik seperti pencocokan pola pada pohon atau DAG memungkinkan pemilihan yang efisien dan lokal optimal. Ketersediaan instruksi majemuk dan addressing mode khusus membuka peluang pemangkasan langkah. Evaluasi biaya yang akurat memerlukan model arsitektur yang memadai. Sumber referensi memberikan gambaran metode dan komprominya \citep{WikiInstructionSelection}.

Pendekatan \emph{tree covering} dengan biaya dinamis mendekati optimal di banyak kasus praktis. Perluasan ke DAG memperbesar cakupan tetapi meningkatkan kompleksitas. Model biaya yang akurat memerlukan kalibrasi terhadap perangkat keras riil \citep{WikiInstructionSelection}. Praktik ini memastikan hasil yang konsisten.

\subsection{Peephole Optimization}
Optimisasi \emph{peephole} menyempurnakan urutan instruksi lokal dengan mengganti pola suboptimal dengan padanannya yang lebih baik. Transformasi ini dilakukan pada tingkat akhir untuk memanfaatkan konteks target secara spesifik. Dampaknya berkisar pada pengurangan ukuran kode dan penghematan siklus eksekusi. Meskipun lokal, akumulasi perbaikan sering terlihat signifikan pada praktik. Tinjauan ringkas dapat ditemukan pada referensi terbuka \citep{WikiPeephole}.

Aturan peephole sebaiknya diekspresikan sebagai koleksi pola yang mudah diuji dan diperluas. Pengukuran berkala memastikan bahwa aturan lama tetap relevan pada arsitektur baru. Disiplin kurasi ini menjaga efektivitas jangka panjang \citep{WikiPeephole}. Dengan umpan balik empiris, set aturan terus meningkat kualitasnya.

% Bibliografi saat kompilasi per-bab
\IfSubfilesClassLoaded{%
\bibliographystyle{plainnat}
\bibliography{../references}
}{}

\end{document}
