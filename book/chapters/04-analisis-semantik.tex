% Chapter 4: Analisis Semantik
\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Analisis Semantik}

\section{Pengertian Analisis Semantik}
Analisis semantik memastikan bahwa struktur sintaks yang valid juga bermakna sesuai aturan bahasa. Proses ini mencakup pemeriksaan tipe, cakupan nama, dan aturan konsistensi lain yang tidak dapat ditangkap oleh grammar bebas konteks. Representasi pohon yang telah dianotasi mempersingkat akses terhadap informasi yang diperlukan untuk verifikasi. Hasilnya adalah program yang memenuhi invarian penting sebelum diteruskan ke tahapan berikutnya. Landasan konseptualnya dijelaskan dalam sumber terbuka dan buku teks \citep{Mogensen2010,Wirth1996}.

Di banyak bahasa modern, analisis semantik juga menjadi tempat untuk mengekspresikan kebijakan keamanan dan pengetatan aturan gaya. Informasi yang diperkaya pada AST, seperti anotasi tipe dan cakupan, mengalir ke tahap optimisasi untuk memastikan transformasi yang aman. Desain tahap ini berdampak langsung pada kualitas pesan kesalahan dan pengalaman pengguna. Karena itu, struktur data yang jelas dan antarmuka yang stabil antara modul menjadi kritis. Referensi terbuka menyoroti praktik terbaik yang dapat diadopsi di ruang kelas \citep{CS143}.

Keterkaitan tahap semantik dengan representasi menengah sangat erat, karena informasi tipe dan cakupan memandu translasi yang setara. Kualitas pesan kesalahan yang dihasilkan pada tahap ini meningkatkan pengalaman pengembang dan keandalan sistem. Strategi pelaporan yang baik menyajikan lokasi, sebab, dan saran perbaikan secara ringkas. Selain itu, analisis semantik sering kali memperkaya struktur dengan anotasi yang dimanfaatkan pada optimisasi. Hubungan ini menegaskan peran sentral semantik dalam pipeline kompilasi.

\section{Attribute Grammar}
\subsection{Synthesized Attributes}
Atribut tersintesis dihitung dari anak ke induk pada pohon sintaks, merangkum informasi hasil komputasi lokal. Contohnya, tipe ekspresi atau nilai konstanta dapat dinaikkan untuk digunakan oleh konteks yang lebih luas. Pola pengangkatan ini menjaga modularitas dan kejelasan evaluasi. Dalam implementasi, evaluasi atribut perlu diatur urutannya agar tidak terjadi ketergantungan siklik. Prinsip ini didokumentasikan dengan baik dalam literatur pendidikan \citep{WikiAttributeGrammar}.

Penghitungan yang disiplin memastikan bahwa nilai yang diperlukan tersedia tepat waktu untuk aturan berikutnya. Pada beberapa kerangka, penjadwalan atribut dilakukan otomatis berdasarkan grafik ketergantungan. Mekanisme ini mengurangi beban reasoning manual dan mencegah kebuntuan evaluasi. Dengan pendekatan ini, implementasi menjadi lebih dapat diprediksi dan mudah diuji.

Penempatan evaluasi yang tepat menghindari akses ke nilai yang belum dihitung pada traversal. Secara praktik, evaluasi dilakukan dengan urutan topologis pada DAG dependensi. Pendekatan ini memastikan determinisme dan menghindari kebuntuan logika \citep{WikiAttributeGrammar}. Dengan kebijakan yang konsisten, hasil evaluasi dapat direproduksi.

\subsection{Inherited Attributes}
\begin{figure}[t]
  \centering
  \begin{tikzpicture}[
    node distance=1.6cm,
    box/.style={rectangle, draw, rounded corners, align=center, minimum width=2.6cm, minimum height=0.9cm},
    >=Stealth
  ]
    % Syntax tree skeleton
    \node[box] (e) {E};
    \node[box, below left=of e] (e1) {E};
    \node[box, below right=of e] (t) {T};
    \node[box, below=of e1] (id1) {id};
    \node[box, below=of t] (id2) {id};
    % Inherited and synthesized flows
    \draw[->, dashed] (e) -- node[left]{T.expectedType} (e1);
    \draw[->, dashed] (e) -- node[right]{T.expectedType} (t);
    \draw[->] (id1) -- node[left]{E.type} (e1);
    \draw[->] (id2) -- node[right]{T.type} (t);
    \draw[->, thick] (e1) -- node[above]{synth E.type} (e);
    \draw[->, thick] (t) -- node[above]{synth T.type} (e);
  \end{tikzpicture}
  \caption{Skema aliran atribut: atribut terwariskan (garis putus-putus) mengalir ke bawah, atribut tersintesis (garis tebal) mengalir ke atas \citep{WikiAttributeGrammar,WikiSDT}.}
  \label{fig:attr-flow}
\end{figure}
Atribut terwariskan mengalir dari induk ke anak untuk menyediakan konteks yang diperlukan selama evaluasi. Informasi seperti lingkungan penamaan atau tipe yang diharapkan membantu memandu keputusan lokal. Kombinasi atribut terwariskan dan tersintesis menghasilkan aliran informasi dua arah yang kaya. Penjadwalan evaluasi harus memastikan ketersediaan nilai sebelum digunakan. Kerangka formal ini menjadi tulang punggung \emph{syntax-directed definition}.

Penggunaan atribut terwariskan yang berlebihan dapat menyulitkan pelacakan aliran informasi pada pohon yang besar. Oleh sebab itu, penyusunan lingkungan yang eksplisit dan terstruktur membantu mengelola kompleksitas. Pada implementasi nyata, abstraksi tabel simbol dan konteks skop sering menggantikan atribut terwariskan murni. Kompromi ini menjaga keterbacaan dan kinerja sistem.

Penggunaan lingkungan eksplisit pada simpul memudahkan propagasi informasi seperti cakupan dan tipe yang diharapkan. Pada implementasi, pembatasan akses mencegah pencampuran data yang tidak sah. Hasilnya adalah evaluasi yang modular dan dapat diuji. Pendekatan ini juga memudahkan pelokalisasian kesalahan.

\section{Syntax Directed Translation}
\subsection{Syntax Directed Definition (SDD)}
SDD memformalkan kaitan antara produksi grammar dan evaluasi atribut melalui kumpulan aturan. Aturan tersebut menjelaskan komputasi nilai dan efek samping yang terjadi selama penurunan atau kenaikan pohon. Desain SDD yang baik menghindari siklus dependensi dan memastikan determinisme hasil. Dalam praktik, SDD menjadi cetak biru untuk menghasilkan kode menengah dari struktur sintaks. Referensi umum memberikan pola desain yang dapat diadaptasi \citep{WikiSDT}.

Pemetaan yang konsisten dari aturan ke representasi menengah memungkinkan audit dan pembuktian korektitas lokal. Dokumentasi aturan dengan contoh kecil mempercepat proses debugging dan pengujian unit. Dalam lingkungan pengajaran, SDD memperjelas hubungan antara notasi formal dan implementasi konkret. Dengan demikian, mahasiswa memperoleh intuisi yang kuat tentang translasi terarah sintaks.

Representasi aturan dalam bentuk fungsi murni meningkatkan kejelasan dan memudahkan pengujian. Ketika efek samping diperlukan, pembatasan tempat dan waktu eksekusi harus disepakati. Disiplin ini menjaga keterbacaan spesifikasi \citep{WikiSDT}. Dengan dokumentasi yang rapi, tim dapat berkolaborasi efektif.

\subsection{Translation Schemes}
Skema translasi menanamkan aksi semantik ke dalam produksi grammar, memungkinkan evaluasi terjadi seiring parsing. Pendekatan ini menggabungkan konstruksi pohon dengan pembentukan representasi menengah secara langsung. Tantangannya adalah menjaga keterbacaan dan meminimalkan efek samping yang menyulitkan analisis. Dengan disiplin desain, skema translasi menghasilkan alur yang efisien dan dapat diprediksi. Literatur pengantar menyediakan contoh-contoh skema yang representatif \citep{WikiSDT}.

Pembatasan aksi semantik pada lokasi yang terkontrol mengurangi kopling dengan parser dan memudahkan pemeliharaan. Ketika kebutuhan menjadi kompleks, pemisahan aksi ke tahap terpisah sering meningkatkan kejelasan. Pilihan ini bergantung pada ukuran bahasa dan tim yang terlibat. Materi pengantar menawarkan panduan untuk kedua pendekatan ini.

Strukturisasi aksi sebagai produksi pra/pasca memisahkan kekhawatiran antara parsing dan evaluasi. Hal ini juga memperjelas kapan representasi menengah harus dibentuk atau diperbarui. Contoh pada referensi menampilkan pola umum yang dapat diadaptasi \citep{WikiSDT}. Pendekatan ini meningkatkan keterbacaan dan pemeliharaan.

\section{Type Checking}
\subsection{Type System}
\begin{table}[t]
  \centering
  \caption{Ragam properti sistem tipe dan implikasinya pada kompilasi \citep{WikiTypeSystem}.}
  \label{tab:type-system}
  \begin{tabular}{@{}lll@{}}
    \toprule
    Dimensi & Varian & Implikasi singkat \\
    \midrule
    Waktu & Statis vs Dinamis & Deteksi awal vs fleksibilitas \\
    Kekuatan & Kuat vs Lemah & Jaminan keamanan vs kemudahan interfacing \\
    Inferensi & Ada vs Tidak & Ergonomi vs kebutuhan anotasi \\
    Polimorfisme & Parametrik vs Ad-hoc & Generik vs overload \\
    \bottomrule
  \end{tabular}
\end{table}
Sistem tipe memberikan aturan yang membatasi dan menstrukturkan penggunaan nilai serta operasi dalam bahasa. Dengan tipe, kompiler dapat mencegah kelas kesalahan yang besar sebelum eksekusi. Ragam sistem—dari statis ke dinamis, kuat ke lemah—memiliki implikasi terhadap desain pemeriksaan dan inferensi. Pilihan ini memengaruhi kesederhanaan kompilasi dan ekspresivitas bahasa. Sumber terbuka memberikan tinjauan komprehensif konsep dasar ini \citep{WikiTypeSystem}.

Implementasi pemeriksa tipe biasanya memanfaatkan unifikasi, inferensi lokal, atau pemeriksaan deklaratif bergantung pada paradigma bahasa. Kebijakan subtipe dan koersi memerlukan definisi yang eksplisit untuk menghindari ambiguitas. Dengan spesifikasi yang baik, pesan kesalahan dapat diarahkan pada sumber masalah, bukan gejalanya. Praktik ini mendukung pengalaman belajar yang lebih efektif.

Desain sistem tipe berdampak langsung pada pengalaman pengembang melalui kualitas diagnostik dan inferensi. Kompiler modern sering menyeimbangkan kekakuan dengan ergonomi agar tetap produktif. Tinjauan konsep dasar membantu menghindari jebakan implementasi \citep{WikiTypeSystem}. Dengan kerangka yang kuat, pemeriksaan menjadi lebih efektif.

\subsection{Type Expression}
Ekspresi tipe menyatakan konstruksi tipe majemuk seperti fungsi, array, dan struktur rekaman. Representasi formal memudahkan operasi unifikasi dan kompatibilitas yang dibutuhkan selama pemeriksaan. Notasi yang konsisten mempermudah implementasi dan pelaporan kesalahan yang jelas. Dalam implementasi, simbol tabel menyimpan pemetaan nama ke ekspresi tipe untuk akses cepat. Komponen ini menjadi bagian inti dari infrastruktur semantik.

Pada bahasa dengan generik, ekspresi tipe diperluas dengan parameter dan batasan yang memerlukan pemeriksaan tambahan. Identitas tipe dan kesetaraan struktural atau nominal harus ditetapkan dengan cermat. Keputusan ini berimbas pada interoperabilitas modul dan desain perpustakaan. Literatur terbuka membahas konsekuensinya terhadap desain bahasa modern \citep{WikiTypeSystem}.

Penanganan variasi parameter seperti kovarians dan kontravarians memerlukan notasi yang konsisten. Aspek ini penting pada bahasa berorientasi objek dan generik. Dokumentasi pengantar menekankan kehati-hatian pada pemetaan ke representasi internal. Kejelasan notasi memperkuat keandalan pemeriksaan.

\subsection{Type Checking Ekspresi}
Pemeriksaan tipe untuk ekspresi mengevaluasi kesesuaian operator dan operan berdasarkan aturan bahasa. Inferensi dapat digunakan untuk melengkapi tipe yang tidak dinyatakan eksplisit. Kesalahan ketidakcocokan terdeteksi lebih awal dengan memberikan pesan yang informatif. Pada bahasa dengan konversi implisit, aturan \emph{coercion} diterapkan untuk mempertahankan konsistensi \citep{WikiTypeChecking,WikiCoercion}. Proses ini memastikan operasi dievaluasi pada domain yang tepat.

Penanganan kelebihan beban operator dan resolusi metode memerlukan algoritme pemilihan yang konsisten. Penggunaan konteks ekspektasi tipe membantu memperkecil ruang pencarian kandidat. Dengan pelaporan yang jelas, pengguna dapat memahami alasan pemilihan atau penolakan. Praktik ini meningkatkan prediktabilitas perilaku bahasa.

Operasi polimorfik memerlukan resolusi \emph{overload} yang memadukan informasi tipe dari konteks dan argumen. Implementasi yang tepat menyiasati kasus ambigu dengan aturan prioritas. Ini meningkatkan prediktabilitas hasil kompilasi \citep{WikiTypeChecking}. Dengan kebijakan jelas, pengalaman pengguna menjadi lebih baik.

\subsection{Type Checking Statement}
Pemeriksaan pada pernyataan mencakup validasi kontrol aliran, cakupan variabel, dan kesesuaian tipe pada operasi penugasan dan pemanggilan. Struktur seperti percabangan dan perulangan memerlukan kondisi boolean yang valid dan cakupan yang benar. Penanganan fungsi memastikan jumlah dan jenis argumen sesuai dengan deklarasi. Dengan kebijakan yang konsisten, kompiler mencegah perilaku tak terdefinisi sejak dini. Praktik ini memperkuat keandalan program secara keseluruhan.

Pada konstruksi canggih seperti penanganan pengecualian, aturan propagasi tipe dan eksekusi perlu didefinisikan. Validasi penggunaan sumber daya yang tepat, seperti penutupan berkas, dapat ditopang oleh analisis semantik. Integrasi dengan analisis aliran data memperkaya kemampuan deteksi kesalahan. Hasilnya adalah sistem yang lebih aman dan dapat dipelihara.

Analisis jalur memastikan bahwa semua jalur eksekusi mematuhi aturan tipe dan pengembalian. Validasi variabel tak terinisialisasi mencegah perilaku tak terdefinisi. Praktik ini meningkatkan keandalan perangkat lunak sejak tahap awal. Dengan laporan yang jelas, perbaikan menjadi lebih cepat.

\subsection{Type Conversion dan Type Coercion}
Konversi tipe merujuk pada perubahan representasi nilai dari satu tipe ke tipe lain, baik eksplisit maupun implisit. \emph{Coercion} adalah bentuk implisit yang dilakukan oleh kompiler berdasarkan aturan bahasa. Walaupun meningkatkan ergonomi, coercion harus dibatasi agar tidak menyembunyikan kesalahan logika. Keputusan desain pada bagian ini memengaruhi prediktabilitas dan keamanan program. Literatur referensi membahas kompromi dan praktik yang seimbang \citep{WikiCoercion}.

Aturan konversi numerik memerlukan perhatian khusus terhadap overflow, pembulatan, dan presisi. Pada tipe referensi, pertimbangan keamanan memori dan waktu hidup menjadi penting. Dokumentasi yang jelas mengurangi kebingungan pengguna dan memudahkan diagnosa kesalahan. Prinsip ini memperbaiki kualitas ekosistem bahasa.

Konversi implisit lintas tipe numerik harus mempertimbangkan presisi dan \emph{overflow}. Kebijakan konversi yang jelas menghindari perbedaan perilaku lintas platform. Dokumentasi bahasa biasanya menetapkan aturan ini secara eksplisit \citep{WikiCoercion}. Dengan pedoman yang tegas, perilaku program tetap konsisten.

\section{Semantic Error}
\subsection{Jenis-jenis Semantic Error}
Kesalahan semantik meliputi ketidakcocokan tipe, penggunaan variabel tak terdefinisi, dan pelanggaran aturan visibilitas. Berbeda dari kesalahan sintaks, kesalahan ini terjadi pada struktur yang secara sintaks benar namun bermakna salah. Klasifikasi yang jelas membantu strategi deteksi dan pesan yang lebih informatif. Pengelompokan berdasarkan kategori memudahkan diagnostik dan perbaikan. Referensi pengantar memberikan contoh umum dan penjelasan konseptual \citep{WikiSemanticError}.

Kategori tambahan dapat mencakup pelanggaran efek samping yang tidak diizinkan, penggunaan sebelum inisialisasi, dan ketidaksesuaian kontrak antarmuka. Penetapan kategori membantu prioritisasi perbaikan dan desain pesan yang konsisten. Pada skala besar, metrik kejadian membantu memandu investasi perbaikan alat. Dengan demikian, proses rekayasa menjadi berbasis data.

Pemetaan kategori kesalahan ke kode dan tingkat keparahan membantu pengelolaan pada alat pengembang. Pelaporan yang konsisten mempermudah otomatisasi dalam pipeline integrasi berkelanjutan. Pendekatan ini mendorong praktik \emph{shift-left} dalam kualitas. Dengan diagnostik yang baik, waktu perbaikan menurun.

\subsection{Penanganan Semantic Error}
Penanganan yang efektif mencakup pelaporan yang presisi, pemulihan yang aman, dan pelacakan konteks untuk perbaikan. Teknik seperti penandaan lokasi, petunjuk perbaikan, dan batasan jumlah kesalahan menjaga alur kompilasi yang produktif. Dalam sistem besar, integrasi dengan IDE meningkatkan umpan balik melalui penyorotan dan saran perbaikan. Desain pesan yang empatik namun teknis mempercepat proses belajar mahasiswa. Tujuannya adalah membantu, bukan menghukum, saat kesalahan terjadi.

Strategi pelaporan bertingkat menghindari banjir kesalahan turunan dengan memfokuskan pada penyebab utama terlebih dahulu. Penyediaan sarana "+fix-it hints+" yang aman mempercepat perbaikan tanpa mengaburkan tanggung jawab pengguna. Dengan kerangka uji yang baik, kualitas diagnostik dapat diukur dan ditingkatkan secara iteratif. Pendekatan ini memperkaya pengalaman pengguna alat kompilasi.

% Bibliography when compiling this chapter standalone
\IfSubfilesClassLoaded{
\bibliographystyle{plainnat}
\bibliography{../references}
}{}

Strategi pemulihan terarah menjaga konsistensi struktur internal agar tahap berikut tetap dapat berjalan. Pengelompokan kesalahan yang serupa dalam satu laporan ringkas meningkatkan keterbacaan. Prinsip ini selaras dengan tujuan pendidikan untuk mempercepat pemahaman \citep{Mogensen2010}. Dengan pendekatan tersebut, proses iterasi menjadi lebih efisien.

% Bibliografi saat kompilasi per-bab
\IfSubfilesClassLoaded{%
\bibliographystyle{plainnat}
\bibliography{../references}
}{}

\end{document}
